<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多项式指数函数]]></title>
    <url>%2F2020%2F04%2F05%2Fpolexp%2F</url>
    <content type="text"><![CDATA[给出一个 $n-1$ 次多项式 $A(x)$, 求一个 $\mod x^n$ 下的多项式 $B(x)$, 满足 $B(x)\equiv e^{A(x)}$. 系数对 $998244353$ 取模。 前置定理与算法多项式对数函数。 根据复合函数求极限法则， e=\lim_{x\to\infty}\left(1+\frac1x\right)^x=\lim_{x\to0}(1+x)^{\frac1x} \lim_{x\to0}\frac{e^x-1}x=\lim_{x\to0}\frac{\left((1+x)^{\frac1x}\right)^x-1}x=\lim_{x\to0}\frac{1+x-1}x=1然后 $\exp x$ 对 $x$ 求导 (\exp x)^\prime_x=\lim_{\Delta x\to0}\frac{\exp(x+\Delta x)-\exp x}{\Delta x}=\lim_{\Delta x\to0}\frac{\exp x\cdot(e^{\Delta x}-1)}{\Delta x}=\exp x\cdot\lim_{\Delta x\to0}\frac{e^{\Delta x}-1}{\Delta x}因此 $(\exp x)^\prime_x=\exp x$. 令 $y=\exp x$. 则 $x=\ln y$, $\mathrm{d}y=\exp x\mathrm{d}x$. 1=\exp x\cdot\frac{\mathrm dx}{\mathrm dy}\Rightarrow\frac1{\exp x}=\frac{\mathrm dx}{\mathrm dy}\Rightarrow\frac1y=\frac{\mathrm dx}{\mathrm dy}所以 $(\ln y)^\prime_y=\frac1y$. 泰勒展开简略地说，如果要求一个易求导难求值的函数 $f(x)$ 上一点的函数值，可以构造一个函数 $g(x)$, 使得对于 $x$ 点他们的 $n$ 阶导函数函数值相等 f(x)\approx g(x)=g(x_0)+\frac{f^1(x_0)}{1!}(x-x_0)+\frac{f^2(x_0)}{2!}(x-x_0)^2+\cdots+\frac{f^n(x_0)}{n!}(x-x_0)^n+\cdots其中 $f^n(x_0)$ 代表对原函数图像上 $x_0$ 这个点进行 $n$ 阶求导。 牛顿迭代牛顿迭代可以用来求一个函数(多项式)的零点，即对于 $G(x)$, 求满足条件的多项式 $F(z)$. G(F(z))\equiv0\mod z^n假设已经求出了 G(F_0(z))\equiv0\mod z^{\left\lceil\frac z2\right\rceil}那么 F(z)\equiv F_0(z)-\frac{G(F_0(z))}{G^\prime(F_0(z))}\mod z^n多项式 exp现在我们需要计算 F(x)=e^{A(x)}两边同时取对数来消去 $e$. \ln F(x)-A(x)=0也就是求 G(F(x))=\ln F(x)-A(x)的零点，这里 $F(x)$ 是变量，$A(x)$ 是常量，求导得 G^\prime(F(x))=\frac1{F(x)}代入牛顿迭代的公式 F(x)\equiv F_0-\frac{G(F_0(x))}{G^\prime(F_0(x))}\equiv F_0(x)\left(1-\ln F_0(x)+A(x)\right)\mod x^n时间复杂度 T(n)=T\left(\frac n2\right)+O(n\log n)=O(n\log n)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt;constexpr auto MOD = 998244353LL;constexpr auto MAXN = (int)5e5;long long Pow(long long a,long long b, long long MOD = ::MOD)&#123; long long ans = 1LL; for(;b;b&gt;&gt;=1,(a*=a)%=MOD) if(b &amp; 1) (ans *= a) %= MOD; return ans;&#125;long long Module(long long a,const long long&amp; b)&#123; a+=b; return a&gt;=MOD ? a-MOD : a; &#125;long long&amp; s_Module(long long&amp; a, const long long&amp; b)&#123; a+=b; return a&gt;=MOD ? a-=MOD : a; &#125;namespace Poly&#123; constexpr auto g = 3LL; int r[MAXN]; int* GetR(const int&amp; totLv)&#123; int totNums = 1 &lt;&lt; totLv; *r=0; for(int i=1;i&lt;totNums;++i) r[i] = (r[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;totLv-1); return r; &#125; void NTT(long long* A,const int&amp; totLv, const long long&amp; type)&#123; int totNums = 1 &lt;&lt; totLv; for(int i=0;i&lt;totNums;++i) if(i &lt; r[i]) std::swap(A[i], A[r[i]]); long long temp,Omega,Omega_n; for(int i=0;i&lt;totLv;++i)&#123; Omega_n = Pow(g, (MOD-1)/(1LL&lt;&lt;i+1)); if(type == -1) Omega_n = Pow(Omega_n, MOD-2); for(int j=0;j&lt;totNums;j+=(1&lt;&lt;i+1))&#123; Omega = 1LL; for(int k=0;k&lt;(1&lt;&lt;i);++k)&#123; temp = (A[j+k+(1&lt;&lt;i)] * Omega) % MOD; A[j+k+(1&lt;&lt;i)] = Module(A[j+k], MOD-temp); s_Module(A[j+k], temp); (Omega *= Omega_n) %= MOD; &#125; &#125; &#125; if(type == -1)&#123; temp = Pow((long long)totNums, MOD-2); for(int i=0;i&lt;totNums;++i) (A[i] *= temp) %= MOD; &#125; &#125; long long* Mult(long long* X,long long* Y, const int&amp; totLv, const bool equ=true)&#123; static long long A[MAXN],B[MAXN]; memset(A,0,sizeof(A)); memset(B,0,sizeof(B)); int totNums = 1 &lt;&lt; totLv; for(int i=0;i&lt;(totNums&gt;&gt;(equ?1:0));++i) A[i]=X[i], B[i]=Y[i]; NTT(A,totLv,1); NTT(B,totLv,1); for(int i=0;i&lt;totNums;++i) (A[i] *= B[i]) %= MOD; NTT(A,totLv,-1); for(int i=0;i&lt;totNums;++i) X[i] = A[i]; return X; &#125;&#125;; using namespace Poly;namespace PolyInv&#123; long long* Inverse(long long* arr, const int&amp; totLv)&#123; static long long A[2][MAXN]; int totNums = 1 &lt;&lt; totLv; int cur=0; memset(A[cur],0,sizeof(A[cur])); A[cur][0] = Pow(*arr, MOD-2); int lev=1,fin=1,nowsiz=2; while(fin &lt;= totNums)&#123; cur^=1; memset(A[cur],0,sizeof(A[cur])); GetR(lev); for(int i=0;i&lt;fin;++i) A[cur][i] = (A[cur^1][i]&lt;&lt;1) % MOD; Mult(A[cur^1],A[cur^1],lev,true); Mult(A[cur^1],arr,lev,true); for(int i=0;i&lt;nowsiz;++i) A[cur][i] = Module(A[cur][i], MOD-A[cur^1][i]); fin&lt;&lt;=1; nowsiz&lt;&lt;=1; ++lev; &#125; for(int i=0;i&lt;totNums;++i) arr[i] = A[cur][i]; return A[cur]; &#125;&#125;; using namespace PolyInv;namespace Polyln&#123; long long* Differential(long long* A, const int&amp; totLv)&#123; int totNums = 1 &lt;&lt; totLv; for(int i=1;i&lt;totNums;++i) A[i-1] = i*A[i] % MOD; A[totNums-1] = 0LL; return A; &#125; long long* Intergral(long long* A, const int&amp; totLv)&#123; int totNums = 1 &lt;&lt; totLv; for(int i=totNums-2;i&gt;=0;--i) A[i+1] = A[i]*Pow(i+1,MOD-2) % MOD; *A = 0; return A; &#125; long long* Ln(long long* A, const int&amp; totLv)&#123; static long long fp[MAXN],f1[MAXN]; memset(fp,0,sizeof(fp)); memset(f1,0,sizeof(fp)); int totNums = 1 &lt;&lt; totLv; for(int i=0;i&lt;totNums;++i) fp[i] = f1[i] = A[i]; Inverse(f1,totLv); Differential(fp,totLv); Mult(fp,f1,totLv+1); Intergral(fp, totLv); for(int i=0;i&lt;totNums;++i) A[i] = fp[i]; return fp; &#125; long long* Ln(long long* B,long long* A, const int&amp; totLv)&#123; int totNums = 1 &lt;&lt; totLv; for(int i=0;i&lt;totNums; ++i) B[i] = A[i]; return Ln(B,totLv); &#125;&#125;; using namespace Polyln;namespace PolyExp&#123; void Exp(long long* B, long long* A,const int&amp; totLv)&#123; static long long F[MAXN]; int totNums = 1 &lt;&lt; totLv; if(totNums &lt;= 1)&#123; assert(totNums==1); *B=1; return; &#125; Exp(B,A,totLv-1); Ln(F,B,totLv); *F = Module(*A+1, MOD-*F); for(int i=1;i&lt;totNums;++i) F[i] = Module(A[i], MOD-F[i]); Mult(B,F,totLv+1); for(int i=totNums,top=totNums&lt;&lt;1; i&lt;top; ++i) B[i] = F[i] = 0; &#125;&#125;; using namespace PolyExp;long long A[MAXN],B[MAXN];signed main(void)&#123; int totA,tot=1,totLv=0; scanf("%d", &amp;totA); --totA; for(int i=0;i&lt;=totA;++i) scanf("%lld", A+i); while(tot &lt;= totA)&#123; tot&lt;&lt;=1; ++totLv; &#125; Exp(B,A,totLv); for(int i=0;i&lt;=totA;++i) printf("%lld ", B[i]); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式对数函数]]></title>
    <url>%2F2020%2F04%2F05%2Fpolln%2F</url>
    <content type="text"><![CDATA[给出一个 $n-1$ 次多项式 $A(x)$, 求一个 $\mod x^n$ 下的多项式 $B(x)$, 满足 $B(x)\equiv \ln A(x)$. 系数对 $998244353$ 取模。 对于一个多项式 $f(x)=\sum_{i=0}^{+\infty}a_ix^i$, 可以将其对数函数看作其与麦克劳林级数的复合： \ln(1-f(x))=-\sum_{i=1}^{+\infty}\frac{f^i(x)}i=\sum_{i=1}^{+\infty}\frac{(-1)^{i-1}f^i(x)}i对于一个多项式 $F(x)=\sum_{i=0}^na_ix^i$, 它的导数和积分为: F^\prime(x)=\sum_{i=1}^nia_ix^{i-1}\\ \int F(x)=\sum_{i=1}^n\frac{a_ix^{i+1}}{i+1}+C它们都可以单次 $O(N)$ 计算。 计算 $\ln F$ 时， \ln(F(x))\equiv\int F^\prime F^{-1}\mod x^n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;constexpr auto MOD = 998244353LL;constexpr auto MAXN = (int)5e5;long long Pow(long long a,long long b, long long MOD = ::MOD)&#123; long long ans = 1LL; for(;b;b&gt;&gt;=1,(a*=a)%=MOD) if(b &amp; 1) (ans *= a) %= MOD; return ans;&#125;long long Module(long long a,const long long&amp; b)&#123; a+=b; return a&gt;=MOD ? a-MOD : a; &#125;long long&amp; s_Module(long long&amp; a, const long long&amp; b)&#123; a+=b; return a&gt;=MOD ? a-=MOD : a; &#125;namespace Poly&#123; constexpr auto g = 3LL; int r[MAXN]; int* GetR(const int&amp; totLv)&#123; int totNums = 1 &lt;&lt; totLv; *r=0; for(int i=1;i&lt;totNums;++i) r[i] = (r[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;totLv-1); return r; &#125; void NTT(long long* A,const int&amp; totLv, const long long&amp; type)&#123; int totNums = 1 &lt;&lt; totLv; for(int i=0;i&lt;totNums;++i) if(i &lt; r[i]) std::swap(A[i], A[r[i]]); long long temp,Omega,Omega_n; for(int i=0;i&lt;totLv;++i)&#123; Omega_n = Pow(g, (MOD-1)/(1LL&lt;&lt;i+1)); if(type == -1) Omega_n = Pow(Omega_n, MOD-2); for(int j=0;j&lt;totNums;j+=(1&lt;&lt;i+1))&#123; Omega = 1LL; for(int k=0;k&lt;(1&lt;&lt;i);++k)&#123; temp = (A[j+k+(1&lt;&lt;i)] * Omega) % MOD; A[j+k+(1&lt;&lt;i)] = Module(A[j+k], MOD-temp); s_Module(A[j+k], temp); (Omega *= Omega_n) %= MOD; &#125; &#125; &#125; if(type == -1)&#123; temp = Pow((long long)totNums, MOD-2); for(int i=0;i&lt;totNums;++i) (A[i] *= temp) %= MOD; &#125; &#125; long long* Mult(long long* X,long long* Y, const int&amp; totLv, const bool equ=true)&#123; static long long A[MAXN],B[MAXN]; memset(A,0,sizeof(A)); memset(B,0,sizeof(B)); int totNums = 1 &lt;&lt; totLv; for(int i=0;i&lt;(totNums&gt;&gt;(equ?1:0));++i) A[i]=X[i], B[i]=Y[i]; NTT(A,totLv,1); NTT(B,totLv,1); for(int i=0;i&lt;totNums;++i) (A[i] *= B[i]) %= MOD; NTT(A,totLv,-1); for(int i=0;i&lt;totNums;++i) X[i] = A[i]; return X; &#125;&#125;; using namespace Poly;namespace PolyInv&#123; long long* Inverse(long long* arr, const int&amp; totLv)&#123; static long long A[2][MAXN]; int totNums = 1 &lt;&lt; totLv; int cur=0; memset(A[cur],0,sizeof(A[cur])); A[cur][0] = Pow(*arr, MOD-2); int fin=1,lev=1,nowsiz=2; while(fin &lt;= totNums)&#123; cur^=1; memset(A[cur],0,sizeof(A[cur])); GetR(lev); for(int i=0;i&lt;fin;++i) A[cur][i] = (A[cur^1][i] &lt;&lt; 1) % MOD; Mult(A[cur^1],A[cur^1],lev,true); Mult(A[cur^1],arr,lev,true); for(int i=0;i&lt;nowsiz;++i) A[cur][i] = Module(A[cur][i], MOD-A[cur^1][i]); fin&lt;&lt;=1; nowsiz&lt;&lt;=1; ++lev; &#125; for(int i=0;i&lt;totNums;++i) arr[i] = A[cur][i]; return A[cur]; &#125;&#125;; using namespace PolyInv;namespace Polyln&#123; long long* Differential(long long* A, const int&amp; totLv)&#123; int totNums = 1 &lt;&lt; totLv; for(int i=1;i&lt;totNums;++i) A[i-1] = i*A[i] % MOD; A[totNums-1] = 0LL; return A; &#125; long long* Intergral(long long* A, const int&amp; totLv)&#123; int totNums = 1 &lt;&lt; totLv; for(int i=totNums-2;i&gt;=0;--i) A[i+1] = A[i]*Pow(i+1,MOD-2) % MOD; *A = 0; return A; &#125; long long* Ln(long long* A, const int&amp; totLv)&#123; static long long fp[MAXN],f1[MAXN]; memset(fp,0,sizeof(fp)); memset(f1,0,sizeof(fp)); int totNums = 1 &lt;&lt; totLv; for(int i=0;i&lt;totNums;++i) fp[i] = f1[i] = A[i]; Inverse(f1,totLv); Differential(fp,totLv); Mult(fp,f1,totLv+1); Intergral(fp, totLv); for(int i=0;i&lt;totNums;++i) A[i] = fp[i]; return fp; &#125;&#125;; using namespace Polyln;long long A[MAXN];signed main(void)&#123; int totA,tot=1,totLv=0; scanf("%d", &amp;totA); --totA; for(int i=0;i&lt;=totA;++i) scanf("%lld", A+i); while(tot &lt;= totA)&#123; tot&lt;&lt;=1; ++totLv; &#125; Ln(A,totLv); for(int i=0;i&lt;=totA;++i) printf("%lld ", A[i]); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1327F AND Segments]]></title>
    <url>%2F2020%2F03%2F29%2Fadsg%2F</url>
    <content type="text"><![CDATA[Codeforces 1327 F.AND Segments 给定 $m$ 个限制条件，第 $i$ 个形如 $(l_i,r_i,x_i)$. 统计长度为 $n$ 的数列 $A$, 满足 $\forall1\leq i\leq n$, $0\leq a_i&lt; 2^k$. $\forall1\leq i\leq m$, $a_{l_i}\&amp;a_{l_i+1}\&amp;\cdots\&amp;a_{r_i}=x_i$. 由于各个二进制位之间互不影响，因此单独考虑每一个二进制位，最终的答案是这 $K$ 个二进制位答案的乘积。 对于一个二进制位而言，问题转化成了：统计满足限制条件的长度为 $n$ 的 01 数列个数，每一个限制条件 $i$ 根据 $x_i$ 二进制表示下当前考虑位置的值，决定这个条件限制的是 $l_i-r_i$ 中间全部是 1, 还是 $l_i-r_i$ 中间有至少一个 0. 考虑用动态规划解决这个问题。先预处理出一个数组 $p$, $p_i$ 代表仅考虑所有 $r_j&lt;i$ 的条件 $j$, 第一个 0 最早可能出现的位置，换言之就是这些条件中最大的 $l_j$. 定义状态 $D_{i,j}$ 代表当前考虑到第 $i$ 位，最后一个 0 出现在第 $j$ 位的方案数，转移时 若 $j&lt;p_i$, 那么此后一定还需要有 0 才能满足要求，$D_{i,j}=0$. 若 $p_i\leq j&lt;i$, 上一位所有满足要求的方案依然合法，同时无法构造出更多方案，$D_{i,j}=D_{i-1,j}$. 若 $j=i$, 这时讨论是否有条件限制了第 $i$ 位必须是 1. 如果有 $D_{i,j}=0$, 否则 $D_{i,j}=\sum_{k=j}^{i-1}D_{i-1,j}$. 状态中的第一维可以滚动处理，第二种情况可以不管，然后只需维护一个指针和一个区间和就可以在 $O(N)$ 的时间复杂度内完成单次 DP. 答案是 $D_{n+1,n+1}$. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;constexpr auto MOD = 998244353LL;constexpr auto MAXN = (int)5e5+50;inline long long&amp; s_Module(long long&amp; a, const long long&amp; t)&#123; return (a+=t) &gt;= MOD ? a-=MOD : a; &#125;int fr[MAXN],to[MAXN],sand[MAXN];int dcov[MAXN],pos[MAXN];long long D[MAXN];signed main(void)&#123; int totLen,totOptn,totBits; std::cin&gt;&gt;totLen&gt;&gt;totBits&gt;&gt;totOptn; ++totLen; for(int i=0;i&lt;totOptn;++i)&#123; std::cin&gt;&gt;fr[i]&gt;&gt;to[i]&gt;&gt;sand[i]; ++to[i]; &#125; long long ans = 1LL,cnt,sum; int cov,now; while(totBits--)&#123; memset(pos,0,sizeof(pos)); memset(dcov,0,sizeof(dcov)); memset(D,0,sizeof(D)); for(int i=0;i&lt;totOptn;++i)&#123; if(sand[i] &amp; 1)&#123; ++dcov[fr[i]]; --dcov[to[i]]; &#125; else pos[to[i]] = std::max(pos[to[i]], fr[i]); sand[i] &gt;&gt;= 1; &#125; for(int i=1;i&lt;=totLen;++i) pos[i] = std::max(pos[i], pos[i-1]); now = cov = 0; sum = D[0] = 1LL; for(int i=1;i&lt;=totLen;++i)&#123; cov += dcov[i]; while(now &lt; pos[i])&#123; s_Module(sum, MOD-D[now]); D[now++] = 0; &#125; D[i] = cov&gt;0 ? 0LL : sum; s_Module(sum, D[i]); &#125; (ans *= D[totLen]) %= MOD; &#125; std::cout&lt;&lt;ans&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTS2019 随机立方体]]></title>
    <url>%2F2020%2F02%2F21%2FCube%2F</url>
    <content type="text"><![CDATA[有一个 $n\times m\times l$ 的立方体，立方体中每个格子上都有一个数，如果某个格子上的数比三维坐标至少有一维相同的其他格子上的数都要大的话，我们就称它是极大的。 现在将 $1\mbox{~}n\times m\times l$ 这 $n\times m\times l$ 个数等概率随机填入 $n\times m\times l$ 个格子（即任意数字出现在任意格子上的概率均相等），使得每个数恰出现一次，求恰有 $k$ 个极大的数的概率。答案对 $998244353$（一个质数）取模。 记 $N=n\times m\times l$, $R=\min(n,m,l)$. 我们称一个恰有 $k$ 个极大的数的填数方案称为一个合法方案。如果一个格子 $i$ 的坐标任何一个维度与某个极大数 $j$ 坐标的相同维度相同，那么称 $i$ 在 $j$ 范围内，$j$ 范围内所有的格子组成的集合记为 $S_j$. 先考虑一些现象： 不存在一个极大数在另一个极大数范围内的合法方案。 对于任何一种合法方案，互换此方案中的任何两个平行的平面，得到的方案也合法。这是因为如果这两个平面中存在极大数，那么这些(个)极大数互换后范围内的数并没有发生变化，对于其他极大数也是一样。我们称这两种方案是等价的。 直接算恰有 $k$ 个极大数的方案 $G_k$ 似乎不可能完成，考虑至少 $k$ 个极大数的方案数，记为 $F_k$. 得出这样的式子: F_k=(\mbox{选择}i\mbox{个三维坐标都不相同的点的方案数})\times(\mbox{在这}i\mbox{个极大数范围内的点的个数})\times(\mbox{将}g_i个数分配给g_i)个点的方案数\times(\mbox{选择}g_i\mbox{个数的方案数})\times(\mbox{剩下无限制的方案数})将前三个变量记为 $b_i,\ g_i$ 和 $h_i$. 显然选择 $g_i$ 个数就是 $\left({}_{g_i}^N\right)$, 剩下无限制的就是乘上 $(N-g_i)!$ F_k=\left({}_{g_i}^N\right)b_ih_i(N-g_i)!这样计算看上去非常有道理，而且很容易表示出答案: $G_k=F_k-F_{k+1}$. 但是仔细思考之后会发现 $F_k$ 的含义并不是所谓至少 $k$ 个极大数的方案数，举个例子: 钦定一种有三个极大数的方案 $A$，那么 $F_2$ 包含的所有方案中与 $A$ 相同的有三个，因为 $A$ 中任何两个极大数都被当作 $F_2$ 中至少存在的极大数考虑了一遍。将这一发现推广，得出对于一种恰有 $i$ 个极大数的方案，它会在 $F_k\;(k\leq i)$ 中存在 $({}_k^i)$ 次，两个函数的关系是 F_k=\sum_{i=k}^R({}_k^i)G_k这个式子可以直接二项式反演，得出 G_k=\sum_{i=k}^R(-1)^{i-k}({}_k^i)F_k如果更改 $G$ 和 $F$ 的定义，考虑上概率，那么这个式子仍然成立。 接下来计算 $F$ 函数。 考虑 $b_i$, 在最开始，所有 $N$ 个点都有可能是极大点，选择一个之后，它的范围内就不会再产生极大点了，这时问题成了三个维度都减一的子问题，最后需要除以 $i!$ 将排列化成组合。 b_i=\frac{\prod_{k=0}^{i-1}(n-k)(m-k)(l-k)}{i!}考虑 $g_i$, 当 $i$ 个极大点都产生之后，还不在范围内的点有 $(n-i)\times(m-i)\times(l-i)$ 个 g_i=N-(n-i)\times(m-i)\times(l-i)考虑 $h_i$, 我们根据之前的发现，将方案中已经选定的 $i$ 个极大点通过交换平行平面移动到一个角落，同时规定他们之间的大小关系为从角落向外依次增大。记 $a_i=(n-i)\times(m-i)\times(l-i)$. 考虑离角落最远的第 $u$ 个格子，他上面的数一定是 $u_v=nml$, $u$ 的范围内同时也在其它极大点范围内的数是 $T_u=S_u\cap\left(\cup_{0&lt;i&lt;u} S_i\right)$, 剩下 $S_u-T_u$ 中的数随便填与其他极大数无关。计算或者找规律得到 $|S_u-T_u|=a_{i-1}-a_i$, 但是我们已经钦定了极大数的大小，所以剩下的数的填法有 $P_{g_i-1}^{a_{i-1}-a_i-1}$ 这么多。考虑完这一层，可以将它去掉，剩下的就是一个与之前无关，规模减一的子问题。最后计算完了还需要乘上 $i!$, 因为钦定了大小关系。总之 h_i=i!\prod_{j=1}^i\frac{(g_j-1)!}{g_{j-1}!}将得到的东西全部带入，同时考虑上概率，得到 \begin{align} F_k&=\frac{N!}{(N-g_k)!g_k!}\cdot b_k\cdot k!\cdot\prod_{i=1}^k\frac{(g_i-1)!}{g_{i-1}!}\cdot(N-g_k)!\cdot\frac1{N!}\\ &=k!\cdot b_k\cdot\prod_{i=1}^k\frac1{g_j} \end{align}同时 G_k=\sum_{i=k}^R(-1)^{i-k}C_i^k\cdot\prod_{j=0}^{i-1}(n-j)(m-j)(l-j)\cdot\prod_{j=1}^i\frac 1{g_j}之后发现性能的瓶颈在于求逆元，利用线性求逆的技巧，最终时间复杂度是 $O(T\cdot\min(n,m,l))$. 实现过程中还需要特判一种 $k&gt;R$ 的特殊情况，这时答案是 $0$. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;template&lt;typename T&gt;T Max(const T&amp; a,const T&amp; b,const T&amp; c)&#123; return std::max(a,std::max(b,c)); &#125;template&lt;typename T&gt;T Min(const T&amp; a,const T&amp; b,const T&amp; c)&#123; return std::min(a,std::min(b,c)); &#125;constexpr auto MAXN = 5000000 + 50;constexpr auto MOD = 998244353LL;inline long long Pow(long long a,long long b)&#123; long long ans = 1LL; for(;b;b&gt;&gt;=1,(a*=a)%=MOD) if(b &amp; 1) (ans *= a) %= MOD; return ans;&#125;long long fact[MAXN],revfact[MAXN],g[MAXN],revg[MAXN],b[MAXN],revb[MAXN];inline long long C(long long n,long long r)&#123; return fact[n]*revfact[n-r]%MOD*revfact[r]%MOD;&#125;signed main(void)&#123; int totCases; long long n,m,l,t,R,k,N,delta,ans; //R_T *fact = 1LL; for(int i=1;i&lt;MAXN;++i) fact[i] = fact[i-1]*i%MOD; revfact[MAXN-1] = Pow(fact[MAXN-1],MOD-2); for(int i=MAXN-2;i&gt;=0;--i) revfact[i] = revfact[i+1]*(i+1) % MOD; scanf("%d", &amp;totCases); while(totCases--)&#123; scanf("%lld%lld%lld%lld", &amp;n,&amp;m,&amp;l,&amp;k); N = n*m%MOD*l % MOD; R = Min(n,m,l); if(R &lt; k)&#123; puts("0"); continue; &#125; *b = 1; for(int i=1;i&lt;=R;++i) b[i] = b[i-1]*(n-i+1)%MOD*(m-i+1)%MOD*(l-i+1)%MOD; *g = 1; *revg = 1; for(int i=1;i&lt;=R;++i) g[i] = ((N-(n-i)%MOD*(m-i)%MOD*(l-i)%MOD)%MOD+MOD) % MOD; for(int i=1;i&lt;=R;++i) revg[i] = revg[i-1] * g[i] % MOD; revg[R] = Pow(revg[R], MOD-2); for(int i=R;i&gt;0;--i) revg[i-1] = revg[i] * g[i] % MOD; //for(int i=1;i&lt;=R;++i)&#123; assert(revg[i] == Pow(g[i], MOD-2)); (g[i+1] *= g[i]) %= MOD; &#125; ans = 0; for(int i=k;i&lt;=R;++i)&#123; delta = (i-k&amp;1) ? MOD-1 : 1; delta = delta*C(i,k)%MOD*b[i]%MOD*revg[i]%MOD; (ans += delta) %= MOD; &#125; printf("%lld\n", (ans+MOD) % MOD); &#125; //std::cout&lt;&lt;(double)clock()/CLOCKS_PER_SEC&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>二项式反演</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2019 删数]]></title>
    <url>%2F2020%2F02%2F17%2Fdeln%2F</url>
    <content type="text"><![CDATA[给定一个长度为 $k$ 的序列，每一次删除操作可以去除序列中所有值为 $k$ 的元素，询问至少更改序列中多少个元素，使得能够在经过若干次操作之后将序列删空。 在此基础之上，还需要支持更换序列中某个元素，以及所有元素加上/减去 $1$ 这两种修改操作。 考虑画出一些方格，从左向右第 $i$ 个代表现在正处于一个序列长度为 $i$ 的状态，最开始我们位于方格 $n$. 如果此时序列中存在 $a&gt;0$ 个元素值是 $n$, 那么下一步我们所处的方格就是 $n-a$. 序列最终被删成 $\varnothing$, 我们在不断执行删除操作的同时经过了 $n\to1$ 的所有方格。 对于值为 $i$ 的元素，他们出现了 $k$ 次，那么在方格上给 $[i-k+1,i]$ 这一段涂黑，代表到达方格 $i$ 之后，一次操作可以带我们到 $i-k+1$. 如果 $[1,n]$ 中有没有被涂黑的方格，那么显然序列不可删空。进一步，修改一个元素最多涂黑一个空白，由于涂层有重叠，所以采取最优策略可以使得白色正好减少一个，那么答案就是白色部分的个数。 具体实现可以使用线段树维护方格的覆盖次数，记录一下 $0$ 的个数，最小值和最小值的个数。这样可以轻松维护单点修改，整体加减实际上就是整体平移，更改一下询问的区间，将离开询问区间的点的贡献消除掉就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;namespace SegTr&#123; struct Node&#123; int fr,to; int cnt,min,cntmin,dlt; Node *lft,*rgt; Node(const int&amp; ifr,const int&amp; ito) : fr(ifr),to(ito) &#123; dlt = 0; min = 0; cnt = cntmin = ito-ifr+1; lft = rgt = nullptr; &#125; Node&amp; Add(const int &amp;val)&#123; if(val)&#123; dlt += val; min += val; cnt = min==0 ? cntmin : 0; &#125; return *this; &#125; Node&amp; Push_Down(void)&#123; if(dlt &amp;&amp; lft!=nullptr)&#123; lft-&gt;Add(dlt); rgt-&gt;Add(dlt); dlt = 0; &#125; return *this; &#125; Node&amp; Update(void)&#123; if(lft != nullptr)&#123; cnt = lft-&gt;cnt + rgt-&gt;cnt; min = std::min(lft-&gt;min, rgt-&gt;min); cntmin = ((lft-&gt;min==min) ? lft-&gt;cntmin : 0) + ((rgt-&gt;min==min) ? rgt-&gt;cntmin : 0); &#125; return *this; &#125; &#125;*root; void Build(const int&amp; fr,const int&amp; to)&#123; Node *a,*b,*t; std::queue&lt;Node*&gt; que,add; for(int i=fr;i&lt;=to;++i)&#123; t = new Node(i,i); que.push(t); &#125; for(;que.size()&gt;=2;std::swap(que,add))&#123; while(que.size()&gt;=2)&#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = new Node(a-&gt;fr, b-&gt;to); t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if(!que.empty())&#123; add.push(que.front()); que.pop(); &#125; &#125; root = que.front(); &#125; void Add(const int&amp; fr,const int&amp; to, const int&amp; val, Node* nowAt=root)&#123; if(to&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;fr) return; nowAt-&gt;Push_Down(); if(fr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=to) nowAt-&gt;Add(val); else&#123; Add(fr,to,val,nowAt-&gt;lft); Add(fr,to,val,nowAt-&gt;rgt); nowAt-&gt;Update(); &#125; &#125; void Add(const int&amp; pos, const int&amp; val)&#123; Add(pos,pos,val); &#125; int Query(const int&amp; fr,const int&amp; to, Node* nowAt=root)&#123; if(to&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;fr) return 0; nowAt-&gt;Push_Down(); if(fr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=to) return nowAt-&gt;cnt; else return Query(fr,to,nowAt-&gt;lft) + Query(fr,to,nowAt-&gt;rgt); &#125;&#125;; using namespace SegTr;constexpr auto MAXN = 150050&lt;&lt;1;constexpr auto MAXM = MAXN;int arr[MAXN+MAXM&lt;&lt;1];int val[MAXN],*cnt=arr+MAXN+MAXM;signed main(void)&#123; int totNums,totOptn; int dltQue=0, pos,cg,org; scanf("%d%d", &amp;totNums,&amp;totOptn); for(int i=0;i&lt;totNums;++i)&#123; scanf("%d", val+i); ++cnt[val[i]]; &#125; Build(-2*totOptn,totNums+2*totOptn); for(int i=1;i&lt;=totNums;++i) if(cnt[i] &gt; 0) Add(i-cnt[i]+1,i,1); while(totOptn--)&#123; scanf("%d%d", &amp;pos,&amp;cg); switch(pos)&#123; case 0: switch(cg)&#123; case 1: pos = totNums + dltQue; if(cnt[pos]) Add(pos-cnt[pos]+1, pos, -1); --dltQue; break; case -1: ++dltQue; pos = totNums + dltQue; if(cnt[pos]) Add(pos-cnt[pos]+1, pos, 1); break; default: assert(false); break; &#125; break; default: --pos; cg += dltQue; org = val[pos]; val[pos] = cg; if(org &lt;= totNums+dltQue) Add(org-cnt[org]+1, -1); --cnt[org]; ++cnt[cg]; if(cg &lt;= totNums+dltQue) Add(cg-cnt[cg]+1, 1); break; &#125; //Solve printf("%d\n", Query(1+dltQue, totNums+dltQue)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSOI2010 冷冻波]]></title>
    <url>%2F2020%2F02%2F11%2FFrozenNova%2F</url>
    <content type="text"><![CDATA[WJJ喜欢《魔兽争霸》这个游戏。在游戏中，巫妖是一种强大的英雄，它的技能 Frozen Nova 每次可以杀死一个小精灵。我们认为，巫妖和小精灵都可以看成是平面上的点。 当巫妖和小精灵之间的直线距离不超过 $R$，且巫妖看到小精灵的视线没有被树木阻挡（也就是说，巫妖和小精灵的连线与任何树木都没有公共点）的话，巫妖就可以瞬间杀灭一个小精灵。 在森林里有 $N$ 个巫妖，每个巫妖释放 Frozen Nova 之后，都需要等待一段时间，才能再次施放。不同的巫妖有不同的等待时间和施法范围，但相同的是，每次施放都可以杀死一个小精灵。 现在巫妖的头目想知道，若从 $0$ 时刻开始计算，至少需要花费多少时间，可以杀死所有的小精灵？ 考虑给定一个巫妖 $A$ 和一个在攻击范围内的小精灵 $B$，判断它是否在视野范围内。枚举一下可能遮挡视野的树，如果这棵树所在的圆心 $O$ 到线段 $AB$ 的距离小于半径 $r$, 那么它会遮挡视野。 如果过 $O$ 作 $AB$ 的垂线，垂足在 $AB$ 上，那么距离显然是 $d=\left|\vec{OA}\times\vec{OB}\right|\div OA$. 如果在 $AB$ 外，那么距离应该是 $O$ 到离它最近的一个端点。判断垂足的位置可以使用点积，例如 $\vec{OA}\cdot\vec{AB}&lt;0$, 那么 $d=OA$. 预处理出对于每一个巫妖 $i$ 可以攻击到的小精灵集合 $S_i$, 然后二分答案。对于一个等待时间为 $g$ 的巫妖，它在 $t$ 时间内可以鲨掉 $1+\left\lfloor\frac tg\right\rfloor$ 个小精灵，利用网络最大流计算答案是否涵盖了每一个小精灵即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;#define Sqr(x) ((x)*(x))constexpr auto EPS = 1e-8;struct Vector2&#123; int y,x; Vector2()&#123;&#125; Vector2(const int&amp; iy,const int&amp; ix) : y(iy),x(ix) &#123;&#125; double Len(void) const &#123; return sqrt((double)(Sqr(x) + Sqr(y))); &#125; bool operator == (const Vector2&amp; comp) const &#123; return y==comp.y &amp;&amp; x==comp.x; &#125; bool operator != (const Vector2&amp; comp) const &#123; return y!=comp.y || x!=comp.x; &#125; Vector2 operator - (const Vector2&amp; t) const &#123; return Vector2(y-t.y, x-t.x); &#125; Vector2&amp; operator -= (const Vector2&amp; t)&#123; return *this = *this - t; &#125;&#125;; typedef Vector2 Point;double Dist(const Point&amp; a,const Point&amp; b)&#123; return sqrt(Sqr(a.y-b.y) + Sqr(a.x-b.x)); &#125;int Cross(const Vector2&amp; a,const Vector2&amp; b)&#123; return a.x*b.y - a.y*b.x; &#125;int Dot(const Vector2&amp; a,const Vector2&amp; b)&#123; return a.x*b.x + a.y*b.y; &#125;struct Line&#123; Point fr,to; Line()&#123;&#125; Line(const Point&amp; ifr,const Point&amp; ito) : fr(ifr),to(ito) &#123;&#125; Line&amp; Dlt(const Point&amp; targ)&#123; if(fr != to) if(targ == fr)&#123; if(to.x &lt; targ.x) --fr.x; else if(to.x &gt; targ.x) ++fr.x; if(to.y &lt; targ.y) --fr.y; else if(to.y &gt; targ.y) ++fr.y; &#125; else if(targ == to)&#123; if(fr.x &lt; targ.x) --to.x; else if(fr.x &gt; targ.x) ++to.x; if(fr.y &lt; targ.y) --to.y; else if(fr.y &gt; targ.y) ++to.y; &#125; return *this; &#125; double Dis(const Point&amp; tg) const &#123; if(fr == to) return (tg-fr).Len(); Vector2 ts = to-fr, a = tg-fr, b = tg-to; if(Dot(ts, a) &lt; 0) return a.Len(); else if(Dot(ts, b) &gt; 0) return b.Len(); else return fabs(Cross(ts,a)) / ts.Len(); &#125;&#125;;constexpr auto MAXN = 400;constexpr auto MAXM = MAXN;constexpr auto MAXT = MAXN&lt;&lt;1;//Dinicstruct Edge&#123; int fr,to,residual; Edge()&#123;&#125; Edge(const int&amp; ifr,const int&amp; ito,const int&amp; ire) : fr(ifr),to(ito),residual(ire) &#123;&#125;&#125;; std::vector&lt;int&gt; G[MAXT]; std::vector&lt;Edge&gt; edges;const int s=MAXT-1,t=MAXT-2;void AddEdge(const int&amp; fr,const int&amp; to,const int&amp; res)&#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr,to,res)); G[to].push_back(edges.size()); edges.push_back(Edge(to,fr,0));&#125;int depth[MAXT],cur[MAXT];bool BFS(void)&#123; memset(depth,-1,sizeof(depth)); std::queue&lt;int&gt; que; que.push(s); depth[s] = 0; int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(int i=0;i&lt;G[nowAt].size(); ++i)&#123; const Edge&amp; it = edges[G[nowAt][i]]; if(it.residual&gt;0 &amp;&amp; depth[it.to] == -1)&#123; depth[it.to] = depth[nowAt] + 1; que.push(it.to); &#125; &#125; &#125; return depth[t] &gt;= 0;&#125;int Dinic(const int&amp; nowAt, int maxFlow = INT_MAX)&#123; if(nowAt==t || maxFlow&lt;=0) return maxFlow; int flow=0,deltaFlow; for(int&amp; i=cur[nowAt];i&lt;G[nowAt].size();++i)&#123; Edge&amp; it = edges[G[nowAt][i]]; if(depth[it.fr]+1==depth[it.to] &amp;&amp; 0&lt;(deltaFlow=Dinic(it.to, std::min(maxFlow,it.residual))))&#123; flow += deltaFlow; it.residual -= deltaFlow; edges[G[nowAt][i]^1].residual += deltaFlow; maxFlow -= deltaFlow; if(maxFlow &lt;= 0) break; &#125; &#125; return flow;&#125;int MaxFlow(void)&#123; int ans = 0; while(BFS())&#123; memset(cur,0,sizeof(cur)); ans += Dinic(s); &#125; return ans;&#125;int totTree,totNova,totElf;Point nova[MAXN],elf[MAXN],tree[MAXN];int gp[MAXN]; double range[MAXN],r[MAXN];bool Check(const Line&amp; ln)&#123; for(int i=0;i&lt;totTree;++i) if(r[i]+EPS &gt; ln.Dis(tree[i])) return false; return true;&#125;bool Check(const int&amp; ts)&#123; for(int i=0;i&lt;(totNova&lt;&lt;1);i+=2)&#123; edges[i].residual = 1+ts/gp[i&gt;&gt;1]; edges[i^1].residual = 0; &#125; for(int i=totNova&lt;&lt;1;i&lt;edges.size();i+=2)&#123; edges[i].residual = 1; edges[i^1].residual = 0; &#125; return MaxFlow() &gt;= totElf;&#125;signed main(void)&#123; int x,y,fr=0,to=0,mid; scanf("%d%d%d", &amp;totNova,&amp;totElf,&amp;totTree); for(int i=0;i&lt;totNova;++i)&#123; scanf("%d%d%lf%d", &amp;x,&amp;y,range+i,gp+i); nova[i] = Point(y,x); to = std::max(to, gp[i]*totElf); &#125; for(int i=0;i&lt;totElf;++i)&#123; scanf("%d%d", &amp;x,&amp;y); elf[i] = Point(y,x); &#125; for(int i=0;i&lt;totTree;++i)&#123; scanf("%d%d%lf", &amp;x,&amp;y,r+i); tree[i] = Point(y,x); &#125; //Build int cnt[MAXN] = &#123;&#125;; for(int i=0;i&lt;totNova;++i) AddEdge(s,i,0); for(int i=0;i&lt;totNova;++i) for(int j=0;j&lt;totElf;++j) if(range[i]+EPS&gt;Dist(nova[i],elf[j]) &amp;&amp; Check(Line(nova[i], elf[j])))&#123; AddEdge(i,j+totNova,1); ++cnt[j]; &#125; for(int i=0;i&lt;totElf;++i) AddEdge(i+totNova,t,1); for(int i=0;i&lt;totElf;++i) if(cnt[i] &lt;= 0)&#123; puts("-1"); return 0; &#125; while(fr &lt; to)&#123; mid = fr+to&gt;&gt;1; if(Check(mid)) to = mid; else fr = mid+1; &#125; printf("%d\n", fr); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF600E Lomsat Gelral]]></title>
    <url>%2F2019%2F12%2F27%2FLomsatGelral%2F</url>
    <content type="text"><![CDATA[Codeforces600 E.Lomsat Gelral 给定一棵根为 $1$, 一共 $n$ 个结点的树，每一个结点有颜色，分别求出对于每一个结点，以这个结点为根的子树中出现次数最多的颜色的编号总和。 dsu on tree 模板题。 如果每次到达一个结点都暴力统计当前子树的答案，那么时间复杂度为 $O(N^2)$. 考虑在递归处理完 $v$ 的一个子树 $u$ 时，如果不清空 $u$ 这颗子树的答案，那么就会对之后递归到的子树统计产生影响，但是如果 $u$ 是 $v$ 最后一个儿子，那么下一步就是回溯，不会有影响。也就是说对于每一个结点，都可以保留一个子树的信息传递到自己，很明显应该选择最大的那个儿子。 将树轻重链剖分，每次到达一个结点 $u$, 先递归处理它的所有轻儿子，并在最终将答案撤销，最后递归处理重儿子，不撤销答案。要计算当前点答案时再暴力统计每一个轻儿子即可。 考虑一个点 $u$ 最多被暴力统计多少次。如果 $u$ 在一次计算以 $v$ 为根的答案时被暴力统计了一次，那么它下一次被暴力统计时的根 $t$ 一定拥有一个比 $v$ 更大的子树，也就是每一次被暴力统计都意味着当前子树大小至少翻倍，次数就是 $\log N$ 次，因此总时间复杂度为 $O(N\log N)$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)1e5+50;int color[MAXN];std::vector&lt;int&gt; G[MAXN];int imp[MAXN],siz[MAXN];void Dfs(const int&amp; nowAt,const int fa = 0)&#123; siz[nowAt] = 1; for(const auto&amp; it : G[nowAt]) if(it != fa)&#123; Dfs(it,nowAt); siz[nowAt] += siz[it]; if(siz[it] &gt; siz[imp[nowAt]]) imp[nowAt] = it; &#125;&#125;long long ans[MAXN];int nowmax; long long curans[MAXN],appear[MAXN],cnt[MAXN];void Add(const int&amp; color)&#123; --cnt[appear[color]]; curans[appear[color]] -= color; cnt[++appear[color]]++; curans[appear[color]] += color; if(cnt[nowmax+1] &gt; 0) ++nowmax;&#125;void Del(const int&amp; color)&#123; --cnt[appear[color]]; curans[appear[color]] -= color; cnt[--appear[color]]++; curans[appear[color]] += color; while(nowmax&gt;0 &amp;&amp; cnt[nowmax]==0) --nowmax;&#125;void Addin(const int&amp; nowAt,const int fa = 0)&#123; Add(color[nowAt]); for(const auto&amp; it : G[nowAt]) if(it != fa) Addin(it,nowAt);&#125;void Erase(const int&amp; nowAt,const int fa = 0)&#123; Del(color[nowAt]); for(const auto&amp; it : G[nowAt]) if(it != fa) Erase(it,nowAt);&#125;void Solve(const int&amp; nowAt,const int fa=0,const bool hvy=false)&#123; for(const auto&amp; it : G[nowAt]) if(it!=fa &amp;&amp; it!=imp[nowAt]) Solve(it,nowAt); if(imp[nowAt] &gt; 0) Solve(imp[nowAt],nowAt,true); for(const auto&amp; it : G[nowAt]) if(it!=fa &amp;&amp; it!=imp[nowAt]) Addin(it,nowAt); Add(color[nowAt]); ans[nowAt] = curans[nowmax]; if(!hvy) Erase(nowAt,fa);&#125;signed main(void)&#123; int totVertex,fr,to; std::cin&gt;&gt;totVertex; for(int i=1;i&lt;=totVertex;i++) std::cin&gt;&gt;color[i]; for(int i=1;i&lt;totVertex;i++)&#123; std::cin&gt;&gt;fr&gt;&gt;to; G[fr].push_back(to); G[to].push_back(fr); &#125; Dfs(1); Solve(1); //output std::for_each(ans+1,ans+1+totVertex,[](const auto&amp; it)&#123; std::cout&lt;&lt;it&lt;&lt;' '; &#125;); std::cout&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SNOI2017 礼物]]></title>
    <url>%2F2019%2F12%2F26%2FBananas%2F</url>
    <content type="text"><![CDATA[有一个长度为 $n$ 的序列，其中每一项从 $1$ 至 $n$ 编号，第 $1$ 项的数值是 $1$, 其后第 $i$ 项的数值等于前面每一项的数值之和加上 $i^k$. 给定 $n$ 和 $k$, 需要输出序列的第 $n$ 项。 记 $F_i$ 为第 $i$ 项的值，$T_i=\sum_{j=1}^i F_i$. F_i=T_{i-1}+i^k\\ T_i=T_{i-1}+F_i=2T_{i-1}+i^k那么 $T$ 可以用矩阵描述转移 \begin{bmatrix} T_{i-1}\\i^k\\i^{k-1}\\\vdots\\i\\1 \end{bmatrix}\cdot\begin{bmatrix} 2&1&0&\cdots&0&0\\ 0&C_k^0&C_k^1&\cdots&C_k^{k-1}&C_k^k\\ 0&0&C_{k-1}^0&\cdots&C_{k-1}^{k-2}&C_{k-1}^{k-1}\\ \vdots&\vdots&\vdots&\ddots&\vdots&\vdots\\ 0&0&0&\cdots&1&1\\ 0&0&0&\cdots&0&1 \end{bmatrix}=\begin{bmatrix} T_i\\(i+1)^k\\(i+1)^{k-1}\\\vdots\\i+1\\1 \end{bmatrix}矩阵快速幂即可。 时间复杂度为 $O(K^3\log N)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;constexpr auto MAXK = 13;constexpr long long MOD = (long long)1e9+7LL;struct Matrix&#123; long long val[MAXK][MAXK]; Matrix()&#123; memset(val,0,sizeof(val)); &#125; Matrix&amp; Cls(void)&#123; memset(val,0,sizeof(val)); return *this; &#125; Matrix&amp; Def(void)&#123; Cls(); for(int i=0;i&lt;MAXK;i++) val[i][i] = 1LL; return *this; &#125; Matrix operator * (const Matrix&amp; times) const &#123; Matrix ans; for(int i=0;i&lt;MAXK;i++) for(int j=0;j&lt;MAXK;j++) for(int k=0;k&lt;MAXK;k++) (ans.val[i][j] += val[i][k]*times.val[k][j]) %= MOD; return ans; &#125; Matrix&amp; operator *= (const Matrix&amp; times)&#123; return *this = *this*times; &#125; Matrix operator ^ (long long b)&#123; Matrix ans,ts=*this; ans.Def(); for(;b;b&gt;&gt;=1,ts*=ts) if(b&amp;1) ans *= ts; return ans; &#125; Matrix&amp; operator ^= (long long b)&#123; return *this = *this^b; &#125;&#125;;signed main(void)&#123; int k; long long totNums,num[MAXK]=&#123;&#125;; Matrix A; std::cin&gt;&gt;totNums&gt;&gt;k; A.val[0][0] = 2LL; A.val[0][1] = 1LL; *num = 1LL; for(int i=0;i&lt;=k;i++)&#123; for(int j=k;j&gt;=0;--j) A.val[k+1-i][k+1-j] = num[j]; for(int j=k;j&gt;0;--j) (num[j] += num[j-1]) %= MOD; &#125; A ^= totNums; long long ans = 0LL; for(int i=1;i&lt;=k;i++) (ans += A.val[0][i]) %= MOD; std::cout&lt;&lt;ans&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2012 迷失游乐园]]></title>
    <url>%2F2019%2F12%2F24%2FPark%2F</url>
    <content type="text"><![CDATA[给定一个 $n$ 个结点 $m$ 条边的图，它是一颗树或者基环树。Z 会等概率地选择一个起点，然后在面对岔路时等概率选择去向，但是不会经过已经到过了的点，直到无路可走时停止。求期望路径长度。 如果这是一棵树，那么定义 $up_i$ 代表从这个点开始，规定第一步向上的期望路径，$down_i$ 类似，规定第一步向下。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2018 屠龙勇士]]></title>
    <url>%2F2019%2F12%2F23%2FValiantFrontier%2F</url>
    <content type="text"><![CDATA[有 $n$ 条巨龙，第 $i$ 条血量为 $a_i$, 杀死之后将得到一把攻击力为 $b_i$ 的剑。 开始时拥有 $m$ 把攻击力已知的剑，有一个机器人会用这些剑去屠龙。每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择 攻击力最低的一把剑作为武器。之后，它会使用之前选定的攻击力为 $t$ 的剑攻击 $x$ 次，使得龙的血量减少 $tx$. 如果这个时候血量低于 0, 那么龙会以每次 $p_i$ 的血量回血直到不小于 0. 如果最终龙的血量正好等于 0, 那么龙会死掉。 需要求出将 $x$ 最小设定成多少可以杀掉所有的龙，无解输出 $-1$. 可以发现每一次选择的剑都是固定的，可以提前求出来。 观察所有测试点可以发现，如果不满足 $a_i\leq p_i$, 那么一定有 $\forall p_i=1$, 对于后一种情况，答案是 $\operatorname{Max}\left(\left\lfloor\frac {a_i}{c_i}\right\rfloor\right)$. 否则，相当于求解同余方程组，第 $i$ 个形如 $c_ix\equiv a_i\pmod{p_i}$. 考虑如何将这个方程化成 $x\equiv a\pmod{b}$ 的形式。 首先可以将它写成不定方程形式 c_ix+p_iy=a_i求出这个方程的一个特解 $x^\prime$. 那么 x=x^\prime+k\frac{p_i}{\gcd(c_i,p_i)}\\ x\equiv x^\prime\pmod{\frac{p_i}{\gcd(c_i,p_i)}}如果任何一个 $p_i$ 不是 $\gcd(c_i,p_i)$ 的倍数，或者最终的同余方程组无解，那么答案是 $-1$. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;namespace Templates&#123; long long Mult(long long a,long long b,long long MOD)&#123; long long ans = 0LL, f = 1LL; if(a &lt; 0) a = -a, f = -f; if(b &lt; 0) b = -b, f = -f; for(;b;b&gt;&gt;=1,(a&lt;&lt;=1)%=MOD) if(b&amp;1) (ans += a) %= MOD; return ans*f; &#125; long long exgcd(long long a,long long b,long long&amp; x,long long&amp; y)&#123; if(!b)&#123; x = 1LL; y = 0LL; return a; &#125; long long ret = exgcd(b,a%b,y,x); y -= a/b*x; return ret; &#125; long long Inverse(long long a,long long MOD)&#123; long long x,y; a %= MOD; exgcd(a,MOD,x,y); return (x%MOD+MOD)%MOD; &#125;&#125;; using namespace Templates;constexpr auto MAXN = (int)1e5+50;long long c[MAXN],a[MAXN],p[MAXN],rwd[MAXN];std::multiset&lt;long long&gt; S;signed main(void)&#123; //freopen("dragon.in","r",stdin); //freopen("dragon.out","w",stdout); int totCases; int totDrg,totSwd; long long inp; scanf("%d", &amp;totCases); bool spj; std::multiset&lt;long long&gt;::iterator ito; while(totCases--)&#123; scanf("%d%d", &amp;totDrg,&amp;totSwd); for(int i=0;i&lt;totDrg;++i) scanf("%lld", a+i); for(int i=0;i&lt;totDrg;++i) scanf("%lld", p+i); for(int i=0;i&lt;totDrg;++i) scanf("%lld", rwd+i); for(int i=0;i&lt;totSwd;++i)&#123; scanf("%lld", &amp;inp); S.insert(inp); &#125; for(int i=0;i&lt;totDrg;++i)&#123; ito = (a[i]&lt;(*S.begin())) ? S.begin() : (--S.upper_bound(a[i])); c[i] = *ito; S.erase(ito); S.insert(rwd[i]); &#125; &#123; std::multiset&lt;long long&gt; T; std::swap(T,S); &#125; spj = true; for(int i=0;i&lt;totDrg;++i) if(p[i] != 1)&#123; spj = false; break; &#125; if(spj)&#123; long long max = 0; for(int i=0;i&lt;totDrg;++i) max = std::max(max, a[i]/c[i] + (a[i]%c[i]==0 ? 0 : 1)); printf("%lld\n", max); &#125; else &#123; for(int i=0;i&lt;totDrg;++i) if((c[i]%=p[i]) == 0LL) if(a[i] == p[i])&#123; a[i] = 0LL; p[i] = 1LL; c[i] = 1LL; &#125; else&#123; puts("-1"); goto END; &#125; long long gcd,x,y,t; for(int i=0;i&lt;totDrg;++i)&#123; gcd = exgcd(c[i],p[i],x,y); if(a[i]%gcd != 0)&#123; puts("-1"); goto END; &#125; p[i] /= gcd; x = (x%p[i]+p[i]) % p[i]; a[i] = Mult(x,(a[i]/gcd),p[i]); &#125; //Merge long long na,np; for(int i=1;i&lt;totDrg;i++)&#123; gcd = std::__gcd(p[i],p[i-1]); if((a[i]-a[i-1])%gcd != 0)&#123; puts("-1"); goto END; &#125; na = Mult(Inverse(p[i-1]/gcd,p[i]/gcd), (a[i]-a[i-1])/gcd, p[i]/gcd); np = p[i]/gcd*p[i-1]; na = Mult(na, p[i-1], np); (na += a[i-1]) %= np; a[i] = na; p[i] = np; &#125; printf("%lld\n", (a[totDrg-1]%p[totDrg-1]+p[totDrg-1])%p[totDrg-1]); &#125; END:; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>CRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Extended CRT 扩展中国剩余定理]]></title>
    <url>%2F2019%2F12%2F18%2FexCRT%2F</url>
    <content type="text"><![CDATA[给定 $n$ 组非负整数 $a_i,\ b_i$, 求解关于 $x$ 的方程组的最小非负整数解。 \begin{cases} x\equiv b_1\pmod{a_1}\\ x\equiv b_2\pmod{a_2}\\ \quad\vdots\\ x\equiv b_n\pmod{a_n} \end{cases}CRT 可以在所有的 $a$ 互素时求解，如果它们之间不满足任何特殊的条件，那么就需要使用到 exCRT. 基本思路是通过变换将两个同余方程合并为一个，增量地一个个合并直到仅剩下一个同余方程。 考虑同余方程 x\equiv a\pmod{b_i}它的一个解显然是 $x=a$. 如果有两个同余方程组成的方程组，考虑如何将他们合并成一个 \begin{cases} x\equiv a_{i-1}\pmod{b_{i-1}}\\ x\equiv a_i\pmod{b_i} \end{cases}可以将这个方程组转化为 \begin{cases} x+k_1b_i=a_i\\ x+k_2b_{i-1}=a_{i-1}\end{cases}上下相减得到 k_1b_i-k_2b_{i-1}=a_i-a_{i-1}将等号左右两边同时乘上 $d=\frac{\operatorname{gcd}(b_i,b_{i-1})}{a_i-a_{i-1}}$, 同时令 $k_1^\prime=k_1d,\ k_2^\prime=k_2d$. 那么 k_1^\prime b_i+k_2^\prime b_{i-1}=\gcd(b_i,b_{i-1})利用扩展欧几里德算法求出这个不定方程的一个特解 $k_{1_0}^\prime$. 那么 $k_1$ 的一个特解是 $k_{1_0}^\prime d^{-1}$. 通解是 $k_1=t\frac{b_{i-1}}{\gcd(b_i,b_{i-1})}\quad t\in\mathbb Z$. 由于 x+k_1b_i=a_i将 $k_1$ 的值带入得到 x+b_ik_1+t\frac{b_ib_{i-1}}{\gcd(b_i,b_{i-1})}=a_i\\ t\operatorname{lcm}(b_i,b_{i-1})=a_i-x-b_ik_1由于 $t\in\mathbb Z$, 那么 a_i-x-b_ik_1\equiv0\pmod{\operatorname{lcm}(b_i,b_{i-1})}\\ x\equiv a_i-b_ik_1\pmod{\operatorname{lcm}(b_i,b_{i-1})}12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;long long Mult(long long a,long long b,const long long&amp; MOD)&#123; long long ans = 0LL,f = 1LL; if(a &lt; 0) a = -a, f = -f; if(b &lt; 0) b = -b, f = -f; for(;b;b&gt;&gt;=1,(a&lt;&lt;=1)%=MOD) if(b&amp;1) (ans += a) %= MOD; return ans*f;&#125;long long exgcd(long long a,long long b,long long&amp; x,long long&amp; y)&#123; if(!b)&#123; x = 1; y = 0; return a; &#125; long long ret = exgcd(b,a%b, y,x); y -= a/b*x; return ret;&#125;signed main(void)&#123; int totFomula; long long a,b,la,lb; scanf("%d%lld%lld", &amp;totFomula,&amp;lb,&amp;la); long long t,gcd,x,y; while(--totFomula)&#123; scanf("%lld%lld", &amp;b,&amp;a); gcd = exgcd(b,lb,x,y); t = lb/gcd; x = (Mult(x,(a-la)/gcd,t)%t+t) % t; a -= Mult(x,b,b/gcd*lb); (b /= gcd) *= lb; a = (a%b+b) % b; la = a; lb = b; &#125; printf("%lld\n", (a%b+b)%b); return 0;&#125; 并不是所有的同余方程组都是有解的，有时需要用另一种思路合并 \begin{cases} x\equiv c_1\pmod{p_1}\\ x\equiv c_2\pmod{p_2} \end{cases}将他们写成不定方程的形式 \begin{cases} x=c_1+p_1y_1\\ x=c_2+p_2y_2\\ \end{cases}那么 p_1y_1=p_2y_2+c_2-c_1两边同时乘上 $\frac 1{\gcd(p_1,p_2)}$ \frac{p_1}{\gcd(p_1,p_2)}y_1=\frac{p_2}{\gcd(p_1,p_2)}+\frac{c_2-c_1}{\gcd(p_1,p_2)}\\ \frac{p_1}{\gcd(p_1,p_2)}y_1\equiv\frac{c_2-c_1}{\gcd(p_1,p_2)}\pmod{\frac{p_2}{\gcd(p_1,p_2)}}如果 $c_2-c_1\not|\gcd(p_1,p_2)$, 那么这两个同余方程无法被合并，方程组无解。 由于 $\frac{p_1}{\gcd(p_1,p_2)}$ 和 $\frac{p_2}{\gcd(p_1,p_2)}$ 是互素的，因此可以在模 $\frac{p_2}{\gcd(p_1,p_2)}$ 的意义下求出 $\frac{p_1}{\gcd(p_1,p_2)}$ 的逆元，两边同时乘上这个逆元。 y_1\equiv\left(\frac{p_2}{\gcd(p_1,p_2)}^{-1}\mod\frac{p_2}{\gcd(p_1,p_2)}\right)\pmod{\frac{p_2}{\gcd(p_1,p_2)}}\\ y_1=\left(\frac{p_2}{\gcd(p_1,p_2)}^{-1}\mod\frac{p_2}{\gcd(p_1,p_2)}\right)+k\frac{p_2}{\gcd(p_1,p_2)}将 $y_1$ 代入到 $x=c_1+p_1y_1$ 中，得到 x=\left(\frac{p_2}{\gcd(p_1,p_2)}^{-1}\cdot\frac{c_2-c_1}{\gcd(p_1,p_2)}\mod\frac{p_2}{\gcd(p_1,p_2)}\right)p_1+c_1+k\frac{p_1p_2}{\gcd(p_1,p_2)}\\ x\equiv\left(\frac{p_2}{\gcd(p_1,p_2)}^{-1}\cdot\frac{c_2-c_1}{\gcd(p_1,p_2)}\mod\frac{p_2}{\gcd(p_1,p_2)}\right)p_1+c_1\pmod{\operatorname{lcm}(p_1,p_2)}代码实现大致一样 123456789for(int i=1;i&lt;totDrg;i++)&#123; gcd = std::__gcd(p[i],p[i-1]); if((a[i]-a[i-1])%gcd != 0) throw 1; na = Mult(Inverse(p[i-1]/gcd,p[i]/gcd), (a[i]-a[i-1])/gcd, p[i]/gcd); np = p[i]/gcd*p[i-1]; na = Mult(na, p[i-1], np); (na += a[i-1]) %= np; a[i] = na; p[i] = np;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI2017 树点涂色]]></title>
    <url>%2F2019%2F12%2F17%2Ftvtcolor%2F</url>
    <content type="text"><![CDATA[Bob 有一棵 $n$ 个点的有根树，其中 $1$ 号点是根节点。Bob 在每个点上涂了颜色，并且每个点上的颜色不同。 定义一条路径的权值是：这条路径上的点（包括起点和终点）共有多少种不同的颜色。 Bob可能会进行这几种操作： 1 x 表示把点 $x$ 到根节点的路径上所有的点染上一种没有用过的新颜色。 2 x y 求 $x$ 到 $y$ 的路径的权值。 3 x 在以 $x$ 为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。 Bob一共会进行 $m$ 次操作 考虑到 $1$ 号操作与 LCT 的 Access 过程非常像，都将结点 $x$ 到根这一段路径上所有的点变成了同一种类型的，因此用一棵 LCT 维护这棵树，LCT 中每一个 Splay 都是一种相邻的颜色，可以证明他们一定是树上连着的一段。 考虑两个查询操作，显然对于 2 操作是不能直接 Split 的，否则破坏了颜色之间的关系。在 LCT 上直接维护权值有些困难，可以用树链剖分的思想替代。在 1 操作的时候如果需要拆掉某一个 Splay 中的一段，可以直接将这一段代表的颜色变为一个颜色序列上的很多段，用线段树维护即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)1e5+50;constexpr auto MAXM = MAXN;std::vector&lt;int&gt; G[MAXN];int ind[MAXN],siz[MAXN],top[MAXN],imp[MAXN],depth[MAXN],fa[MAXN],dfs_clock;void Dfs1(const int&amp; nowAt,const int up = 0)&#123; siz[nowAt] = 1; depth[nowAt] = depth[fa[nowAt]=up] + 1; for(const auto&amp; it : G[nowAt]) if(it != up)&#123; Dfs1(it, nowAt); siz[nowAt] += siz[it]; if(siz[imp[nowAt]] &lt; siz[it]) imp[nowAt] = it; &#125;&#125;void Dfs2(const int&amp; nowAt,const int fa = 0)&#123; ind[nowAt] = dfs_clock++; if(imp[fa] != nowAt) top[nowAt] = nowAt; else top[nowAt] = top[fa]; if(imp[nowAt] &gt; 0) Dfs2(imp[nowAt], nowAt); for(const auto&amp; it : G[nowAt]) if(it!=fa &amp;&amp; it!=imp[nowAt]) Dfs2(it, nowAt);&#125;int LCA(int a,int b)&#123; while(top[a] != top[b])&#123; if(depth[top[a]] &lt; depth[top[b]]) std::swap(a,b); a = fa[top[a]]; &#125; return depth[a]&lt;depth[b] ? a : b;&#125;//Segment Treenamespace SegTr&#123; struct Node&#123; int fr,to; int maxval,delt; Node *lft,*rgt; Node()&#123; lft = rgt = nullptr; &#125; Node(const int&amp; ifr,const int&amp; ito) : fr(ifr),to(ito)&#123; lft = rgt = nullptr; delt = 0; &#125; Node(const int&amp; ifr,const int&amp; ito,const int&amp; imax) : fr(ifr),to(ito),maxval(imax) &#123; lft = rgt = nullptr; delt = 0; &#125; Node&amp; Mark(const int&amp; val)&#123; delt += val; maxval += val; return *this; &#125; Node&amp; Push_Down(void)&#123; if(lft!=nullptr &amp;&amp; delt)&#123; lft-&gt;Mark(delt); rgt-&gt;Mark(delt); delt = 0; &#125; return *this; &#125; Node&amp; Update(void)&#123; if(lft != nullptr) maxval = std::max(lft-&gt;maxval, rgt-&gt;maxval); return *this; &#125; &#125;*root; void Build(const int&amp; siz,int* valarr)&#123; Node *a,*b,*t; std::queue&lt;Node*&gt; que,add; for(int i=0;i&lt;siz;i++)&#123; t = new Node(i,i,*valarr++); que.push(t); &#125; for(;que.size()&gt;=2; std::swap(que,add))&#123; while(que.size()&gt;=2)&#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = new Node(a-&gt;fr,b-&gt;to,std::max(a-&gt;maxval,b-&gt;maxval)); t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if(!que.empty())&#123; add.push(que.front()); que.pop(); &#125; &#125; root = que.front(); &#125; void Add(const int&amp; fr,const int&amp; to,const int&amp; val,Node* nowAt)&#123; if(to&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;fr) return; nowAt-&gt;Push_Down(); if(fr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=to) nowAt-&gt;Mark(val); else&#123; Add(fr,to,val,nowAt-&gt;lft); Add(fr,to,val,nowAt-&gt;rgt); nowAt-&gt;Update(); &#125; &#125; void AddT(int fr,int to,const int&amp; val)&#123; if(fr &gt; to) std::swap(fr,to); Add(fr,to,val,root); &#125; void Add(const int&amp; targ,const int&amp; val)&#123; Add(ind[targ], ind[targ]+siz[targ]-1, val,root); &#125; void Add(int a,int b,const int&amp; val)&#123; while(top[a] != top[b])&#123; if(depth[top[a]] &lt; depth[top[b]]) std::swap(a,b); AddT(ind[a], ind[top[a]], val); a = fa[top[a]]; &#125; AddT(ind[a], ind[b], val); &#125; int Query(const int&amp; fr,const int&amp; to,Node* nowAt)&#123; if(to&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;fr) return INT_MIN; nowAt-&gt;Push_Down(); if(fr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=to) return nowAt-&gt;maxval; else return std::max(Query(fr,to,nowAt-&gt;lft), Query(fr,to,nowAt-&gt;rgt)); &#125; int Query(int fr,int to)&#123; if(fr &gt; to) std::swap(fr,to); return Query(fr,to,root); &#125; int Query(int targ)&#123; return Query(targ,targ,root); &#125;&#125;;//Link-Cut Treestruct /*LCT*/Node&#123; int ID; bool rev; Node *ch[2],*fa; Node()&#123; ch[0] = ch[1] = nullptr; fa = nullptr; rev = false; &#125; bool IsRoot(void)&#123; if(fa == nullptr) return true; else if(fa-&gt;ch[0]==this || fa-&gt;ch[1]==this) return false; else return true; &#125; Node&amp; Mark(void)&#123; rev ^= 1; return *this; &#125; Node&amp; Push_Down(void)&#123; if(rev)&#123; std::swap(ch[0], ch[1]); rev = false; &#125; return *this; &#125; short Position(Node* targ)&#123; if(targ!=ch[0] &amp;&amp; targ!=ch[1]) return -1; else return targ==ch[0] ? 0 : 1; &#125;&#125;node[MAXN];void Rotate(Node* targ)&#123; const short pos = targ-&gt;fa-&gt;ch[0] == targ ? 1 : 0; Node* faa = targ-&gt;fa; if(!faa-&gt;IsRoot()) faa-&gt;fa-&gt;ch[faa-&gt;fa-&gt;ch[1]==faa] = targ; faa-&gt;ch[pos^1] = targ-&gt;ch[pos]; if(targ-&gt;ch[pos] != nullptr) targ-&gt;ch[pos]-&gt;fa = faa; targ-&gt;ch[pos] = faa; targ-&gt;fa = faa-&gt;fa; faa-&gt;fa = targ;&#125;void Spaly(Node* targ)&#123; static std::stack&lt;Node*&gt; stk; Node* nowAt = targ; stk.push(targ); while(!nowAt-&gt;IsRoot()) stk.push(nowAt = nowAt-&gt;fa); while(!stk.empty())&#123; stk.top()-&gt;Push_Down(); stk.pop(); &#125; for(;!targ-&gt;IsRoot() &amp;&amp; !targ-&gt;fa-&gt;IsRoot(); Rotate(targ)) if(targ-&gt;fa-&gt;fa-&gt;Position(targ-&gt;fa) == targ-&gt;fa-&gt;Position(targ)) Rotate(targ-&gt;fa); else Rotate(targ); if(!targ-&gt;IsRoot()) Rotate(targ);&#125;Node* Find(Node* nowAt)&#123; while(nowAt-&gt;ch[0] != nullptr) nowAt = nowAt-&gt;ch[0]; return nowAt;&#125;void Access(Node* nowAt)&#123; for(Node* y=nullptr; nowAt!=nullptr; nowAt=nowAt-&gt;fa)&#123; Spaly(nowAt); if(nowAt-&gt;ch[1] != nullptr) SegTr::Add(Find(nowAt-&gt;ch[1])-&gt;ID, 1); if(y != nullptr) SegTr::Add(Find(y)-&gt;ID, -1); nowAt-&gt;ch[1] = y; y = nowAt; &#125;&#125;//Mainsigned main(void)&#123; int totVertex,totOpt,opt,targ,val,fr,to; scanf("%d%d", &amp;totVertex,&amp;totOpt); for(int i=1;i&lt;totVertex;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); G[fr].push_back(to); G[to].push_back(fr); &#125; Dfs1(1); Dfs2(1); //Init static int *insarr = new int[totVertex]; for(int i=1;i&lt;=totVertex;i++) insarr[ind[i]] = depth[i]; SegTr::Build(totVertex,insarr); delete insarr; for(int i=1;i&lt;=totVertex;i++)&#123; node[i].ID = i; node[i].fa = fa[i]&gt;0 ? node+fa[i] : nullptr; &#125; while(totOpt--)&#123; scanf("%d", &amp;opt); switch(opt)&#123; case 1: scanf("%d", &amp;targ); Access(node+targ); //for(int i=1;i&lt;=totVertex;i++) // std::cout&lt;&lt;SegTr::Query(ind[i])&lt;&lt;' '; std::cout&lt;&lt;std::endl; break; case 2: scanf("%d%d", &amp;fr,&amp;to); targ = LCA(fr,to); printf("%d\n", SegTr::Query(ind[fr])+SegTr::Query(ind[to])-(SegTr::Query(ind[targ])&lt;&lt;1)+1); break; case 3: scanf("%d", &amp;targ); printf("%d\n", SegTr::Query(ind[targ],ind[targ]+siz[targ]-1)); break; default: assert(false); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>LCA</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI2017 序列计数]]></title>
    <url>%2F2019%2F12%2F16%2FSeqc%2F</url>
    <content type="text"><![CDATA[一个长度为 $n$ 的序列，序列中的数都是不超过 $m$ 的正整数，且这 $n$ 个数的和是 $p$ 的倍数，其中至少有一个数是素数。 需要计算出在所有长度为 $n$ 的序列中，有多少个符合要求。 先将所有不考虑含有一个素数这个条件的序列数量算出来，然后再减去全部是合数构成的序列个数就是答案。 由于 $p$ 非常小，我们预处理出来一个 $p\times p$ 的矩阵 $A$，其中的一个元素 $A_{i,j}$ 代表 $1$ 至 $m$ 这些数中模 $p$ 得到的数同余于 $i-j$ 的有多少个，记这个数字为 $c_{(i+j)\%p}$. A=\begin{bmatrix} c_0&c_{p-1}&c_{p-2}&\cdots&c_1\\ c_1&c_0&c_{p-1}&\cdots&c_2\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ c_{p-1}&c_{p-2}&c_{p-3}&\cdots&c_0 \end{bmatrix}可以发现，如果令 $B=A\times A$, 那么 $B$ 中的任何一个元素 $B_{i,j}$ 都代表 $1$ 至 $m$ 中选择两个数模 $p$ 同余于 $i-j$ 的排列个数。也就是说，令 $C=A^n$, 答案就是 $C_{0,0}$. 接下来只需要去掉所有的纯合数构成的序列了。类似地，筛出 $1$ 至 $m$ 这个范围内所有的素数，然后利用剩下的数计算 $A^\prime$ 数组，答案即为 $({A^\prime}^n)_{0,0}$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;constexpr auto MOD = 20170408LL;constexpr auto MAXN = 105;constexpr auto MAXM = (int)2e7;struct Matrix&#123; long long val[MAXN][MAXN]; Matrix()&#123; memset(val,0,sizeof(val)); &#125; Matrix&amp; Cls(void)&#123; memset(val,0,sizeof(val)); return *this; &#125; Matrix&amp; Def(void)&#123; memset(val,0,sizeof(val)); for(int i=0;i&lt;MAXN;i++) val[i][i] = 1LL; return *this; &#125; Matrix operator * (const Matrix&amp; times) const&#123; Matrix ans; for(int i=0;i&lt;MAXN;i++) for(int j=0;j&lt;MAXN;j++) for(int k=0;k&lt;MAXN;k++) (ans.val[i][j] += val[i][k] * times.val[k][j]) %= MOD; return ans; &#125; Matrix&amp; operator *= (const Matrix&amp; times)&#123; return *this = *this*times; &#125; Matrix operator ^ (long long b) const &#123; Matrix ans,t; for(int i=0;i&lt;MAXN;i++) for(int j=0;j&lt;MAXN;j++) t.val[i][j] = val[i][j]; for(ans.Def(); b; t*=t,b&gt;&gt;=1) if(b&amp;1LL) ans *= t; return ans; &#125; Matrix&amp; operator ^= (long long b)&#123; return *this = *this^b; &#125;&#125;;int prime[MAXM&gt;&gt;2],minFactor[MAXM];int cnt[MAXN],cntp[MAXN]; int cntPrime;signed main(void)&#123; int totNums,maxVal,fac; std::cin&gt;&gt;totNums&gt;&gt;maxVal&gt;&gt;fac; //GetPrimes cntp[1%fac] = 1; cnt[1%fac] = 1; for(int i=2;i&lt;=maxVal;++i)&#123; ++cnt[i % fac]; ++cntp[i % fac]; if(minFactor[i] == 0)&#123; --cntp[i % fac]; prime[cntPrime++] = i; minFactor[i] = i; &#125; for(int j=0;j&lt;cntPrime;++j)&#123; if((long long)prime[j]*i&gt;maxVal || prime[j]&gt;minFactor[i]) break; minFactor[i*prime[j]] = prime[j]; &#125; &#125; Matrix mtx; for(int i=0;i&lt;fac;i++) for(int j=0;j&lt;fac;j++) mtx.val[i][j] = cnt[(i-j+fac)%fac]; mtx ^= totNums; long long ans = mtx.val[0][0]; mtx.Cls(); for(int i=0;i&lt;fac;i++) for(int j=0;j&lt;fac;j++) mtx.val[i][j] = cntp[(i-j+fac)%fac]; mtx ^= totNums; ans -= mtx.val[0][0]; std::cout&lt;&lt;(ans%MOD+MOD)%MOD&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>素数判定/筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2018 你的名字]]></title>
    <url>%2F2019%2F12%2F11%2FYourName%2F</url>
    <content type="text"><![CDATA[给定一个长度为 $n$ 的文本串 $s$, 有 $q$ 次询问，每一次询问给定一个串 $t$ 和一个区间 $[l,r]$, 需要求出 $t$ 有多少个本质不同的子串是不是 $s_{l\cdots r}$ 的任何一个子串。 将每一次询问串 $t$ 建立成后缀树，如果 $s$ 和 $t$ 没有一个相等的字符，那么 $t$ 所有不同的子串个数就是 $t$ 的后缀树所代表的 trie 的结点树(需要减去最后 $ 记号构成的子串)，然后每一次指定一个左端点 $l$, 在仅考虑 $s_{l\cdots r}$ 的情况下向右匹配尽可能多的字符，如果匹配到了 $r$, 那么 $t_{l\cdots r}$ 对应着 $t$ 后缀树上一个从 $t_0$ 出发的链，将这条链上所有的结点都打上记号，最后一次深搜搜出所有没有记号的结点，答案就是这些结点中不同的结点个数。 先考虑对于所有询问 $l=1,\,r=|S|$ 的情况，此时我们在 $s$ 整颗后缀树中尽可能多地匹配 $t$, 也就是用两个指针分别指向 $s$ 的后缀树和 $t$ 的后缀树。假定我们现在最多匹配到了 $t_{u\cdots v}$, 那么在下一步我们将开始的位置变成 $u+1$, 只需要将两个指针跳一次所在点的后缀链接。特别地，$t_0$ 的后缀链接指向自己。 接下来考虑正解，如果我们只考虑 $s_{l\cdots r}$, 那么 $s$ 对应的后缀树中有很多结点就不能访问到，能走到的结点只有开始于 $[l,r]$ 的后缀组成的链上的点。对于后缀树上的每一个结点，从 $t_0$ 到它连成的串是若干个后缀的前缀，这些后缀就是它子树中所有的叶子结点代表的后缀。因此我们可以对于每一个点建立一颗线段树，保存以这个点为根的子树中存在的后缀，在预处理的时候可持久化线段树合并可以快速求出每个点对应的线段树，之后每次走入一个新结点的时候都查询一下是否在那个结点中有符合条件的后缀即可。 总时间复杂度为 $O(N\log N+M\log N)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include&lt;bits/stdc++.h&gt;constexpr auto INT_32_MAX = 100000000;//SegmentTreenamespace SegTr&#123; const int range = (int)1e6+5; struct Node&#123; Node* lft,*rgt; int ID; Node(const int&amp; iID) : ID(iID) &#123; lft = rgt = nullptr; &#125; ~Node()&#123; if(lft!=nullptr) delete lft; if(rgt!=nullptr) delete rgt; &#125; &#125;; Node* Build(const int&amp; targ,const int&amp; ID)&#123; Node* ret = new Node(ID); int fr=0,to=range,mid; for(Node* nowAt=ret;fr&lt;to;)&#123; mid = fr+to&gt;&gt;1; if(targ&lt;=mid)&#123; nowAt-&gt;lft = new Node(ID); nowAt = nowAt-&gt;lft; to = mid; &#125; else&#123; nowAt-&gt;rgt = new Node(ID); nowAt = nowAt-&gt;rgt; fr = mid+1; &#125; &#125; return ret; &#125; Node* Merge(Node* a,Node* b,const int&amp; ID)&#123; if(a == nullptr) return b; if(b == nullptr) return a; Node* ret = new Node(ID); ret-&gt;lft = Merge(a-&gt;lft,b-&gt;lft,ID); ret-&gt;rgt = Merge(a-&gt;rgt,b-&gt;rgt,ID); return ret; &#125; void Attend(Node*&amp; a,Node* b,const int&amp; ID)&#123; if(a == nullptr)&#123; a = b; return; &#125; if(b == nullptr) return; if(a-&gt;ID != ID)&#123; Node* t = new Node(ID); t-&gt;lft = a-&gt;lft; t-&gt;rgt = a-&gt;rgt; a = t; &#125; Attend(a-&gt;lft,b-&gt;lft,ID); Attend(a-&gt;rgt,b-&gt;rgt,ID); &#125; bool Query(const int&amp; fr,const int&amp; to,Node* nowAt,const int nfr=0,const int nto=range)&#123; if(nowAt==nullptr || nfr&gt;nto || nto&lt;fr || to&lt;nfr) return false; if(fr&lt;=nfr &amp;&amp; nto&lt;=to) return true; if(Query(fr,to,nowAt-&gt;lft,nfr,nfr+nto&gt;&gt;1)) return true; if(Query(fr,to,nowAt-&gt;rgt,1+(nfr+nto&gt;&gt;1),nto)) return true; return false; &#125;&#125;;constexpr auto MAXN = (int)5e5+50;constexpr auto MAXM = (int)1e6+50;constexpr auto MAXK = 28;//Suffix Treestruct Node&#123; int start,len,totLen; SegTr::Node* root; Node* ch[MAXK],*link; Node()&#123; start = len = 0; link = nullptr; root = nullptr; memset(ch,0,sizeof(ch)); &#125; Node(const int&amp; istart,const int&amp; ilen) : start(istart),len(ilen) &#123; link = nullptr; root = nullptr; memset(ch,0,sizeof(ch)); &#125; ~Node()&#123; if(root != nullptr) delete root; for(auto&amp; it : ch) if(it != nullptr) delete it; &#125;&#125;*t0,*virt,*nowAt;int s[MAXN],remain,totLen;void Attend(const int&amp; add)&#123; s[totLen++] = add; ++remain; for(Node* last=virt,*t; remain;)&#123; while(nowAt-&gt;ch[s[totLen-remain]]!=nullptr &amp;&amp; remain&gt;nowAt-&gt;ch[s[totLen-remain]]-&gt;len)&#123; t = nowAt-&gt;ch[s[totLen-remain]]; remain -= t-&gt;len; nowAt = t; &#125; Node*&amp; v = nowAt-&gt;ch[s[totLen-remain]]; int endChar_v = v==nullptr ? MAXK-1 : s[v-&gt;start+remain-1]; if(v==nullptr || endChar_v==add)&#123; last-&gt;link = nowAt; last = nowAt; if(v == nullptr) v = new Node(totLen-remain,INT_32_MAX); else break; &#125; else &#123; Node* split = new Node(v-&gt;start, remain-1); v-&gt;start += remain-1; v-&gt;len -= remain-1; split-&gt;ch[endChar_v] = v; split-&gt;ch[add] = new Node(totLen-1, INT_32_MAX); last-&gt;link = v = split; last = split; &#125; if(nowAt == t0) --remain; else nowAt = nowAt-&gt;link; &#125;&#125;int dfs_clock;void Dfs1(Node* nowAt,const int&amp; sumLen=0)&#123; int ch = 0; const int dfn = ++dfs_clock; for(const auto&amp; it : nowAt-&gt;ch) if(it != nullptr) ++ch; if(ch == 0)&#123; nowAt-&gt;len = totLen - nowAt-&gt;start; nowAt-&gt;totLen = nowAt-&gt;len + sumLen; nowAt-&gt;root = SegTr::Build(totLen-nowAt-&gt;totLen,dfn); return; &#125; nowAt-&gt;totLen = sumLen+nowAt-&gt;len; SegTr::Node* ch1; ch = 0; for(const auto&amp; it : nowAt-&gt;ch) if(it != nullptr)&#123; Dfs1(it, nowAt-&gt;totLen); if(ch == 0) ch1 = it-&gt;root; else if(ch == 1) nowAt-&gt;root = SegTr::Merge(ch1, it-&gt;root,dfn); else SegTr::Attend(nowAt-&gt;root, it-&gt;root,dfn); ++ch; &#125;&#125;char ins[MAXM];int insarr[MAXM];namespace CNT&#123; struct Node&#123; int start,len,cov,totLen; Node* ch[MAXK],*link; Node()&#123; start = len = 0; link = nullptr; cov = -1; memset(ch,0,sizeof(ch)); &#125; Node(const int&amp; istart,const int&amp; ilen) : start(istart),len(ilen) &#123; link = nullptr; memset(ch,0,sizeof(ch)); cov = -1; &#125; ~Node()&#123; for(auto&amp; it : ch) if(it != nullptr) delete it; &#125; &#125;*t0,*virt,*nowAt; int s[MAXM],totLen,remain; int cov; void Attend(const int&amp; add)&#123; s[totLen++] = add; ++remain; for(Node* last=virt,*t; remain;)&#123; while(nowAt-&gt;ch[s[totLen-remain]]!=nullptr &amp;&amp; remain&gt;nowAt-&gt;ch[s[totLen-remain]]-&gt;len)&#123; t = nowAt-&gt;ch[s[totLen-remain]]; remain -= t-&gt;len; nowAt = t; &#125; Node*&amp; v = nowAt-&gt;ch[s[totLen-remain]]; int endChar_v = v==nullptr ? MAXK-1 : s[v-&gt;start+remain-1]; if(v==nullptr || endChar_v==add)&#123; last-&gt;link = nowAt; last = nowAt; if(v == nullptr) v = new Node(totLen-remain,INT_32_MAX); else break; &#125; else &#123; Node* split = new Node(v-&gt;start, remain-1); v-&gt;start += remain-1; v-&gt;len -= remain-1; split-&gt;ch[endChar_v] = v; split-&gt;ch[add] = new Node(totLen-1, INT_32_MAX); last-&gt;link = v = split; last = split; &#125; if(nowAt == t0) --remain; else nowAt = nowAt-&gt;link; &#125; &#125; long long cntans; void cntDfs(Node* nowAt)&#123; for(const auto&amp; it : nowAt-&gt;ch) if(it!=nullptr)&#123; cntDfs(it); if(it-&gt;cov != -1) nowAt-&gt;cov = nowAt-&gt;len; &#125; if(nowAt-&gt;cov &lt; 0) cntans += nowAt-&gt;len; else cntans += nowAt-&gt;len - nowAt-&gt;cov; &#125; void Dfs(Node* nowAt,const int&amp; sumLen=0)&#123; int ch = 0; for(const auto&amp; it : nowAt-&gt;ch) if(it != nullptr) ++ch; if(ch == 0)&#123; nowAt-&gt;len = totLen - nowAt-&gt;start; nowAt-&gt;totLen = nowAt-&gt;len + sumLen; return; &#125; nowAt-&gt;totLen = sumLen+nowAt-&gt;len; for(const auto&amp; it : nowAt-&gt;ch) if(it != nullptr) Dfs(it, nowAt-&gt;totLen); &#125; long long Count(void)&#123; cntans = 0LL; cntDfs(t0); return cntans; &#125; void Build(char* a)&#123; remain = totLen = 0; if(t0 != nullptr) delete t0; t0 = new Node(); nowAt = t0; if(virt==nullptr) virt = new Node(); for(;*a!='\0';++a) Attend(*a-'a'); Attend(MAXK-2); t0-&gt;link = t0; Dfs(t0); &#125;&#125;//Mainsigned main(void)&#123; int totQuery,fr,to; scanf("%s%d", ins,&amp;totQuery); t0 = new Node(); virt = new Node(); nowAt = t0; for(char* it=ins; *it!='\0'; ++it) Attend(*it-'a'); Attend(MAXK-2); t0-&gt;link = t0; Dfs1(t0); long long ans; int cov,inslen,totprevlen,delt; while(totQuery--)&#123; scanf("%s%d%d", ins,&amp;fr,&amp;to); --fr; --to; inslen = strlen(ins); CNT::Build(ins); for(int i=0;i&lt;inslen;i++) insarr[i] = ins[i]-'a'; nowAt = t0; cov = 0; CNT::nowAt = CNT::t0; CNT::cov = 0; totprevlen = 0; //nxtchar_pos for(int beg=0;beg&lt;inslen;++beg)&#123; if(totprevlen &lt; beg)&#123; totprevlen = beg; nowAt = t0; CNT::nowAt = CNT::t0; cov = CNT::cov = 0; &#125; nowAt = nowAt-&gt;link; cov = totprevlen-nowAt-&gt;totLen-beg; CNT::nowAt = CNT::nowAt-&gt;link; CNT::cov = totprevlen-CNT::nowAt-&gt;totLen-beg; while(cov&gt;0 &amp;&amp; cov&gt;=nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;len)&#123; delt = nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;len; nowAt = nowAt-&gt;ch[insarr[totprevlen-cov]]; cov -= delt; &#125; while(CNT::cov&gt;0 &amp;&amp; CNT::cov&gt;=CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;len)&#123; delt = CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;len; CNT::nowAt = CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]; CNT::cov -= delt; &#125; while(totprevlen&lt;inslen &amp;&amp; (cov&gt;0 || nowAt-&gt;ch[insarr[totprevlen]]!=nullptr) &amp;&amp; SegTr::Query(fr,to-totprevlen+beg,nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;root) &amp;&amp; s[nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;start+cov]==insarr[totprevlen])&#123; ++cov; ++CNT::cov; ++totprevlen; while(cov&gt;0 &amp;&amp; cov&gt;=nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;len)&#123; delt = nowAt-&gt;ch[insarr[totprevlen-cov]]-&gt;len; nowAt = nowAt-&gt;ch[insarr[totprevlen-cov]]; cov -= delt; &#125; while(CNT::cov&gt;0 &amp;&amp; CNT::cov&gt;=CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;len)&#123; delt = CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;len; CNT::nowAt = CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]; CNT::cov -= delt; &#125; &#125; if(CNT::cov == 0) CNT::nowAt-&gt;cov = CNT::nowAt-&gt;len; else CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;cov = std::max(CNT::nowAt-&gt;ch[insarr[totprevlen-CNT::cov]]-&gt;cov, CNT::cov); &#125; printf("%lld\n", CNT::Count()-inslen-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀树</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2015 幻想乡战略游戏]]></title>
    <url>%2F2019%2F12%2F05%2FStrGame%2F</url>
    <content type="text"><![CDATA[给定一棵 $n$ 个结点，点有点权边有边权的树，有 $m$ 次修改，每一次修改会改变一个点的点权。每次修改之后，需要求出一个点 $v$ 使得 $\sum_i dist(i\to v)\times d_i$ 最小，其中 $dist(i\to j)$ 是两点之间的最短距离，$d_i$ 为点 $i$ 的权值。 考虑在没有修改的情况下，如何求出最优点 $v$. 可以发现，如果当前位于一个点 $u$, 它的一个儿子的子树点权和大于 $u$ 子树权值和的一半，那么最优点一定位于这个儿子的子树中。 接下来考虑修改操作，对于每一个点 $i$ 维护 $d_i$ 代表 $i$ 的点权，$sd_i$ 代表 $i$ 子树 $S_i$ 的点权和，$sum_i$ 代表 $\sum_{j\in S_i}dist(j\to i)\times d_j$, $sumf_i$ 代表 $\sum_{j\in S_i}dist(j\to fa_i)\times d_j$. 如果修改的结点是 $k$, 那么只用将前后点权的变换量 $\Delta d_k$ 记录下来，接着从 $k$ 逐步跳到根，顺带修改这几个变量即可。 由于树形结构不一定平衡，考虑在点分树上进行这两个操作。修改基本思路还是一样。查询的时候如果需要将当前最优点从 $u$ 转移到 $v$ ($u,\ v$ 在点分树上有一条边直接相连)，那么记点 $w$ 为原树上 $u\to v$ 中间一个点，且原树上存在直接点接 $u\to w$ 的边。将 $d_w$ 增加 $sd_u-sd_v$, 答案加上 $dist(u\to w)\times(sd_u-sd_v)+sum_u-sumf_v$. 之后从 $w$ 开始将之前点权的修改逐步上跳更新到 $v$. 最终如果找到罗最优点 $v$, 那么还需要将答案再加上 $sum_v$. 时间复杂度为 $O(M\log^2 N)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)5e5+5;constexpr auto MAXK = 25;//infostd::vector&lt;std::pair&lt;int,long long&gt;&gt; G[MAXN];//dfstd::vector&lt;int&gt; ch[MAXN]; int root;int fa[MAXN],depth[MAXN]; long long dis[MAXN][MAXK]; std::pair&lt;int,int&gt; fach[MAXN];int siz[MAXN],mxsiz[MAXN],imp,totsiz;bool vis[MAXN];void Find(const int&amp; nowAt,const int&amp; fa=0)&#123; siz[nowAt] = 1; mxsiz[nowAt] = 0; for(const auto&amp; it : G[nowAt]) if(!vis[it.first] &amp;&amp; it.first!=fa)&#123; Find(it.first,nowAt); siz[nowAt] += siz[it.first]; mxsiz[nowAt] = std::max(mxsiz[nowAt], siz[it.first]); &#125; mxsiz[nowAt] = std::max(mxsiz[nowAt], totsiz-siz[nowAt]); if(mxsiz[nowAt] &lt; mxsiz[imp]) imp = nowAt;&#125;void Calc(const int&amp; nowAt,const long long dist,const int&amp; depth_cent, const int&amp; fa = 0)&#123; dis[nowAt][depth_cent] = dist; for(const auto&amp; it : G[nowAt]) if(!vis[it.first] &amp;&amp; it.first!=fa) Calc(it.first, dist+it.second, depth_cent, nowAt);&#125;void Dfs(const int nowAt)&#123; vis[nowAt] = true; int local_totsiz = totsiz; Calc(nowAt,0LL,depth[nowAt]); for(const auto&amp; it : G[nowAt]) if(!vis[it.first])&#123; if(siz[it.first] &gt; siz[nowAt]) totsiz = local_totsiz - siz[nowAt]; else totsiz = siz[it.first]; imp = 0; Find(it.first); depth[imp] = depth[nowAt] + 1; fa[imp] = nowAt; fach[imp] = it; ch[nowAt].push_back(imp); Dfs(imp); &#125;&#125;//Mainlong long ansval;long long sumd[MAXN],d[MAXN],sumdisd[MAXN],sumfadisd[MAXN];void Apply(const int&amp; targ, const long long&amp; val)&#123; int nowAt = targ; d[targ] += val; while(depth[nowAt] &gt; 0)&#123; sumd[nowAt] += val; sumdisd[nowAt] += val*dis[targ][depth[nowAt]]; if(depth[nowAt] == 1) sumfadisd[nowAt] = sumdisd[nowAt]; else sumfadisd[nowAt] += val*dis[targ][depth[nowAt]-1]; nowAt = fa[nowAt]; &#125;&#125;void Transport(const int&amp; targ,const long long&amp; val,const int&amp; stLv)&#123; int nowAt = targ; d[targ] += val; while(depth[nowAt] &gt;= stLv)&#123; sumd[nowAt] += val; sumdisd[nowAt] += val*dis[targ][depth[nowAt]]; if(depth[nowAt] == 1) sumfadisd[nowAt] = sumdisd[nowAt]; else sumfadisd[nowAt] += val*dis[targ][depth[nowAt]-1]; nowAt = fa[nowAt]; &#125;&#125;void Findans(const int&amp; nowAt = root)&#123; int nxt = -1; for(const auto&amp; it : ch[nowAt]) if((sumd[it]&lt;&lt;1) &gt; sumd[nowAt])&#123; nxt = it; break; &#125; long long delt; long long ansdelt; if(nxt != -1)&#123; delt = sumd[nowAt] - sumd[nxt]; ansdelt = sumdisd[nowAt] - sumfadisd[nxt] + fach[nxt].second*delt; ansval += ansdelt; Transport(fach[nxt].first,delt,depth[nxt]); Findans(nxt); Transport(fach[nxt].first,-delt,depth[nxt]); &#125; else ansval += sumdisd[nowAt];&#125;signed main(void)&#123; int totVertex,totOptn,fr,to,dis,targ; long long val; scanf("%d%d", &amp;totVertex,&amp;totOptn); for(int i=1;i&lt;totVertex;i++)&#123; scanf("%d%d%d", &amp;fr,&amp;to,&amp;dis); G[fr].push_back(std::make_pair(to,dis)); G[to].push_back(std::make_pair(fr,dis)); &#125; totsiz = totVertex; mxsiz[imp = 0] = INT_MAX; Find(1); depth[root=imp] = 1; Dfs(imp); while(totOptn--)&#123; scanf("%d%lld", &amp;targ,&amp;val); Apply(targ,val); ansval = 0; Findans(); printf("%lld\n", ansval); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2017 树状数组]]></title>
    <url>%2F2019%2F12%2F02%2Fbitar%2F</url>
    <content type="text"><![CDATA[给定一个长度为 $n$ 的数组 $A$, 初始值都是 $0$, 接下来进行 $m$ 次操作，操作有两种： 将 $A_x$ 变成 $A_x+1\mod2$ 询问 $\sum_{i=l}^r A_i\mod2$ 当时非常 young 的可怜通过树状数组求解这道题目，但是非常 simple 的她写出了位置变化方向相反的算法： 123456789101112131415161718192021222324function ADD(x) while x&gt;0 do A_x := (A_x+1) mod 2 x := x-lowbit(x) end whileend functionfunction FIND(x) if x==0 then return 0 end if ans := 0 while x&lt;=n do ans := (ans+A_x) mod 2 x := x+lowbit(x) end while return ansend functionfunction QUERY(l,r) ansl := FIND(l-1) ansr := FIND(r) return (ansr-ansl+2) mod 2end function 对于每一个操作 在区间 $[l,r]$ 中等概率选择一个 $x$ 并执行 ADD(x). 询问执行 QUERY(l,r) 得到正确结果的概率. 可以发现按照如上算法求出的是后缀和，因此 QUERY(l,r) 得到的结果其实是 \sum_{i=l-1}^{r-1}A_iQUERY(l,r) 得到正确结果的概率就是 $A_{l-1}=A_r$ 的概率。 如果执行一次 ADD(x) 其中 $x$ 在 $[l,r]$ 中等概率随机，那么对于 $l_0r$ 的区间询问得到正确结果的概率没有任何变化，如果区间有一个端点在 $[l,r]$ 中，另一个不在，那么得到有 $\frac 1{r-l+1}$ 的概率得到错误答案，如果区间两个端点都在 $[l,r]$ 中，那么得到错误答案的概率就是 $\frac 2{r-l+1}$. 开一个树状数组套线段树维护一下每一个可能的询问区间的答案即可。 注意到在 FIND(x) 函数中，特判了 $x=0$ 的情况，这时 QUERY(x) 得到的就是一个后缀和 \sum_{i=r}^nA_i它得到正确答案的概率就是前缀和等于后缀和的概率，单独开一个线段树维护即可。 时空复杂度 $O(M\log^2N)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;constexpr auto MOD = 998244353LL;constexpr auto MAXN = 500000;constexpr auto MAXM = 42800000;int Mark(const int&amp; a,const int&amp; val)&#123; return (int)((long long)((((long long)a*val&lt;&lt;1)+1LL-a-val)%MOD+MOD) % MOD);&#125;int range,nxtTr,nxtAr;//SegmentTreestruct arNode&#123; int mark; int lft,rgt; arNode()&#123; mark = 1; lft = rgt = -1; &#125; arNode&amp; Mark(const int&amp; val)&#123; mark = ((long long)(((long long)mark*val&lt;&lt;1)+1LL-val-mark)%MOD+MOD) % MOD; return *this; &#125;&#125;ar[MAXM]; int arRoot = -1;struct trNode&#123; int ar; int lft,rgt; trNode()&#123; ar = -1; lft = rgt = -1; &#125;&#125;tr[MAXN]; int trRoot = -1;void Add(const int&amp; fr,const int&amp; to,const int&amp; xfr,const int&amp; xto,const int&amp; val,int&amp; nowAt,const int nfr,const int nto);void Add(const int&amp; fr,const int&amp; to,const int&amp; val, int&amp; nowAt, const int nfr,const int nto);void Add(const int&amp; yfr,const int&amp; yto,const int&amp; xfr,const int&amp; xto,const int&amp; val);void Add(const int&amp; fr,const int&amp; to,const int&amp; val);void Query(const int&amp; ytarg,const int&amp; xtarg,const int&amp; nowAt,const int nyfr,const int nyto);void Query(const int&amp; targ,const int&amp; nowAt,const int nfr,const int nto);int Query(const int&amp; ytarg,const int&amp; xtarg);int Query(const int&amp; targ);void /*tr*/Add(const int&amp; fr,const int&amp; to,const int&amp; xfr,const int&amp; xto,const int&amp; val,int&amp; nowAt,const int nfr,const int nto)&#123; if(nfr&gt;nto || to&lt;nfr || nto&lt;fr) return; if(nowAt == -1) nowAt = nxtTr++; if(fr&lt;=nfr &amp;&amp; nto&lt;=to) Add(xfr,xto,val,tr[nowAt].ar,0,range); else&#123; Add(fr,to,xfr,xto,val,tr[nowAt].lft,nfr,nfr+nto&gt;&gt;1); Add(fr,to,xfr,xto,val,tr[nowAt].rgt,1+(nfr+nto&gt;&gt;1),nto); &#125;&#125;void /*ar*/Add(const int&amp; fr,const int&amp; to,const int&amp; val, int&amp; nowAt, const int nfr,const int nto)&#123; if(nfr&gt;nto || to&lt;nfr || nto&lt;fr) return; if(nowAt == -1) nowAt = nxtAr++; if(fr&lt;=nfr &amp;&amp; nto&lt;=to) ar[nowAt].Mark(val); else&#123; Add(fr,to,val,ar[nowAt].lft,nfr,nfr+nto&gt;&gt;1); Add(fr,to,val,ar[nowAt].rgt,1+(nfr+nto&gt;&gt;1),nto); &#125;&#125;void Add(const int&amp; yfr,const int&amp; yto,const int&amp; xfr,const int&amp; xto,const int&amp; val)&#123; Add(yfr,yto,xfr,xto,val,trRoot,0,range);&#125;void Add(const int&amp; fr,const int&amp; to,const int&amp; val)&#123; Add(fr,to,val,arRoot,0,range);&#125;int anstr,ansar;void Query(const int&amp; ytarg,const int&amp; xtarg,const int&amp; nowAt,const int nfr,const int nto)&#123; if(nowAt==-1 || ytarg&lt;nfr || nto&lt;ytarg) return; if(nfr&lt;=ytarg &amp;&amp; ytarg&lt;=nto)&#123; ansar = 1; Query(xtarg,tr[nowAt].ar,0,range); anstr = Mark(anstr, ansar); &#125; Query(ytarg,xtarg,tr[nowAt].lft,nfr,nfr+nto&gt;&gt;1); Query(ytarg,xtarg,tr[nowAt].rgt,1+(nfr+nto&gt;&gt;1),nto);&#125;void Query(const int&amp; targ,const int&amp; nowAt,const int nfr,const int nto)&#123; if(nowAt==-1 || targ&lt;nfr || nto&lt;targ) return; if(nfr&lt;=targ &amp;&amp; targ&lt;=nto) ansar = Mark(ansar, ar[nowAt].mark); Query(targ,ar[nowAt].lft,nfr,nfr+nto&gt;&gt;1); Query(targ,ar[nowAt].rgt,1+(nfr+nto&gt;&gt;1),nto);&#125;int Query(const int&amp; ytarg,const int&amp; xtarg)&#123; anstr = 1; Query(ytarg,xtarg,trRoot,0,range); return anstr;&#125;int Query(const int&amp; targ)&#123; ansar = 1; Query(targ,arRoot,0,range); return ansar;&#125;namespace _Temp&#123; long long Pow(long long val,long long pows)&#123; long long ans = 1LL; for(;pows;pows&gt;&gt;=1,(val*=val)%=MOD) if(pows &amp; 1) (ans *= val) %= MOD; return ans; &#125;&#125;; using namespace _Temp;signed main(void)&#123; int totNums,totQuery,fr,to,opt,targ; long long p,p1,p2; scanf("%d%d", &amp;totNums,&amp;totQuery); range = totNums; while(totQuery--)&#123; scanf("%d%d%d", &amp;opt,&amp;fr,&amp;to); switch(opt)&#123; case 1: p = _Temp::Pow(to-fr+1,MOD-2); p1 = (1LL-p+MOD)%MOD; p2 = ((1LL-(p&lt;&lt;1))%MOD+MOD)%MOD; Add(0,fr-1,fr,to,(int)p1); Add(fr,to,to+1,totNums,(int)p1); Add(fr,to,fr,to,(int)p2); Add(fr,to,(int)p); Add(0,fr-1,0); Add(to+1,totNums,0); break; case 2: --fr; if(fr &lt;= 0) printf("%d\n", Query(to)); else printf("%d\n", Query(fr,to)); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AH2017/HNOI2017 礼物]]></title>
    <url>%2F2019%2F12%2F02%2Fgift%2F</url>
    <content type="text"><![CDATA[给定两个顺序写有 $n$ 个数字的环 $A$ 和 $B$ ，环上每一个数字都不大于 $m$. 可以将其中一个环上每一个数增加一个非负整数 $x$, 两个环都可以旋转但不能翻转。将环上的数字对齐之后，求出最小的 \sum_{i=1}^n(a_i-b_i)^2 首先不难发现 $A$ 中每一个数增加 $x$ 和 $B$ 中每一个数减去 $x$ 是等价的，所以可以转换为将 $A$ 中每一个数加上一个整数 $x$, 那么 \sum_{i=1}^n(a_i+x-b_i)^2=\sum_{i=1}^na_i^2+b_i^2+2a_ix-2b_ix+x^2-2a_ib_i枚举 $x$ 可以确定最小的 $\sum_{i=1}^na_i^2+b_i^2+2a_ix-2b_ix+x^2$, 考虑让 $T=\sum_{i=1}^na_ib_i$ 尽可能大。如果将 $A$ 翻转然后倍长，那么 $A$ 和 $B$ 卷积的 $n$ 至 $2n$ 项对应着将 $B$ 旋转某一个角度 $c$ 的 $T_c$. 在这些位置中找到一个最大的即可。 时间复杂度为 $O(N\log N+NM)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define sqr(t) ((t)*(t))constexpr auto MAXN = 400000;namespace NTT&#123; constexpr auto MOD = 998244353LL; constexpr auto g = 3LL; template&lt;typename ansType,typename powsType&gt; inline ansType Pow(ansType a,powsType b,const ansType&amp; MOD = MOD)&#123; ansType ans = 1; for(;b;b&gt;&gt;=1,(a*=a)%=MOD) if(b &amp; 1) (ans *= a) %= MOD; return ans; &#125; template&lt;typename T&gt; inline T Module(T a,const T&amp; b)&#123; a += b; if(a &gt;= MOD) a -= MOD; return a; &#125; int r[MAXN]; void NTT(long long* A,const int&amp; totLevel, const short &amp;type)&#123; int totNums = 1&lt;&lt;totLevel; for(int i=0;i&lt;totNums;i++) if(i &lt; r[i]) std::swap(A[i], A[r[i]]); long long temp,gn,omega; for(int nowLevel=0;nowLevel&lt;totLevel;nowLevel++)&#123; gn = Pow(g, (MOD-1)/(1LL&lt;&lt;nowLevel+1)); if(type == -1) gn = Pow(gn, MOD-2); for(int nowBlk=0;nowBlk&lt;totNums;nowBlk+=1&lt;&lt;nowLevel+1)&#123; omega = 1; for(int i=0;i&lt;(1&lt;&lt;nowLevel);i++)&#123; temp = omega*A[nowBlk+i+(1&lt;&lt;nowLevel)] % MOD; A[nowBlk+i+(1&lt;&lt;nowLevel)] = Module(A[nowBlk+i], MOD-temp); A[nowBlk+i] = Module(A[nowBlk+i], temp); (omega *= gn) %= MOD; &#125; &#125; &#125; if(type == -1)&#123; temp = Pow((long long)totNums,MOD-2); for(int i=0;i&lt;totNums;i++) (A[i] *= temp) %= MOD; &#125; &#125; void Mult(long long* X,long long* Y,const int&amp; totLevel)&#123; static long long cX[MAXN], cY[MAXN]; int totNums = 1&lt;&lt;totLevel; memset(cX,0,sizeof(cX)); memset(cY,0,sizeof(cY)); *r = 0; for(int i=1;i&lt;=totNums;i++) r[i] = (r[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;totLevel-1); for(int i=0;i&lt;(totNums&gt;&gt;1);i++)&#123; cX[i] = X[i]; cY[i] = Y[i]; &#125; NTT(cX, totLevel, 1); NTT(cY, totLevel, 1); for(int i=0;i&lt;totNums;i++) (cX[i] *= cY[i]) %= MOD; NTT(cX, totLevel, -1); for(int i=0;i&lt;totNums;i++) X[i] = cX[i]; &#125;&#125;; using namespace NTT;long long A[MAXN],B[MAXN];signed main(void)&#123; int totNums,maxLight; scanf("%d%d", &amp;totNums,&amp;maxLight); for(int i=0;i&lt;totNums;i++) scanf("%lld", A+i); for(int i=0;i&lt;totNums;i++) scanf("%lld", B+i); long long tot=0,min=INT64_MAX,sum; for(int i=0;i&lt;totNums;i++) tot += sqr(A[i]); for(int i=0;i&lt;totNums;i++) tot += sqr(B[i]); for(int t=-maxLight-1;t&lt;=maxLight;++t)&#123; sum = 0; for(int i=0;i&lt;totNums;i++) sum += ((A[i]-B[i])*t&lt;&lt;1) + sqr(t); min = std::min(min, sum); &#125; tot += min; int lv = 0; for(int i=0;(i&lt;&lt;1)&lt;totNums;i++) std::swap(A[i], A[totNums-i-1]); for(int i=0;i&lt;totNums;i++) A[i+totNums] = A[i]; while((1&lt;&lt;lv) &lt; (totNums&lt;&lt;2)) ++lv; Mult(A,B,lv); long long max = INT64_MIN; for(int i=0;i&lt;totNums;i++) max = std::max(max, A[i+totNums]); tot -= max&lt;&lt;1; printf("%lld\n", tot); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WC2014 紫荆花之恋]]></title>
    <url>%2F2019%2F11%2F27%2FHongKong%2F</url>
    <content type="text"><![CDATA[有一颗树每一个时刻都会长出一个权值为 $r_i$ 的叶子结点，对于每一个时刻询问 \sum_{i\not=j}[dist(i\to j)\leq r_i+r_j]强制在线。 可以发现，如果新加进一个点 $k$, 那么对于 $k$ 的一个祖先结点 $u$, 对答案的贡献就是所有满足条件但又不在 $u$ 同一个子树内的结点点对 dist(a\to u)+dist(k\to u)\leq r_a+r_k也就是 dist(a\to u)-r_a\leq r_k-dist(k\to u)查询完之后将 $dist(k\to u)-r_k$ 放在一个 $u$ 子树代表的平衡树中维护。 由于树不一定平衡，所以需要像替罪羊树那样在达到一定不平衡程度之后将一个子树重构，这一步过程可以用点分治完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238#include&lt;bits/stdc++.h&gt;namespace FastIO&#123; template&lt;typename T&gt; inline T Read(void) &#123; T x = 0; static char ch = 0; static bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = getchar(); &#125; return x = sign ? -x : x; &#125; inline int Read(void)&#123; return Read&lt;int&gt;(); &#125; template&lt;typename T&gt; inline void WriteLine(T x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) &#123; putchar(stk[top--] + '0'); &#125; putchar('\n'); &#125;&#125;; using namespace FastIO;namespace ScapegoatBST&#123; constexpr float alpha = 0.8; template&lt;typename type&gt; class Set&#123; private: struct Node&#123; type val; size_t cnt, siz; Node *lft,*rgt; Node()&#123; lft = rgt = nullptr; &#125; Node(const type&amp; ival) : val(ival) &#123; cnt = siz = 1; lft = rgt = nullptr; &#125; ~Node()&#123; if(lft != nullptr) delete lft; if(rgt != nullptr) delete rgt; &#125; bool Balance(void)&#123; if(lft==nullptr || rgt==nullptr) if(lft==nullptr &amp;&amp; rgt==nullptr) return true; else if(lft == nullptr) return rgt-&gt;siz &lt; (float)siz*alpha; else return lft-&gt;siz &lt; (float)siz*alpha; else return std::max(lft-&gt;siz, rgt-&gt;siz) &lt; (float)siz*alpha; &#125; Node&amp; Update(void)&#123; siz = cnt; if(lft != nullptr) siz += lft-&gt;siz; if(rgt != nullptr) siz += rgt-&gt;siz; return *this; &#125; &#125;*root; //Rebuild std::vector&lt;Node*&gt; arr; void Dfs(Node* nowAt)&#123; if(nowAt-&gt;lft != nullptr) Dfs(nowAt-&gt;lft); arr.push_back(nowAt); if(nowAt-&gt;rgt != nullptr) Dfs(nowAt-&gt;rgt); &#125; Node* Build(const size_t&amp; fr,const size_t&amp; to)&#123; if(fr &gt;= to) return nullptr; size_t mid = (fr+to)&gt;&gt;1; Node* ret = arr[mid]; ret-&gt;lft = Build(fr,mid); ret-&gt;rgt = Build(mid+1,to); ret-&gt;Update(); return ret; &#125; void Rebuild(Node*&amp; rt)&#123; &#123; std::vector&lt;Node*&gt; T; std::swap(arr,T); &#125; Dfs(rt); rt = Build(0,arr.size()); &#125; void Insert(const type&amp; val,Node*&amp; nowAt)&#123; if(nowAt == nullptr)&#123; nowAt = new Node(val); return; &#125; else if(nowAt-&gt;val == val)&#123; ++nowAt-&gt;cnt; ++nowAt-&gt;siz; return; &#125; else &#123; ++nowAt-&gt;siz; Insert(val,(val&gt;nowAt-&gt;val ? nowAt-&gt;rgt : nowAt-&gt;lft)); nowAt-&gt;Update(); &#125; &#125; bool Check(const type&amp; val,Node*&amp; nowAt)&#123; if(nowAt==nullptr || nowAt-&gt;val==val) return false; if(!nowAt-&gt;Balance())&#123; Rebuild(nowAt); return true; &#125; else if(nowAt-&gt;val&lt;val) return Check(val,nowAt-&gt;rgt); else return Check(val,nowAt-&gt;lft); &#125; public: Set()&#123; root = nullptr; &#125; ~Set()&#123; if(root != nullptr) delete root; &#125; bool Empty(void)&#123; return root == nullptr; &#125; size_t&amp; Size(void)&#123; return root==nullptr ? 0 : root-&gt;siz; &#125; Set&amp; Destroy(void)&#123; if(root != nullptr) &#123; delete root; root = nullptr; &#125; return *this; &#125; Set&amp; Insert(const type&amp; val)&#123; Insert(val,root); Check(val,root); return *this; &#125; size_t CountLower(const type&amp; val) const &#123; size_t ans = 0; Node* nowAt = root; while(nowAt != nullptr)&#123; if(nowAt-&gt;val &lt;= val)&#123; ans += nowAt-&gt;cnt; if(nowAt-&gt;lft != nullptr) ans += nowAt-&gt;lft-&gt;siz; nowAt = nowAt-&gt;rgt; &#125; else nowAt = nowAt-&gt;lft; &#125; return ans; &#125; &#125;;&#125;; using namespace ScapegoatBST;constexpr auto MAXN = 100005;constexpr auto MOD = (long long)1e9;constexpr float Alpha = 0.82;std::vector&lt;std::pair&lt;int,int&gt;&gt; G[MAXN];//dfstd::vector&lt;int&gt; ch[MAXN];Set&lt;int&gt; S[MAXN], Stofa[MAXN];int depth[MAXN],siz[MAXN],fa[MAXN],chid[MAXN],mxsiz[MAXN];int dist[MAXN][70],rval[MAXN];//Refreshint totrefvertex,ref_siz[MAXN],ref_mxsiz[MAXN],imp;bool vis[MAXN];void Find(const int&amp; nowAt,const int&amp; fa = 0)&#123; ref_siz[nowAt] = 1; ref_mxsiz[nowAt] = 0; for(const auto&amp; it : G[nowAt]) if(!vis[it.first] &amp;&amp; it.first!=fa)&#123; Find(it.first, nowAt); ref_siz[nowAt] += ref_siz[it.first]; ref_mxsiz[nowAt] = std::max(ref_mxsiz[nowAt], ref_siz[it.first]); &#125; ref_mxsiz[nowAt] = std::max(ref_mxsiz[nowAt], totrefvertex-ref_siz[nowAt]); if(ref_mxsiz[nowAt] &lt; ref_mxsiz[imp]) imp = nowAt;&#125;void Calc(const int&amp; nowAt, const int len, const int&amp; cent, const int&amp; fa=0)&#123; dist[nowAt][depth[cent]] = len; S[cent].Insert(len-rval[nowAt]); if(::fa[cent] &gt; 0) Stofa[cent].Insert(dist[nowAt][depth[cent]-1]-rval[nowAt]); for(const auto&amp; it : G[nowAt]) if(it.first!=fa &amp;&amp; !vis[it.first]) Calc(it.first,len+it.second,cent,nowAt);&#125;void Dfs(const int nowAt)&#123; vis[nowAt] = true; siz[nowAt] = 1; mxsiz[nowAt] = 0; Calc(nowAt,0LL,nowAt); int totsiz = totrefvertex,chthis; for(const auto&amp; it : G[nowAt]) if(!vis[it.first])&#123; ref_mxsiz[imp = 0] = INT_MAX; if(ref_siz[it.first] &gt; ref_siz[nowAt]) totrefvertex = totsiz-ref_siz[nowAt]; else totrefvertex = ref_siz[it.first]; Find(it.first,nowAt); chthis = imp; depth[chthis] = depth[nowAt] + 1; chid[chthis] = ch[nowAt].size(); ch[nowAt].push_back(chthis); fa[chthis] = nowAt; Dfs(chthis); siz[nowAt] += siz[chthis]; if(siz[chthis] &gt; siz[mxsiz[nowAt]]) mxsiz[nowAt] = chthis; &#125; //assert(totsiz == siz[nowAt]);&#125;void MarkTarg(const int&amp; nowAt,const int&amp; fa)&#123; for(const auto&amp; it : ch[nowAt]) if(it!=fa) MarkTarg(it, nowAt); S[nowAt].Destroy(); Stofa[nowAt].Destroy(); ch[nowAt].clear(); vis[nowAt] = false;&#125;void Rebuild(const int targ)&#123; totrefvertex = siz[targ]; MarkTarg(targ,fa[targ]); ref_mxsiz[imp = 0] = INT_MAX; Find(targ); depth[imp] = depth[targ]; if(fa[targ] &gt; 0)&#123; chid[imp] = chid[targ]; ch[fa[targ]][chid[imp]] = imp; &#125; fa[imp] = fa[targ]; Dfs(imp);&#125;//Mainlong long ans;signed main(void)&#123; int last_ans=0,faid, falen,rthis; int test_ID,totVertex; test_ID = Read(); totVertex = Read(); if(totVertex &lt;= 0) return 0; faid = Read(); falen = Read(); rthis = Read(); //init memset(vis,true,sizeof(vis)); depth[1] = 1; siz[1] = 1; S[1].Insert(-rthis); rval[1] = rthis; puts("0"); //Solve int cntRebuild = 0,cntRebuildSize=0; int nowAt,rebuildTarg; long long len,nxtlen; for(int nowID=2;nowID&lt;=totVertex;++nowID)&#123; faid = Read() ^ last_ans; falen = Read(); rthis = Read(); //assert(faid&lt;nowID &amp;&amp; faid&gt;0); G[faid].push_back(std::make_pair(nowID,falen)); G[nowID].push_back(std::make_pair(faid,falen)); rval[nowID] = rthis; fa[nowID] = faid; chid[nowID] = ch[faid].size(); ch[faid].push_back(nowID); depth[nowID] = depth[faid] + 1; for(int i=depth[faid];i&gt;0;i--) dist[nowID][i] = dist[faid][i] + falen; nowAt = nowID; rebuildTarg = 0; nxtlen=0; for(int i=depth[nowID];i&gt;0;--i)&#123; len = nxtlen; ans += S[nowAt].CountLower(rthis-len); S[nowAt].Insert(len-rthis); if(fa[nowAt] &gt; 0)&#123; nxtlen = dist[nowID][i-1]; ans -= Stofa[nowAt].CountLower(rthis-nxtlen); Stofa[nowAt].Insert(nxtlen-rthis); &#125; if(++siz[nowAt] &gt; siz[mxsiz[fa[nowAt]]]) mxsiz[fa[nowAt]] = nowAt; if((float)siz[nowAt]*Alpha &lt;= (float)siz[mxsiz[nowAt]]) rebuildTarg = nowAt; nowAt = fa[nowAt]; &#125; WriteLine(ans); last_ans = ans%MOD; if(rebuildTarg &gt; 0) Rebuild(rebuildTarg); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AH2017/HNOI2017 单旋]]></title>
    <url>%2F2019%2F11%2F21%2Fspaly%2F</url>
    <content type="text"><![CDATA[维护一个单旋 Splay, 需要支持 $m$ 个操作，每个为插入，单旋最小值至根，单旋最大值至根，单旋删除最小值，单旋删除最大值中的一种。每次操作后都需要统计这次操作的时间开销，也就是目标节点的深度。 开一颗权值线段树，维护节点的权值对应的深度。 对于插入操作，插入的节点是他权值的前驱深度和后继权值深度的最大值$+1$. 对于删除最小值操作，记当前最小值为 $t$, 最小值在 Splay 上的父亲节点权值为 $v$, 那么对于所有权值属于 $(t,v)$ 的节点，它们的深度不会发生变化，最小值深度变为 $1$, 其他节点的深度会全部增大 $1$. 其余的操作同理，需要模拟树的形态，记录每一个节点的左右儿子和父亲。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;int ReadOpt(void)&#123; char in; do in = getchar(); while(!('1'&lt;=in &amp;&amp; in&lt;='5')); return in-'0';&#125;constexpr auto MAXM = (int)1e5+5;//Segment Treeint range = 1e9+3;struct Node&#123; int depth,mark; Node *lft,*rgt; Node()&#123; lft = rgt = nullptr; depth = -1; mark = 0; &#125; Node(const int&amp; idepth) : depth(idepth) &#123; lft = rgt = nullptr; mark = 0; &#125; Node&amp; Mark(const int&amp; delta)&#123; if(depth != -1) depth += delta; mark += delta; return *this; &#125; Node&amp; Push_Down(void)&#123; if(mark)&#123; if(lft != nullptr) lft-&gt;Mark(mark); if(rgt != nullptr) rgt-&gt;Mark(mark); mark = 0; &#125; return *this; &#125;&#125;*root = nullptr;void Insert(const int&amp; val,const int&amp; depth, Node*&amp; nowAt=root,const int fr=1,const int to=range)&#123; if(fr&gt;val || to&lt;val) return; if(nowAt == nullptr) nowAt = new Node(); nowAt-&gt;Push_Down(); if(fr==val &amp;&amp; to==val) nowAt-&gt;depth = depth; else&#123; Insert(val,depth,nowAt-&gt;lft,fr,fr+to&gt;&gt;1); Insert(val,depth,nowAt-&gt;rgt,1+(fr+to&gt;&gt;1),to); &#125;&#125;int Query(const int&amp; val, Node* nowAt=root,const int fr=1,const int to=range)&#123; if(nowAt==nullptr || fr&gt;val || to&lt;val) return -1; nowAt-&gt;Push_Down(); if(fr==val &amp;&amp; to==val) return nowAt-&gt;depth; else return std::max(Query(val,nowAt-&gt;lft,fr,fr+to&gt;&gt;1), Query(val,nowAt-&gt;rgt,1+(fr+to&gt;&gt;1),to)); &#125;void Mark(const int&amp; fr,const int&amp; to, const int&amp; val, Node* nowAt=root,const int nfr=1,const int nto=range)&#123; if(nowAt==nullptr || to&lt;nfr || nto&lt;fr) return; nowAt-&gt;Push_Down(); if(fr&lt;=nfr &amp;&amp; nto&lt;=to) nowAt-&gt;Mark(val); else&#123; Mark(fr,to,val,nowAt-&gt;lft, nfr,nfr+nto&gt;&gt;1); Mark(fr,to,val,nowAt-&gt;rgt,1+(nfr+nto&gt;&gt;1),nto); &#125;&#125;//Spalystd::set&lt;int&gt; S; std::map&lt;int,int&gt; faval,lft,rgt; int rt;void SpalyMin(void)&#123; int min = *S.begin(); if(min == rt) return; Mark(0,range,1); Mark(min, faval[min]-1,-1); Insert(min,1); lft[faval[min]] = rgt[min]; faval[rgt[min]] = faval[min]; rgt[min] = rt; faval[rt] = min; rt = min; faval[min] = 0;&#125;void SpalyMax(void)&#123; int max = *(--S.end()); if(max == rt) return; Mark(0,range,1); Mark(faval[max]+1,max,-1); Insert(max,1); rgt[faval[max]] = lft[max]; faval[lft[max]] = faval[max]; lft[max] = rt; faval[rt] = max; rt = max; faval[max] = 0;&#125;signed main(void)&#123; int totOptn,opt,dep,val,d1,d2; scanf("%d", &amp;totOptn); std::set&lt;int&gt;::iterator itor; while(totOptn--) switch(ReadOpt())&#123; case 1: scanf("%d", &amp;val); d1 = d2 = -1; if(S.empty())&#123; dep = 1; rgt[val] = lft[val] = faval[val] = 0; rt = val; &#125; else &#123; itor = S.lower_bound(val); if(itor != S.end()) d1 = Query(*itor); if(itor-- != S.begin()) d2 = Query(*itor); itor = S.lower_bound(val); if(d1 &lt; d2)&#123; dep = d2 + 1; faval[val] = *(--itor); rgt[*itor] = val; &#125; else &#123; dep = d1 + 1; faval[val] = *itor; lft[*itor] = val; &#125; &#125; Insert(val,dep); S.insert(val); printf("%d\n", dep); break; case 2: printf("%d\n", Query(*S.begin())); SpalyMin(); break; case 3: printf("%d\n", Query(*(--S.end()))); SpalyMax(); break; case 4: printf("%d\n", Query(val=*S.begin())); SpalyMin(); Mark(0,range,-1); rt = rgt[*S.begin()]; faval[val] = 0; lft[val] = 0; rgt[val] = 0; S.erase(S.begin()); break; case 5: printf("%d\n", Query(val=*(--S.end()))); SpalyMax(); Mark(0,range,-1); rt = lft[*(--S.end())]; faval[val] = 0; lft[val] = 0; rgt[val] = 0; S.erase(--S.end()); break; default: assert(false); break; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>模拟</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2017 仙人掌]]></title>
    <url>%2F2019%2F11%2F20%2Fcactus%2F</url>
    <content type="text"><![CDATA[给定一个 $n$ 个点，$m$ 条边的无自环无重边无向连通图，需要向其中添加一些边，使得这个联通图是一颗仙人掌。需要求出合法的加边方案数，两种方案被认为是不同的，当且仅当一个方案中存在一条另一个方案中没有的边。 首先考虑一些特殊的情况。 如果给定的联通图不是仙人掌，那么答案显然是 $0$. 考虑有一个节点 $u$ 有 $t$ 个儿子，在仅考虑这个点和它的儿子的情况下，方案数为 $g_t$. 考虑新加入一个儿子，他可以与某一个其他的儿子连边，也可以不连，易得 g_i=g_{i-1}+(i-1)g_{i-2}接下来考虑将情况推广到树上，如果一个节点 $u$ 的儿子集合为 $S_u$, 如果 $u$ 是一个非根节点，那么它的儿子之间可以互相连边，也可以将儿子与某一个祖先相连，用乘法原理分别统计每一个儿子的贡献，再乘上新加的边的方案数 f_u=g_{|S_u|+1}\Pi_{k\in S_u}f_k这里将某一个儿子和祖先相连边的操作实际上连接的不一定是 $u$ 的直接儿子，也有可能是 $u$ 这个儿子子树中某个一直执行此操作到达 $u$ 的后代。 如果 $u$ 是根节点，那么就不能执行这种操作。 f_u=g_{|S_i|}\Pi_{k\in S_u}f_k如果原图是一颗仙人掌，那么所有环上的边就不能再与加入的边构成新的环了，将这些边去掉即可，此时图会变成许多个连通块，每一个连通块都是一棵树，根据之前的方法分别求出答案，相乘即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;class Edgeset&#123;private: std::set&lt;std::pair&lt;int,int&gt;&gt; st;public: Edgeset&amp; Cls(void)&#123; std::set&lt;std::pair&lt;int,int&gt;&gt; T; std::swap(T, st); return *this; &#125; Edgeset&amp; Attend(const int&amp; fr,const int&amp; to)&#123; st.insert(std::make_pair(std::min(fr,to), std::max(fr,to))); return *this; &#125; bool Count(const int&amp; fr,const int&amp; to)&#123; return st.count(std::make_pair(std::min(fr,to), std::max(fr,to))); &#125;&#125;abd;constexpr auto MOD = 998244353LL;constexpr auto MAXN = (int)5e5+50;constexpr auto MAXM = (int)1e6+5;std::vector&lt;int&gt;G[MAXN];bool vis[MAXN];//GetCircint que[MAXN],tail,queID[MAXN]; bool flag;bool Dfs(const int&amp; nowAt,const int&amp; fa = 0)&#123; vis[nowAt] = true; que[queID[nowAt] = tail++] = nowAt; for(const auto&amp; it : G[nowAt]) if(queID[it]&gt;=0 &amp;&amp; it!=fa)&#123; for(int i=queID[it]+1; i&lt;tail;i++) if(abd.Count(que[i], que[i-1])) return flag = false; else abd.Attend(que[i], que[i-1]); if(abd.Count(nowAt, it))&#123; flag = false; return false; &#125; else abd.Attend(nowAt, it); &#125; else if(!vis[it] &amp;&amp; !Dfs(it, nowAt)) return false; queID[nowAt] = -1; --tail; return true;&#125;//Dplong long g[MAXN],f[MAXN];void Dp(const int&amp; nowAt)&#123; vis[nowAt] = true; int cntch = 0; long long&amp; ret = f[nowAt]; ret = 1; for(const auto&amp; it : G[nowAt]) if(!abd.Count(nowAt,it))&#123; if(!vis[it])&#123; Dp(it); (ret *= f[it]) %= MOD; &#125; ++cntch; &#125; ret = ret*g[cntch] % MOD;&#125;signed main(void)&#123; //setup g[0] = g[1] = 1; for(int i=2;i&lt;MAXN;i++) g[i] = (g[i-1]+g[i-2]*(i-1)) % MOD; int totCases,totVertex,totEdges,fr,to; long long ans; scanf("%d", &amp;totCases); while(totCases--)&#123; scanf("%d%d", &amp;totVertex,&amp;totEdges); //init abd.Cls(); for(int i=0;i&lt;=totVertex;i++)&#123; G[i].clear(); vis[i] = false; queID[i] = -1; &#125; flag = true; tail = 0; //readin for(int i=0;i&lt;totEdges;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); G[fr].push_back(to); G[to].push_back(fr); &#125; Dfs(1); if(!flag) puts("0"); else&#123; memset(vis,false, (totVertex+1)*sizeof(bool)); ans = 1; for(int i=1;i&lt;=totVertex;i++) if(!vis[i])&#123; Dp(i); (ans *= f[i]) %= MOD; &#125; printf("%lld\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2007 捉迷藏]]></title>
    <url>%2F2019%2F11%2F19%2FHDS%2F</url>
    <content type="text"><![CDATA[给定一颗 $n$ 个节点构成的树，树上每一个节点有黑白两种颜色中的一种，需要维护这棵树使得它支持两种操作: 更改一个节点的颜色 询问两个最远黑色点的距离。 动态点分模板。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include&lt;bits/stdc++.h&gt;namespace Mickey_snow&#123; template&lt;typename T&gt; struct Priority_queue&#123; T rk1,rk2; std::priority_queue&lt;T,std::vector&lt;T&gt;,std::less&lt;T&gt;&gt; arr,del; Priority_queue&lt;T&gt;()&#123; rk1 = rk2 = -1; &#125; Priority_queue&lt;T&gt;(const std::priority_queue&lt;T,std::vector&lt;T&gt;,std::less&lt;T&gt;&gt;&amp; iarr, const std::priority_queue&lt;T,std::vector&lt;T&gt;,std::less&lt;T&gt;&gt;&amp; idel) : arr(iarr),del(idel) &#123; rk1 = rk2 = -1; &#125; bool Refresh_Value(void)&#123; bool flag = false; while(!del.empty() &amp;&amp; (arr.empty() || del.top()&gt;arr.top())) del.pop(); while(!arr.empty() &amp;&amp; !del.empty() &amp;&amp; del.top()==arr.top())&#123; arr.pop(); del.pop(); flag = true; &#125; return flag; &#125; Priority_queue&lt;T&gt;&amp; Refresh(void)&#123; Refresh_Value(); if(arr.empty())&#123; rk1 = rk2 = -1; return *this; &#125; rk1 = arr.top(); arr.pop(); Refresh_Value(); if(!arr.empty()) rk2 = arr.top(); else rk2 = -1; arr.push(rk1); return *this; &#125; T DoubleMax(void) &#123; return rk2&lt;0 ? -1 : (rk1 + rk2); &#125; T Max(void) const &#123; return rk1&lt;0 ? -1 : rk1; &#125; bool IsEmpty(void)&#123; return Refresh().arr.empty(); &#125; Priority_queue&lt;T&gt;&amp; Attend(const int&amp; val)&#123; arr.push(val); if(val &gt; rk1)&#123; rk2 = rk1; rk1 = val; &#125; else if(val &gt; rk2) rk2 = val; return *this; &#125; Priority_queue&lt;T&gt;&amp; Delete(const int&amp; val)&#123; del.push(val); return Refresh(); &#125; &#125;; template&lt;typename T&gt; void Apply(Priority_queue&lt;T&gt;&amp; targ,Priority_queue&lt;T&gt;&amp; a)&#123; int add = a.Max(); if(add &gt;= 0) targ.Attend(add).Refresh(); &#125; template&lt;typename T&gt; void Dismiss(Priority_queue&lt;T&gt;&amp; targ,Priority_queue&lt;T&gt;&amp; a)&#123; int del = a.Max(); if(del &gt;= 0) targ.Delete(del).Refresh(); &#125; template&lt;typename T&gt; void ApplyDoubleMax(Priority_queue&lt;T&gt;&amp; targ,Priority_queue&lt;T&gt;&amp; a)&#123; int max = a.DoubleMax(); if(max &gt;= 0) targ.Attend(max).Refresh(); //else Apply(targ, a); &#125; template&lt;typename T&gt; void DisDoubleMax(Priority_queue&lt;T&gt;&amp; targ,Priority_queue&lt;T&gt;&amp; a)&#123; int max = a.DoubleMax(); if(max &gt;= 0) targ.Delete(max).Refresh(); //else Dismiss(targ, a); &#125;&#125;; using namespace Mickey_snow;char ReadOpt(void)&#123; char in; do in = getchar(); while(in!='G' &amp;&amp; in!='C'); return in;&#125;constexpr auto MAXN = 100000 + 5;constexpr auto MAXM = 500000 + 5;constexpr auto MAXK = 18;std::vector&lt;int&gt; G[MAXN];Priority_queue&lt;int&gt; Glob; //Global//df _ setupint jpup[MAXN],dis[MAXN][MAXK],depth[MAXN];Priority_queue&lt;int&gt; uptofa[MAXN],chvals[MAXN];bool vis[MAXN];int siz[MAXN],maxsiz[MAXN],totSize,imp;void Find(const int&amp; nowAt, const int&amp; fa = 0)&#123; siz[nowAt] = 1; maxsiz[nowAt] = 1; for(const auto&amp; it : G[nowAt]) if(!vis[it] &amp;&amp; it!=fa)&#123; Find(it, nowAt); siz[nowAt] += siz[it]; maxsiz[nowAt] = std::max(maxsiz[nowAt], siz[it]); &#125; maxsiz[nowAt] = std::max(maxsiz[nowAt], totSize-siz[nowAt]); if(maxsiz[nowAt] &lt; maxsiz[imp]) imp = nowAt;&#125;void Calc(const int&amp; cent, const int&amp; nowAt, const int&amp; lv, const int &amp;fa = 0)&#123; uptofa[cent].Attend(dis[nowAt][lv]); for(const auto&amp; it : G[nowAt]) if(!vis[it] &amp;&amp; it!=fa) Calc(cent, it, lv, nowAt);&#125;void GetDis(const int&amp; nowAt, const int&amp; lv, const int nowDis, const int&amp; fa = 0)&#123; dis[nowAt][lv] = nowDis; for(const auto&amp; it : G[nowAt]) if(!vis[it] &amp;&amp; it!=fa) GetDis(it, lv, nowDis+1, nowAt);&#125;void Dfs(const int nowAt)&#123; vis[nowAt] = true; int mktotSiz = totSize; GetDis(nowAt, depth[nowAt], 0); if(depth[nowAt] &gt; 0) Calc(nowAt, nowAt, depth[nowAt]-1); for(const auto&amp; it : G[nowAt]) if(!vis[it])&#123; if(siz[it] &gt; siz[nowAt]) totSize = mktotSiz - siz[nowAt]; else totSize = siz[it]; *maxsiz = INT_MAX; imp = 0; Find(it); jpup[imp] = nowAt; depth[imp] = depth[nowAt] + 1; Dfs(imp); &#125;&#125;//mainenum Stat &#123; off,on &#125;;bool status[MAXN];void On(const int &amp;targ)&#123; int nowAt = targ,fa; DisDoubleMax(Glob, chvals[targ]); chvals[targ].Delete(0); ApplyDoubleMax(Glob, chvals[targ]); for(int nowLv = depth[targ]; nowLv&gt;0; nowLv--)&#123; fa = jpup[nowAt]; DisDoubleMax(Glob, chvals[fa]); Dismiss(chvals[fa], uptofa[nowAt]); uptofa[nowAt].Delete(dis[targ][nowLv-1]); Apply(chvals[fa], uptofa[nowAt]); ApplyDoubleMax(Glob, chvals[fa]); nowAt = fa; &#125;&#125;void Off(const int &amp;targ)&#123; int nowAt = targ,fa; DisDoubleMax(Glob, chvals[targ]); chvals[targ].Attend(0); ApplyDoubleMax(Glob, chvals[targ]); for(int nowLv = depth[targ]; nowLv&gt;0; nowLv--)&#123; fa = jpup[nowAt]; DisDoubleMax(Glob, chvals[fa]); Dismiss(chvals[fa], uptofa[nowAt]); uptofa[nowAt].Attend(dis[targ][nowLv-1]); Apply(chvals[fa], uptofa[nowAt]); ApplyDoubleMax(Glob, chvals[fa]); nowAt = fa; &#125;&#125;signed main(void)&#123; int totVertex,totOptn,targ,fr,to,cnt; scanf("%d", &amp;totVertex); for(int i=1;i&lt;totVertex;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); G[fr].push_back(to); G[to].push_back(fr); &#125; memset(status,false/*off*/,sizeof(status)); *maxsiz = INT_MAX; imp = 0; totSize = totVertex; Find(1); Dfs(imp); for(int i=1;i&lt;=totVertex;i++) chvals[i].Attend(0); for(int i=1;i&lt;=totVertex;i++) Apply(chvals[jpup[i]], uptofa[i]); for(int i=1;i&lt;=totVertex;i++) ApplyDoubleMax(Glob, chvals[i]); scanf("%d", &amp;totOptn); cnt = totVertex; while(totOptn--) switch(ReadOpt())&#123; case 'C': scanf("%d", &amp;targ); status[targ] ^= 1; switch(status[targ])&#123; case on: On(targ); --cnt; break; case off: Off(targ); ++cnt; break; default: assert(false); break; &#125; break; case 'G': if(cnt &lt;= 0) puts("-1"); else if(cnt == 1) puts("0"); else printf("%d\n", Glob.Max()); break; default: assert(false); break; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOI2000 邮局]]></title>
    <url>%2F2019%2F11%2F08%2FPost%2F</url>
    <content type="text"><![CDATA[在一条笔直公路旁有 $n$ 个村庄，第 $i$ 个的位置是 $p_i$, 现在要在一些位置建立总共 $k$ 个邮局(不一定要在村庄中)，需要在已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。 考虑当 $k=1$ 时，如果我们将邮局建立在位置 $p$, $p$ 位置不是一个村庄，左边的村庄数量为 $l$, 右边的村庄数量为 $r$, 如果我们将 $p$ 右移一个很小的距离 $\lim_{\Delta x\to0^+}$, 那么答案变化量为 $\Delta x(l-r)$, 左移类似。可知应该尽量往村庄多的那一边移动，最终的位置是这一段村庄的中位数。 定义 $d_{i,j}$ 代表前 $i$ 个村庄，建立 $j$ 个邮局的最小答案。那么转移方程 d_{i,j}=\min_{1\leq k\leq i}\{d_{k,j-1}+w_{k+1,i}\}这里 m=\frac{i+j}2\\ s_i=\sum_{k=1}^ip_i\\ w_{k+1,i}=\frac{j-i}2p_m-s_{m-1}+s_j-s_m-\frac{j-1}2p_m=s_{i-1}+s_j-s_m-s_{m-1}涉及到的所有除法运算都需要向下取整(下同)。 如果我们能证明 $w$ 满足四边形不等式，那么就可以得到 $d_{i,j}$ 最优取值点在 $d_{i,j-1}$ 到 $d_{i+1,j}$ 之间。 w_{i,j}+w_{i+1,j+1}\leq w_{i+1,j}+w_{i,j+1}\\ L=s_j+s_{i+1}-s_{\frac{i+j}2}-s_{\frac{i+j}2-1}+s_{j+1}+s_i-s_{\frac{i+j}2+1}-s_{\frac{i+j}2}\\ R=s_j+s_i-s_{\frac{i+j+1}2}-s_{\frac{i+j-1}2}+s_{j+1}+s_i-s_{\frac{i+j+1}2}-s_{\frac{i+j-1}2}\\ R-L=s_{\frac{i+j}2-1}+\left(s_{\frac{i+j}2}-s_\frac{i+j+1}2\right)+\left(s_j-s_\frac{i+j+1}2\right)+\left(s_\frac{i+j}2-s_\frac{i+j-1}2\right)+\left(s_\frac{i+j}2-s_\frac{i+j+1}2\right)可见，由于 $s$ 单调增，所以每个括号中都是非负的，也就是说 $L\leq R$. 12345678910111213141516171819202122232425262728293031323334353637383940414243%:include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 3001;int pos[MAXN],sum[MAXN];int Sum(const int&amp; fr,const int&amp; to)&#123; return sum[to]-sum[fr-1]; &#125;int D[MAXN][MAXN],f[MAXN][MAXN],sp[MAXN][MAXN];#define w(i,j) (sp[(i)][(j)])signed main(void)&#123; int totVill,totPost,mid; scanf("%d%d", &amp;totVill,&amp;totPost); std::for_each(pos+1,pos+1+totVill,[](auto&amp; it)&#123; scanf("%d", &amp;it); &#125;); std::sort(pos+1,pos+1+totVill); for(int i=1;i&lt;=totVill;i++) sum[i] = sum[i-1]+pos[i]; for(int fr=1;fr&lt;=totVill;fr++) for(int to=fr;to&lt;=totVill;to++)&#123; mid = (fr+to)&gt;&gt;1; sp[fr][to] = (mid-fr)*pos[mid]-Sum(fr,mid-1) + Sum(mid+1,to) - (to-mid)*pos[mid]; &#125; memset(D,0x7f,sizeof(D)); memset(D[0],0,sizeof(D[0])); for(int i=1;i&lt;=totVill;i++) D[i][1] = w(1,i); for(int post=2;post&lt;=totPost;post++)&#123; f[totVill+1][post] = totVill; for(int i=totVill;i&gt;0;i--)&#123; for(int k=f[i][post-1];k&lt;=f[i+1][post];++k) if(D[i][post] &gt; D[k][post-1]+w(k+1,i))&#123; D[i][post] = D[k][post-1]+w(k+1,i); f[i][post] = k; &#125; &#125; &#125; printf("%d\n", D[totVill][totPost]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1242B 0-1 MST]]></title>
    <url>%2F2019%2F11%2F07%2F01MST%2F</url>
    <content type="text"><![CDATA[Codeforces1242 B.0-1 MST 给定一个包含 $n$ 个点的完全图 $G$. 其中有不超过 $m$ 条边边权是 $1$, 其余的都是 $0$, 求这个图的最小生成树权值和。 如果这张图的每一条边都是告诉我们了的，我们可以仅考虑边权为 $0$ 的边，每一次从一个没有到达过的点开始沿着这些边搜索，直到原图成为一些联通块，答案就是联通块个数减去 $1$. 根据 Prim, 这个算法是正确的。 由于这是一张完全图，所以不可能有足够空间存边，考虑将边权为 $1$ 的边存下来，对于每一个点记录一个集合，里面是从这个点出发不能经过一个权为 $0$ 的边到达的点。还是像之前一样，每到达一个点枚举一下下一次去哪，搜出联通块。时间复杂度为 $O(N^2\log M)$. 其实，我们没有必要枚举出下一个点，可以一开始将所有的点全部放在一个全局集合 $S$ 中，然后每到达一个点，将其从 $S$ 中删除，假定当前的下一个点是 $c$, 那么下一步考虑的就是 $c$ 在 $S$ 中的后继。由于每个点最多到达一次，每一条权为 $1$ 的边最多不能匹配一次，如果这里用一颗平衡树维护 $S$, 总时间复杂度为 $O((N+M)\log N\log M)$. 这里 $S$ 并不需要具备平衡树的许多特性，所以可以用一个更加低级的数据结构(算法)代替，考虑记录一个数组 $nxt_i$ 代表下一个是什么，删除一个点 $i$ 的操作就变成了直接将 $nxt_i$ 加 $1$. 然后套用并查集路径压缩的思想，时间复杂度 $O((N+M)\log M\alpha(N))$. 12345678910111213141516171819202122232425262728293031323334353637383940%:include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)1e5+50;constexpr auto MAXM = (int)1e5+50;std::set&lt;int&gt; G[MAXN];int up[MAXN];int FindTop(const int&amp; nowAt)&#123; return up[nowAt]==nowAt ? nowAt : (up[nowAt]=FindTop(up[nowAt]));&#125;bool vis[MAXN];void Dfs(const int&amp; nowAt)&#123; vis[nowAt] = true; ++up[nowAt]; for(int cur=FindTop(1);cur;cur=FindTop(cur+1)) if(!vis[cur] &amp;&amp; !G[nowAt].count(cur)) Dfs(cur);&#125;signed main(void)&#123; int totVertex,totEdges,fr,to; scanf("%d%d", &amp;totVertex,&amp;totEdges); for(int i=0;i&lt;totEdges;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); G[fr].insert(to); G[to].insert(fr); &#125; for(int i=0;i&lt;=totVertex;i++) up[i] = i; int ans = -1; for(int i=1;i&lt;=totVertex;i++) if(!vis[i])&#123; ++ans; Dfs(i); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1256F Equalizing Two Strings]]></title>
    <url>%2F2019%2F11%2F06%2FEqualizing_Two_Strings%2F</url>
    <content type="text"><![CDATA[Codeforces1256 F.Equalizing Two Strings 给定两个长度均为 $n$ 的串 $s$ 和 $t$. 每一次操作可以从 $s$ 中选择一段长度为 $l$ 的连续子串，并且从 $t$ 中选择一段长度相同的连续子串，然后将他们翻转。需要判断能否通过操作使得 $s=t$. 很容易想到的是，如果 $s$ 中某个字符出现的次数与它在 $t$ 中出现的次数不相同，那么答案一定是不行。 接下来，我们考虑通过这种翻转操作，一步步将 $s$ 和 $t$ 排成字典序升序。如果某一种字符在 $s$ 中出现了不止一次，那么我们可以每一次都选择 $l=2$, 翻转两个相邻字符直到 $s$ 为升序，然后想办法让 $t$ 也升序，还是每次翻转两个相邻的字符，这两个字符在 $s$ 中选择那个出现多次的字符，这样 $s$ 没有变化。最终 $s=t$. 如果没有出现多次的字符，我们仍然可以每次将 $l$ 设置为 $2$ 来考虑。如果我们在两次翻转中选择了 $t$ 中相同的区间，那么等同于 $t$ 没有变化，$s$ 上作用了两次操作。也就是说，如果将 $s$ 和 $t$ 排成升序所用操作次数奇偶性相同，那么答案是 YES. 每一次翻转显然会改变逆序对的奇偶性，所以只用判断一下逆序对个数是否相同即可，奇偶性相同一定有解。在这种情况下，考虑 $l$ 不一定等于 $2$ 时是否无解，由于此时同一个串中不存在相同元素，因此无论取多大的 $l$, 逆序对奇偶性的变化总是同步的，因此奇偶性不同一定无解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344%:include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)2e5+50;constexpr auto MAXK = 26;char s[MAXN],t[MAXN];signed main(void)&#123; bool flag,glory; int totCases,totLen; int cnts[MAXK],cntt[MAXK]; std::cin&gt;&gt;totCases; while(totCases--)&#123; std::cin&gt;&gt;totLen&gt;&gt;s&gt;&gt;t; memset(cnts,0,sizeof(cnts)); memset(cntt,0,sizeof(cntt)); for(int i=0;i&lt;totLen;i++)&#123; ++cnts[s[i]-'a']; ++cntt[t[i]-'a']; &#125; flag = true; glory = false; for(int i=0;i&lt;MAXK;i++) if(cnts[i] != cntt[i])&#123; flag = false; break; &#125; else if(cnts[i] &gt;= 2) glory = true; if(!flag)&#123; puts("NO"); continue; &#125; if(glory)&#123; puts("YES"); continue; &#125; *cnts = *cntt = 0; for(int i=0;i&lt;totLen;i++) for(int j=i+1;j&lt;totLen;j++)&#123; if(s[i] &gt; s[j]) ++*cnts; if(t[i] &gt; t[j]) ++*cntt; &#125; if((*cnts&amp;1) == (*cntt&amp;1)) puts("YES"); else puts("NO"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF512C Fox And Dinner]]></title>
    <url>%2F2019%2F11%2F06%2FFox_And_Dinner%2F</url>
    <content type="text"><![CDATA[Codeforces512 C.Fox And Dinner 给定 $n$ 个不小于 $2$ 的整数，第 $i$ 个是 $a_i$. 需要将他们串成若干个环，每个环包含至少 $3$ 个数，且每两个相邻的数的和是一个素数。求出一种可行的方案或者判定无解。 由于这里的数都不小于 $2$, 所以两个数加起来一定是一个奇素数，也就是一个偶数和一个奇数相加的结果。 考虑二分图，将偶数放在左边，奇数放在右边，从源点 $s$ 向每一个左边点连一条容量为 $2$ 的边，从每一个右边点向汇点 $t$ 连一条容量为 $2$ 的边，点之间如果相加是一个素数，则由左边向右边连一条容量为 $1$ 的边。 在这张图上跑一边最大流，如果求出的最大流是 $n$ 那么有解，这时中间的连边如果容量变为了 $0$, 那么说明这条边链接的两个点在串中是相邻的，一遍将方案搜出来即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236%:include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 250;struct Edge&#123; int fr,to,residual; Edge()&#123;&#125; Edge(const int&amp; ifr,const int&amp; ito,const int&amp; ire) : fr(ifr),to(ito),residual(ire) &#123;&#125;&#125;; const int s=MAXN-2,t=MAXN-1;std::vector&lt;Edge&gt;edges; std::vector&lt;int&gt; G[MAXN];void AddEdge(const int&amp; fr,const int&amp; to,const int&amp; residual)&#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr,to,residual)); G[to].push_back(edges.size()); edges.push_back(Edge(to,fr,0));&#125;int depth[MAXN],cur[MAXN];bool BFS(void)&#123; memset(depth,0x7f,sizeof(depth)); std::queue&lt;int&gt; que; que.push(s); depth[s] = 0; int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(int i=0;i&lt;G[nowAt].size();i++)&#123; const auto&amp; it = edges[G[nowAt][i]]; if(depth[it.fr]+1&lt;depth[it.to] &amp;&amp; it.residual&gt;0)&#123; depth[it.to] = depth[it.fr]+1; que.push(it.to); &#125; &#125; &#125; return depth[t]&lt;1000;&#125;int Dinic(const int&amp; nowAt, int maxFlow = INT_MAX)&#123; if(nowAt==t || maxFlow&lt;=0) return maxFlow; int deltaFlow,flow=0; for(int &amp;i=cur[nowAt];i&lt;G[nowAt].size();i++)&#123; auto&amp; it = edges[G[nowAt][i]]; if(depth[it.fr]+1==depth[it.to] &amp;&amp; 0&lt;(deltaFlow=Dinic(it.to,std::min(maxFlow,it.residual))))&#123; maxFlow -= deltaFlow; flow += deltaFlow; edges[G[nowAt][i]^1].residual += deltaFlow; it.residual -= deltaFlow; if(maxFlow &lt;= 0) break; &#125; &#125; return flow;&#125;int MaxFlow(void)&#123; int totFlow = 0; while(BFS())&#123; memset(cur,0,sizeof(cur)); totFlow += Dinic(s); &#125; return totFlow;&#125;int val[MAXN];std::vector&lt;int&gt; even,odd;bool IsPrime(const int&amp; x)&#123; if(x &lt;= 2) return x == 2; int top = sqrt(x)+1; for(int i=2;i&lt;=top;i++) if(x%i == 0) return false; return true;&#125;bool vis[MAXN];std::vector&lt;int&gt; Gr[MAXN];std::vector&lt;std::vector&lt;int&gt;&gt; arr;void Dfs(const int&amp; nowAt)&#123; assert(Gr[nowAt].size() &lt;= 2); vis[nowAt] = true; arr.back().push_back(nowAt+1); for(const auto&amp; it : Gr[nowAt]) if(!vis[it]) Dfs(it);&#125;signed main(void)&#123; int totNums; std::cin&gt;&gt;totNums; for(int i=0;i&lt;totNums;i++)&#123; std::cin&gt;&gt;val[i]; if(val[i] &amp; 1) odd.push_back(i); else even.push_back(i);%:include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 250;struct Edge&#123; int fr,to,residual; Edge()&#123;&#125; Edge(const int&amp; ifr,const int&amp; ito,const int&amp; ire) : fr(ifr),to(ito),residual(ire) &#123;&#125;&#125;; const int s=MAXN-2,t=MAXN-1;std::vector&lt;Edge&gt;edges; std::vector&lt;int&gt; G[MAXN];void AddEdge(const int&amp; fr,const int&amp; to,const int&amp; residual)&#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr,to,residual)); G[to].push_back(edges.size()); edges.push_back(Edge(to,fr,0));&#125;int depth[MAXN],cur[MAXN];bool BFS(void)&#123; memset(depth,0x7f,sizeof(depth)); std::queue&lt;int&gt; que; que.push(s); depth[s] = 0; int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(int i=0;i&lt;G[nowAt].size();i++)&#123; const auto&amp; it = edges[G[nowAt][i]]; if(depth[it.fr]+1&lt;depth[it.to] &amp;&amp; it.residual&gt;0)&#123; depth[it.to] = depth[it.fr]+1; que.push(it.to); &#125; &#125; &#125; return depth[t]&lt;1000;&#125;int Dinic(const int&amp; nowAt, int maxFlow = INT_MAX)&#123; if(nowAt==t || maxFlow&lt;=0) return maxFlow; int deltaFlow,flow=0; for(int &amp;i=cur[nowAt];i&lt;G[nowAt].size();i++)&#123; auto&amp; it = edges[G[nowAt][i]]; if(depth[it.fr]+1==depth[it.to] &amp;&amp; 0&lt;(deltaFlow=Dinic(it.to,std::min(maxFlow,it.residual))))&#123; maxFlow -= deltaFlow; flow += deltaFlow; edges[G[nowAt][i]^1].residual += deltaFlow; it.residual -= deltaFlow; if(maxFlow &lt;= 0) break; &#125; &#125; return flow;&#125;int MaxFlow(void)&#123; int totFlow = 0; while(BFS())&#123; memset(cur,0,sizeof(cur)); totFlow += Dinic(s); &#125; return totFlow;&#125;int val[MAXN];std::vector&lt;int&gt; even,odd;bool IsPrime(const int&amp; x)&#123; if(x &lt;= 2) return x == 2; int top = sqrt(x)+1; for(int i=2;i&lt;=top;i++) if(x%i == 0) return false; return true;&#125;bool vis[MAXN];std::vector&lt;int&gt; Gr[MAXN];std::vector&lt;std::vector&lt;int&gt;&gt; arr;void Dfs(const int&amp; nowAt)&#123; assert(Gr[nowAt].size() &lt;= 2); vis[nowAt] = true; arr.back().push_back(nowAt+1); for(const auto&amp; it : Gr[nowAt]) if(!vis[it]) Dfs(it);&#125;signed main(void)&#123; int totNums; std::cin&gt;&gt;totNums; for(int i=0;i&lt;totNums;i++)&#123; std::cin&gt;&gt;val[i]; if(val[i] &amp; 1) odd.push_back(i); else even.push_back(i); &#125; for(const auto&amp; it : odd) AddEdge(it,t,2); for(const auto&amp; it : even) AddEdge(s,it,2); for(const auto&amp; od : even) for(const auto&amp; ev : odd) if(IsPrime(val[od]+val[ev])) AddEdge(od,ev,1); int maxflow; if((maxflow=MaxFlow()) != totNums)&#123; puts("Impossible"); /*std::cout&lt;&lt;maxflow&lt;&lt;std::endl; */ return 0; &#125; memset(vis,false,sizeof(vis)); for(int i=0;i&lt;edges.size();i+=2) if(edges[i].residual==0 &amp;&amp; edges[i].fr&lt;totNums &amp;&amp; edges[i].to&lt;totNums)&#123; Gr[edges[i].fr].push_back(edges[i].to); Gr[edges[i].to].push_back(edges[i].fr); &#125; for(int i=0;i&lt;totNums;i++) if(!vis[i])&#123; arr.push_back(std::vector&lt;int&gt;()); Dfs(i); &#125; std::cout&lt;&lt;arr.size()&lt;&lt;std::endl; for(const auto&amp; ar : arr)&#123; std::cout&lt;&lt;ar.size()&lt;&lt;' '; for(const auto&amp; it : ar) std::cout&lt;&lt;it&lt;&lt;' '; std::cout&lt;&lt;std::endl; &#125; return 0;&#125; &#125; for(const auto&amp; it : odd) AddEdge(it,t,2); for(const auto&amp; it : even) AddEdge(s,it,2); for(const auto&amp; od : even) for(const auto&amp; ev : odd) if(IsPrime(val[od]+val[ev])) AddEdge(od,ev,1); int maxflow; if((maxflow=MaxFlow()) != totNums)&#123; puts("Impossible"); /*std::cout&lt;&lt;maxflow&lt;&lt;std::endl; */ return 0; &#125; memset(vis,false,sizeof(vis)); for(int i=0;i&lt;edges.size();i+=2) if(edges[i].residual==0 &amp;&amp; edges[i].fr&lt;totNums &amp;&amp; edges[i].to&lt;totNums)&#123; Gr[edges[i].fr].push_back(edges[i].to); Gr[edges[i].to].push_back(edges[i].fr); &#125; for(int i=0;i&lt;totNums;i++) if(!vis[i])&#123; arr.push_back(std::vector&lt;int&gt;()); Dfs(i); &#125; std::cout&lt;&lt;arr.size()&lt;&lt;std::endl; for(const auto&amp; ar : arr)&#123; std::cout&lt;&lt;ar.size()&lt;&lt;' '; for(const auto&amp; it : ar) std::cout&lt;&lt;it&lt;&lt;' '; std::cout&lt;&lt;std::endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF3D Least Cost Bracket Sequence]]></title>
    <url>%2F2019%2F11%2F06%2FLeast_Cost_Bracket_Sequence%2F</url>
    <content type="text"><![CDATA[Codeforces3 D.Least Cost Bracket Sequence 给定一个括号序列，其中有一些位置是 ?. 这个 ? 变为 ( 和 ) 的代价分别为 $a_i$, $b_i$. 求出使得总代价最小的标准括号序列和这个最小总代价。 记 $cnt_i$ 代表第 $i$ 位和之前的括号中 左括号$-$右括号 的个数。那么题目要求优先满足 $\forall cnt_i\ge0$ 且 $cnt_n=0$. 我们在到达一个 ? 时直接将其变为 ), 并记录答案，由于这个序列中左括号和右括号个数是固定的，因此很有可能我们在到达某一位 $i$ 时就会发现 $cnt_i&lt;0$. 这个时候我们就需要在前面找到一个最小的 $a_j-b_j$, 并且把第 $j$ 位替换为 (. 具体实现过程中可以用一个堆来记录最小值。时间复杂度为 $O(N\log N)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051%:include&lt;bits/stdc++.h&gt; constexpr auto MAXN = (int)5e4+50; char charat[MAXN];long long lft[MAXN],rgt[MAXN]; std::priority_queue&lt;std::pair&lt;long long,int&gt;, std::vector&lt;std::pair&lt;long long,int&gt;&gt;, std::greater&lt;std::pair&lt;long long,int&gt;&gt;&gt; que; signed main(void)&#123; int totLen,num; long long ans = 0; scanf("%s", charat); totLen = strlen(charat); num = 0; for(int i=0;i&lt;totLen;i++) if(charat[i] == '?')&#123; std::cin&gt;&gt;lft[num]&gt;&gt;rgt[num]; ++num; &#125; int cnt = 0; std::pair&lt;long long,int&gt; ret; num = 0; for(int nowAt=0;nowAt&lt;totLen;nowAt++) switch(charat[nowAt])&#123; case '(': ++cnt; break; case ')': if(--cnt &lt; 0)&#123; if(que.empty())&#123; puts("-1"); return 0; &#125; ret = que.top(); que.pop(); cnt += 2; charat[ret.second] = '('; ans += ret.first; &#125; break; case '?': ans += rgt[num]; charat[nowAt] = ')'; que.push(std::make_pair(lft[num]-rgt[num], nowAt)); if(--cnt &lt; 0)&#123; if(que.empty())&#123; puts("-1"); return 0; &#125; ret = que.top(); que.pop(); cnt += 2; charat[ret.second] = '('; ans += ret.first; &#125; ++num; break; default: assert(false); &#125; if(cnt &gt; 0) puts("-1"); else std::cout&lt;&lt;ans&lt;&lt;std::endl&lt;&lt;charat&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF258D Little Elephant and Broken Sorting]]></title>
    <url>%2F2019%2F11%2F06%2FLittle%20_lephant_and_Broken_Sorting%2F</url>
    <content type="text"><![CDATA[Codeforces258 D.Little Elephant and Broken Sorting 给定一个 $1-n$ 的排列和 $m$ 次交换操作。第 $i$ 次操作可能会将排列中第 $u_i$ 个数与第 $v_i$ 个数，执行的概率为 $50\%$. 需要求出最终逆序对个数的期望。 如果一个位置数对 $(i,j)$ 能够对逆序对个数产生贡献，那么必定满足两数位置上 $p_iv_j$. 设 $f_{i,j}$ 代表第 $i$ 个位置上的数值大于第 $j$ 个位置上的数的概率。位置数对 $(i,j)$ 能够产生的期望贡献是个数乘上出现概率，由于个数一定是 1, 那么期望贡献就是概率，总期望为 \sum_{1\leq i\leq n}\sum_{i]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2019 语言]]></title>
    <url>%2F2019%2F10%2F30%2Flang%2F</url>
    <content type="text"><![CDATA[给定 $n$ 个结点构成一棵树，其中每一个结点代表一个城市。有 $m$ 次语言普及工作，第 $i$ 次使得城市 $f_i\to t_i$ 最短路径上的所有城市掌握第 $i$ 个通用语。如果两个城市存在同时掌握的通用语，那么他们之间可以展开贸易，询问能够展开贸易的城市对个数。 这里的城市对指的是有序数对，我们可以先求出无序对，最终答案除以 2 即可。 考虑对于一个特定的城市 $s$, 它能够到达的城市集合，容易发现这一定是一个联通块。现在像构建虚树那样选出一些关键点。第一个关键点是 $s$, 对于一条经过 $s$ 的路径 $f\to s\to t$, 令 $f$ 与 $t$ 为关键点。这个联通块就是用这些关键点构造虚树，最终覆盖的点集大小。 具体实现过程中，还是考虑 $f\to t$ 这样一条路径，它制造了两个关键点: $f$ 和 $t$. 这两个关键点作用范围是这条路径上的所有点。首先树链剖分，将这一条路径拆分成为许多 ID 连续的段，在树上差分。 最终将整棵树搜一遍，用一个支持 区间加 和 查询区间非$0$ 的数据结构(线段树)维护。由于在一个有多个儿子的结点处需要合并多个线段树的信息，所以线段树需要动态开点，支持合并。 时间复杂度 $O(N\log^2 N+M\log^2 N)$. 在合并线段树时需要注意及时删除掉不再需要的结点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137%:include&lt;bits/stdc++.h&gt;struct Area&#123; int fr,to; Area()&#123;&#125; Area(const int&amp; ifr,const int&amp; ito)&#123; fr = std::min(ifr,ito); to = std::max(ifr,ito); &#125;&#125;;struct Opt&#123; Area ar; int val; Opt()&#123;&#125; Opt(const Area&amp; iar,const int&amp; ival) : ar(iar),val(ival) &#123;&#125; Opt(const int&amp; ifr,const int&amp; ito,const int&amp; ival) : val(ival)&#123; ar = Area(ifr,ito); &#125;&#125;;constexpr auto MAXN = 100050;//Segment Treeint range;struct Node&#123; int len,cover,cnt; Node *lft,*rgt; Node()&#123; cover = cnt = 0; lft = rgt = nullptr; &#125; Node(const int&amp; ilen) : len(ilen)&#123; cover = cnt = 0; lft = rgt = nullptr; &#125; Node&amp; Update(void)&#123; if(cover &gt; 0) cnt = len; else&#123; cnt = 0; if(lft != nullptr) cnt += lft-&gt;cnt; if(rgt != nullptr) cnt += rgt-&gt;cnt; &#125; if(lft!=nullptr &amp;&amp; lft-&gt;cover==0 &amp;&amp; lft-&gt;cnt==0)&#123; delete lft; lft = nullptr; &#125; if(rgt!=nullptr &amp;&amp; rgt-&gt;cover==0 &amp;&amp; rgt-&gt;cnt==0)&#123; delete rgt; rgt = nullptr; &#125; return *this; &#125;&#125;*root[MAXN];void Add(const Opt&amp; opt, Node*&amp; nowAt, const int fr=0,const int to=range)&#123; if(to&lt;opt.ar.fr || opt.ar.to&lt;fr) return; if(nowAt == nullptr) nowAt = new Node(to-fr+1); if(opt.ar.fr&lt;=fr &amp;&amp; to&lt;=opt.ar.to) nowAt-&gt;cover += opt.val; else&#123; Add(opt,nowAt-&gt;lft,fr,fr+to&gt;&gt;1); Add(opt,nowAt-&gt;rgt,1+(fr+to&gt;&gt;1),to); &#125; nowAt-&gt;Update();&#125;int Query(Node* rt)&#123; return rt==nullptr ? 0LL : rt-&gt;cnt; &#125;Node* Merge(Node* a,Node* b)&#123; if(a==nullptr || b==nullptr) return a==nullptr ? b : a; a-&gt;cover += b-&gt;cover; a-&gt;lft = Merge(a-&gt;lft, b-&gt;lft); a-&gt;rgt = Merge(a-&gt;rgt,b-&gt;rgt); a-&gt;Update(); delete b; return a;&#125;std::vector&lt;int&gt; G[MAXN];std::vector&lt;Opt&gt; add[MAXN];int depth[MAXN],up[MAXN];int Index[MAXN],imp[MAXN],siz[MAXN],top[MAXN];void Dfs2(const int&amp; nowAt, const int fa = 0)&#123; depth[nowAt] = depth[up[nowAt] = fa] + 1; siz[nowAt] = 1; for(const auto&amp; it : G[nowAt]) if(it != fa)&#123; Dfs2(it,nowAt); siz[nowAt] += siz[it]; if(siz[it] &gt; siz[imp[nowAt]]) imp[nowAt] = it; &#125;&#125;void Dfs3(const int&amp; nowAt, const int fa = 0)&#123; static int dfs_clock = 0; Index[nowAt] = dfs_clock++; if(imp[fa] == nowAt) top[nowAt] = top[fa]; else top[nowAt] = nowAt; add[nowAt].push_back(Opt(Index[nowAt],Index[nowAt],1)); add[fa].push_back(Opt(Index[nowAt],Index[nowAt],-1)); if(imp[nowAt] &gt; 0) Dfs3(imp[nowAt], nowAt); for(const auto&amp; it : G[nowAt]) if(it!=fa &amp;&amp; it!=imp[nowAt]) Dfs3(it, nowAt);&#125;std::vector&lt;Area&gt; arearr;int Top(int a,int b)&#123; &#123; std::vector&lt;Area&gt; T; std::swap(T, arearr); &#125; while(top[a] != top[b])&#123; if(depth[top[a]] &lt; depth[top[b]]) std::swap(a,b); arearr.push_back(Area(Index[top[a]], Index[a])); a = up[top[a]]; &#125; arearr.push_back(Area(Index[a], Index[b])); return depth[a]&lt;depth[b] ? a : b;&#125;long long ans;void Solve(const int&amp; nowAt,const int fa = 0)&#123; root[nowAt] = nullptr; for(const auto&amp; it : G[nowAt]) if(it!=fa)&#123; Solve(it,nowAt); root[nowAt] = Merge(root[nowAt], root[it]); &#125; for(const auto&amp; it : add[nowAt]) Add(it,root[nowAt]); ans += Query(root[nowAt])-1;&#125;signed main(void)&#123; int totVertex,totLang,fr,to,lca; scanf("%d%d", &amp;totVertex,&amp;totLang); range = totVertex; for(int i=1;i&lt;totVertex;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); G[fr].push_back(to); G[to].push_back(fr); &#125; Dfs2(1); Dfs3(1); while(totLang--)&#123; scanf("%d%d", &amp;fr,&amp;to); lca = Top(fr,to); for(const auto&amp; it : arearr)&#123; add[fr].push_back(Opt(it,1)); add[to].push_back(Opt(it,1)); add[up[lca]].push_back(Opt(it,-2)); &#125; &#125; Solve(1); printf("%lld\n", ans&gt;&gt;1); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp2016 天天爱跑步]]></title>
    <url>%2F2019%2F10%2F28%2Ftiantian%2F</url>
    <content type="text"><![CDATA[给定一棵有 $n$ 个节点的树，有 $m$ 个玩家，第 $i$ 个玩家起点为 $S_i$, 终点为 $T_i$, 每天所有玩家在第 $0$ 秒会出发不停歇地沿着最短路径从起点跑向终点，速度为 $1$ 条边每秒，到达终点之后他会立刻消失。每一个节点上都有一个观测者，将会在 $W_i$ 秒出现，记录下当前这个节点的人数。询问所有观测者观察到的结果。 对于任意一个玩家的路径 $S_i\to T_i$, 拆分成为两段: $S_i\to lca$ 和 $lca\to T_i$, 在树上打上差分标记，分别处理。 考虑向上走的 $S_i\to lca$, 如果存在一个节点 $j$, 在 $W_j$ 这个时刻出现的观测者能够观察到的玩家 $i$ 必须满足 $depth_{S_i}-depth_j=W_j$. 这样假定我们现在有一颗平衡树，其中每一个元素 $i$ 的值代表了一个节点 $i$ 到当前点 $j$ 的距离 $depth_i-depth_j$. 由于节点 $j$ 的观测者会在 $W_i$ 这个时刻观测，所以答案就等于在这颗平衡树中查询等于 $W_i$ 的节点的数量。现在我们回溯到 $j$ 的父亲 $fa_j$, 会发现只需要将平衡树中所有元素全部加上 $1$. 同样的方法可以用于处理向下走的半段路径，最后在有多个儿子的节点处启发式合并多个平衡树即可。时间复杂度为 $O(N\log^2N)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209%:include&lt;bits/stdc++.h&gt;//BSTnamespace ScapegoatBST&#123; size_t totref = 0; class Set&#123; private:#define Alpha (0.78) struct Node&#123; int val,add; size_t siz,cnt; Node *lft,*rgt; Node()&#123; lft = rgt = nullptr; siz = cnt = 1; add = 0; &#125; Node(const int&amp; ival) : val(ival) &#123; siz = cnt = 1; lft = rgt = nullptr; add = 0; &#125; Node(const int&amp; ival,const int&amp; icnt) : val(ival),cnt(icnt) &#123; siz = 1; add = 0; lft = rgt = nullptr; &#125; Node&amp; Update(void)&#123; siz = 1; if(lft != nullptr) siz += lft-&gt;siz; if(rgt != nullptr) siz += rgt-&gt;siz; return *this; &#125; bool Balance(void)&#123; bool res = true; if(lft != nullptr) res = res&amp;&amp;(double)siz*Alpha&gt;lft-&gt;siz; if(rgt != nullptr) res = res&amp;&amp;(double)siz*Alpha&gt;rgt-&gt;siz; return res; &#125; Node&amp; Add(const int&amp; addval)&#123; val += addval; add += addval; return *this; &#125; Node&amp; Push_Down(void)&#123; if(add)&#123; if(lft != nullptr) lft-&gt;Add(add); if(rgt != nullptr) rgt-&gt;Add(add); add = 0; &#125; return *this; &#125; &#125;*root; std::vector&lt;Node*&gt; arr; void Dfs(Node* nowAt)&#123; nowAt-&gt;Push_Down(); if(nowAt-&gt;lft != nullptr) Dfs(nowAt-&gt;lft); if(nowAt-&gt;cnt &gt; 0) arr.push_back(nowAt); if(nowAt-&gt;rgt != nullptr) Dfs(nowAt-&gt;rgt); if(nowAt-&gt;cnt &lt;= 0) delete nowAt; &#125; Node* Build(const int&amp; fr,const int&amp; to)&#123; if(fr &gt; to) return nullptr; int mid = (fr+to)&gt;&gt;1; Node* ret = arr[mid]; ret-&gt;lft = Build(fr,mid-1); ret-&gt;rgt = Build(mid+1,to); ret-&gt;Update(); return ret; &#125; Node* Rebuild(Node* targ)&#123; &#123; std::vector&lt;Node*&gt; T; std::swap(arr,T); &#125; Dfs(targ); ++totref; //std::cout&lt;&lt;"Refreshed!"&lt;&lt;std::endl; return Build(0,arr.size()-1); &#125; void Attend(const int&amp; val,const size_t&amp; times, Node*&amp; nowAt)&#123; if(nowAt == nullptr) nowAt = new Node(val,times); else &#123; nowAt-&gt;Push_Down(); if(val == nowAt-&gt;val) nowAt-&gt;cnt += times; else if(val &lt; nowAt-&gt;val) Attend(val, times, nowAt-&gt;lft); else Attend(val, times, nowAt-&gt;rgt); &#125; if(!nowAt-&gt;Update().Balance()) nowAt = Rebuild(nowAt); &#125; bool Delete(const int&amp; val,Node*&amp; nowAt)&#123; if(nowAt == nullptr) return false; nowAt-&gt;Push_Down(); bool res; if(nowAt-&gt;val == val) &#123; --nowAt-&gt;cnt; res = true; &#125; else if(val &lt; nowAt-&gt;val) res = Delete(val,nowAt-&gt;lft); else res = Delete(val,nowAt-&gt;rgt); if(!nowAt-&gt;Update().Balance()) nowAt = Rebuild(nowAt); return res; &#125; void Merge(Node* nowAt)&#123; nowAt-&gt;Push_Down(); Attend(nowAt-&gt;val, nowAt-&gt;cnt, root); if(nowAt-&gt;lft != nullptr) Merge(nowAt-&gt;lft); if(nowAt-&gt;rgt != nullptr) Merge(nowAt-&gt;rgt); &#125; public: Set()&#123; root = nullptr; &#125; Set&amp; Attend(const int&amp; val)&#123; Attend(val,1,root); return *this; &#125; bool Delete(const int&amp; val)&#123; return Delete(val,root); &#125; size_t Count(const int&amp; val)&#123; Node* nowAt = root; while(nowAt != nullptr)&#123; nowAt-&gt;Push_Down(); if(nowAt-&gt;val == val) return nowAt-&gt;cnt; else if(val &lt; nowAt-&gt;val) nowAt = nowAt-&gt;lft; else nowAt = nowAt-&gt;rgt; &#125; return 0; &#125; Set&amp; Add(const int&amp; delta)&#123; if(root != nullptr) root-&gt;Add(delta); return *this; &#125; Set&amp; Attend(const Set&amp; add)&#123; //return *this; if(add.root != nullptr) Merge(add.root); return *this; &#125; &#125;;&#125;; using namespace ScapegoatBST;constexpr auto MAXN = 300000;constexpr auto MAXM = 300000;constexpr auto MAXK = 18;std::vector&lt;int&gt; G[MAXN];int siz[MAXN],imp[MAXN];//LCAint up[MAXN][MAXK],depth[MAXN];void Render_Table(const int&amp; nowAt,const int&amp; fa = 0)&#123; depth[nowAt] = depth[fa] + 1; up[nowAt][0] = fa; siz[nowAt] = 1; for(int i=1;i&lt;MAXK;i++) up[nowAt][i] = up[up[nowAt][i-1]][i-1]; for(const auto&amp; it : G[nowAt]) if(it != fa)&#123; Render_Table(it,nowAt); siz[nowAt] += siz[it]; if(siz[it] &gt; siz[imp[nowAt]]) imp[nowAt] = it; &#125;&#125;int LCA(int a,int b)&#123; if(depth[a] &lt; depth[b]) std::swap(a,b); for(int i=MAXK-1;i&gt;=0;i--) if(depth[a]-(1&lt;&lt;i) &gt;= depth[b]) a = up[a][i]; if(a == b) return a; for(int i=MAXK-1;i&gt;=0;i--) if(up[a][i] != up[b][i])&#123; a = up[a][i]; b = up[b][i]; &#125; return up[a][0];&#125;int Dist(int a,int b)&#123; int dist = 0; if(depth[a] &lt; depth[b]) std::swap(a,b); for(int i=MAXK-1;i&gt;=0;i--) if(depth[a]-(1&lt;&lt;i) &gt;= depth[b])&#123; a = up[a][i]; dist += 1&lt;&lt;i; &#125; if(a == b) return dist; for(int i=MAXK-1;i&gt;=0;i--) if(up[a][i] != up[b][i])&#123; dist += 1&lt;&lt;i+1; a = up[a][i]; b = up[b][i]; &#125; return dist + 2;&#125;Set Attend;std::vector&lt;Set&gt; godown(1),goup(1);std::vector&lt;int&gt; addup[MAXN],adddown[MAXN],delup[MAXN],deldown[MAXN];int appear[MAXN],ans[MAXN];void Dfs(const int&amp; nowAt, const int&amp; targ = 0, const int&amp; fa = 0)&#123; if(imp[nowAt] &gt; 0) Dfs(imp[nowAt], targ, nowAt); for(const auto&amp; it : G[nowAt]) if(it!=fa &amp;&amp; it!=imp[nowAt])&#123; godown.push_back(Attend); goup.push_back(Attend); Dfs(it,godown.size()-1,nowAt); &#125; for(int i=targ+1;i&lt;godown.size();i++) godown[targ].Attend(godown[i]); for(int i=targ+1;i&lt;goup.size();i++) goup[targ].Attend(goup[i]); goup.resize(targ + 1); godown.resize(targ + 1); godown[targ].Add(-1); goup[targ].Add(1); for(const auto&amp; it : addup[nowAt]) goup[targ].Attend(it); for(const auto&amp; it : adddown[nowAt]) godown[targ].Attend(it); for(const auto&amp; it : delup[nowAt]) goup[targ].Delete(it); for(const auto&amp; it : deldown[nowAt]) godown[targ].Delete(it); ans[nowAt] = godown[targ].Count(appear[nowAt]) + goup[targ].Count(appear[nowAt]); assert(godown.size() == goup.size());&#125;signed main(void)&#123; int totVertex,totPlayers,fr,to,lca,dis; scanf("%d%d", &amp;totVertex,&amp;totPlayers); for(int i=1;i&lt;totVertex;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); G[fr].push_back(to); G[to].push_back(fr); &#125; Render_Table(1); std::for_each(appear+1,appear+totVertex+1,[](auto&amp; it)&#123; scanf("%d", &amp;it); &#125;); while(totPlayers--)&#123; scanf("%d%d", &amp;fr,&amp;to); lca = LCA(fr,to); dis = Dist(fr,lca); addup[fr].push_back(0); delup[lca].push_back(dis); deldown[*up[lca]].push_back(dis-1); adddown[to].push_back(Dist(fr,to)); &#125; Dfs(1); std::for_each(ans+1,ans+totVertex+1,[](const auto&amp; it)&#123; printf("%d ", it); &#125;); putchar('\n'); //std::cout&lt;&lt;totref&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式开根]]></title>
    <url>%2F2019%2F10%2F21%2FPolynomialSqrt%2F</url>
    <content type="text"><![CDATA[给定一个 $n-1$ 次多项式 $A(x)$, 求一个在 $\mod x^n$ 意义下的多项式 $B(x)$, 使得 $B^2(x)\equiv A(x)\mod x^n$. 多项式系数在 $\mod 998244353$ 意义下进行运算。 设 H^2(x)\equiv A(x)\mod x^\frac n2\\ G^2(x)\equiv A(x)\mod x^n那么 G(x)\equiv H(x)\mod x^\frac n2\\ G(x)-H(x)\equiv 0\mod x^\frac n2\\ \left(G(x)-H(x)\right)^2\equiv 0\mod x^n\\ G^2(x)+H^2(x)-2G(x)H(x)\equiv 0\mod x^n由于 A(x)\equiv G^2(x)\mod x^n所以 A(x)+H^2(x)-2G(x)H(x)\equiv 0\mod x^n\\ G(x)\equiv\frac{H^2(x)+A(x)}{2H(x)}\mod x^n这样就可以倍增求解，时间复杂度为 $O(N\log^2N)$. 空间需要 $O(4N)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123%:include&lt;bits/stdc++.h&gt;constexpr auto MOD = 998244353LL;template&lt;typename ansType,typename powsType&gt;inline ansType Pow(ansType a,powsType b,const ansType&amp; MOD = MOD)&#123; ansType ans = 1LL; for(;b;b&gt;&gt;=1,(a*=a)%=MOD) if(b &amp; 1) (ans *= a) %= MOD; return ans;&#125;template&lt;typename T&gt;inline T Module(T a,const T&amp; b)&#123; a += b; if(a &gt;= MOD) a -= MOD; return a;&#125;constexpr auto MAXN = 500052;constexpr auto g = 3LL;constexpr auto inv2 = 499122177LL;int r[MAXN];void NTT(long long* A,const int&amp; totLevel, const short &amp;type)&#123; int totNums = 1&lt;&lt;totLevel; for(int i=0;i&lt;totNums;i++) if(i &lt; r[i]) std::swap(A[i], A[r[i]]); long long temp,gn,omega; for(int nowLevel=0;nowLevel&lt;totLevel;nowLevel++)&#123; gn = Pow(g, (MOD-1)/(1LL&lt;&lt;nowLevel+1)); if(type == -1) gn = Pow(gn, MOD-2); for(int nowBlk=0;nowBlk&lt;totNums;nowBlk+=1&lt;&lt;nowLevel+1)&#123; omega = 1; for(int i=0;i&lt;(1&lt;&lt;nowLevel);i++)&#123; temp = omega*A[nowBlk+i+(1&lt;&lt;nowLevel)] % MOD; A[nowBlk+i+(1&lt;&lt;nowLevel)] = Module(A[nowBlk+i], MOD-temp); A[nowBlk+i] = Module(A[nowBlk+i], temp); (omega *= gn) %= MOD; &#125; &#125; &#125; if(type == -1)&#123; temp = Pow((long long)totNums,MOD-2); for(int i=0;i&lt;totNums;i++) (A[i] *= temp) %= MOD; &#125;&#125;int* Calrev(int* rev, const int&amp; totLevel)&#123; int totNums = 1&lt;&lt;totLevel; *rev = 0; for(int i=1;i&lt;=totNums;i++) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;totLevel-1); return rev;&#125;void Mult(long long* X,long long* Y,const int&amp; totLevel)&#123; static long long cX[MAXN], cY[MAXN]; int totNums = 1&lt;&lt;totLevel; memset(cX,0,sizeof(cX)); memset(cY,0,sizeof(cY)); for(int i=0;i&lt;(totNums&gt;&gt;1);i++)&#123; cX[i] = X[i]; cY[i] = Y[i]; &#125; Calrev(r, totLevel); NTT(cX, totLevel, 1); NTT(cY, totLevel, 1); for(int i=0;i&lt;totNums;i++) (cX[i] *= cY[i]) %= MOD; NTT(cX, totLevel, -1); for(int i=0;i&lt;totNums;i++) X[i] = cX[i];&#125;long long* Inverse(long long *ret, long long* arr,const int&amp; totNums)&#123; static long long B[2][MAXN] = &#123;&#125;; memset(B,0,sizeof(B)); int cur=0; B[cur][0] = Pow(arr[0], MOD-2); int fin=1,nowsiz=2,lev=1; while(fin &lt; (totNums&lt;&lt;1))&#123; cur ^= 1; memset(B[cur], 0, sizeof(B[cur])); Calrev(r, lev); for(int i=0;i&lt;fin;i++) B[cur][i] = (B[cur^1][i]&lt;&lt;1) % MOD; Mult(B[cur^1], B[cur^1], lev); Mult(B[cur^1], arr, lev); for(int i=0;i&lt;nowsiz;i++) B[cur][i] = Module(B[cur][i], MOD-B[cur^1][i]); fin&lt;&lt;=1; nowsiz&lt;&lt;=1; ++lev; &#125; for(int i=0;i&lt;totNums;i++) ret[i] = B[cur][i]; return ret;&#125;long long* Sqrt(long long* ret, long long* arr,const int&amp; totNums)&#123; static long long inv[MAXN], cparr[MAXN]; memset(inv,0,sizeof(inv)); memset(cparr,0,sizeof(cparr)); ret[0] = 1; int fin=1,nowsiz=2,lev=1; for(;fin&lt;(totNums&lt;&lt;1);++lev,fin&lt;&lt;=1,nowsiz&lt;&lt;=1)&#123; for(int i=0;i&lt;fin;i++) cparr[i] = arr[i]; Inverse(inv, ret, fin); Calrev(r,lev); NTT(cparr, lev, 1); NTT(inv, lev, 1); for(int i=0;i&lt;nowsiz;i++) (cparr[i] *= inv[i]) %= MOD; NTT(cparr, lev, -1); for(int i=0;i&lt;fin;i++) ret[i] = (ret[i]+cparr[i])%MOD *inv2 %MOD; for(int i=fin;i&lt;nowsiz;i++) ret[i] = 0; &#125; return ret;&#125;long long A[MAXN],B[MAXN];signed main(void)&#123; int tot; scanf("%d", &amp;tot); for(int i=0;i&lt;tot;i++) scanf("%lld", A+i); Sqrt(B,A,tot); for(int i=0;i&lt;tot;i++) printf("%lld ", B[i]); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式求逆]]></title>
    <url>%2F2019%2F10%2F20%2FPolynomialInverse%2F</url>
    <content type="text"><![CDATA[给定一个 $n-1$ 次多项式 $F(x)$, 求出一个多项式 $G(x)$ 满足 $F(x)G(x)\equiv1\mod x^n$. 系数对 $998244353$ 取模。 假定保证有解，考虑在知道 F(x)H(x)\equiv1\mod x^\frac n2的情况下如何求出 $G(x)$. 推导一下可以发现 F(x)H(x)\equiv 1\mod x^\frac n2\\ F(x)G(x)\equiv 1\mod x^n\\ F(x)\left(G(x)-H(x)\right)\equiv 0\mod x^\frac n2\\ G(x)-H(x)\equiv 0\mod x^\frac n2\\ \left(G(x)-H(x)\right)^2\equiv 0\mod x^n\\ G^2(x)+H^2(x)-2G(x)H(x)\equiv 0\mod x^n两边同时乘上 $F(x)$ 得 G(x)+F(x)H^2(x)-2H(x)\equiv 0\mod x^n\\ G(x)\equiv 2H(x)-F(x)H^2(x)\mod x^n倍增求解即可。时间复杂度为 $O(N\log N)$, 需要 2 倍空间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;constexpr auto MOD = 998244353LL;constexpr auto MAXN = (int)5e5;long long Pow(long long a,long long b, long long MOD = ::MOD)&#123; long long ans = 1LL; for(;b;b&gt;&gt;=1,(a*=a)%=MOD) if(b &amp; 1) (ans *= a) %= MOD; return ans;&#125;long long Module(long long a,const long long&amp; b)&#123; a+=b; return a&gt;=MOD ? a-MOD : a; &#125;long long&amp; s_Module(long long&amp; a, const long long&amp; b)&#123; a+=b; return a&gt;=MOD ? a-=MOD : a; &#125;namespace Poly&#123; constexpr auto g = 3LL; int r[MAXN]; int* GetR(const int&amp; totLv)&#123; int totNums = 1 &lt;&lt; totLv; *r=0; for(int i=1;i&lt;totNums;++i) r[i] = (r[i&gt;&gt;1]&gt;&gt;1) | ((i&amp;1)&lt;&lt;totLv-1); return r; &#125; void NTT(long long* A,const int&amp; totLv, const long long&amp; type)&#123; int totNums = 1 &lt;&lt; totLv; for(int i=0;i&lt;totNums;++i) if(i &lt; r[i]) std::swap(A[i], A[r[i]]); long long temp,Omega,Omega_n; for(int i=0;i&lt;totLv;++i)&#123; Omega_n = Pow(g, (MOD-1)/(1LL&lt;&lt;i+1)); if(type == -1) Omega_n = Pow(Omega_n, MOD-2); for(int j=0;j&lt;totNums;j+=(1&lt;&lt;i+1))&#123; Omega = 1LL; for(int k=0;k&lt;(1&lt;&lt;i);++k)&#123; temp = (A[j+k+(1&lt;&lt;i)] * Omega) % MOD; A[j+k+(1&lt;&lt;i)] = Module(A[j+k], MOD-temp); s_Module(A[j+k], temp); (Omega *= Omega_n) %= MOD; &#125; &#125; &#125; if(type == -1)&#123; temp = Pow((long long)totNums, MOD-2); for(int i=0;i&lt;totNums;++i) (A[i] *= temp) %= MOD; &#125; &#125; long long* Mult(long long* X,long long* Y, const int&amp; totLv, const bool equ=true)&#123; static long long A[MAXN],B[MAXN]; memset(A,0,sizeof(A)); memset(B,0,sizeof(B)); int totNums = 1 &lt;&lt; totLv; for(int i=0;i&lt;(totNums&gt;&gt;(equ?1:0));++i) A[i]=X[i], B[i]=Y[i]; NTT(A,totLv,1); NTT(B,totLv,1); for(int i=0;i&lt;totNums;++i) (A[i] *= B[i]) %= MOD; NTT(A,totLv,-1); for(int i=0;i&lt;totNums;++i) X[i] = A[i]; return X; &#125;&#125;; using namespace Poly;namespace PolyInv&#123; long long* Inverse(long long* arr, const int&amp; totLv)&#123; static long long A[2][MAXN]; int totNums = 1 &lt;&lt; totLv; int cur=0; memset(A[cur],0,sizeof(A[cur])); A[cur][0] = Pow(*arr, MOD-2); int fin=1,lev=1,nowsiz=2; while(fin &lt;= totNums)&#123; cur ^= 1; memset(A[cur],0,sizeof(A[cur])); GetR(lev); for(int i=0;i&lt;fin;++i) A[cur][i] = (A[cur^1][i]&lt;&lt;1) % MOD; Mult(A[cur^1],A[cur^1], lev, true); Mult(A[cur^1], arr, lev, true); for(int i=0;i&lt;nowsiz;++i) A[cur][i] = Module(A[cur][i], MOD-A[cur^1][i]); fin &lt;&lt;= 1; nowsiz&lt;&lt;=1; ++lev; &#125; for(int i=0;i&lt;totNums;++i) arr[i] = A[cur][i]; return A[cur]; &#125; long long* Inverse(long long* A,long long* B, const int&amp; totLv)&#123; int totNums = 1 &lt;&lt; totLv; for(int i=0;i&lt;totNums;++i) A[i] = B[i]; return Inverse(A, totLv); &#125;&#125;; using namespace PolyInv;long long A[MAXN],B[MAXN];signed main(void)&#123; int totA,tot=1,totLv=0; scanf("%d", &amp;totA); --totA; for(int i=0;i&lt;=totA;++i) scanf("%lld", A+i); while(tot &lt;= totA)&#123; tot&lt;&lt;=1; ++totLv; &#125; Inverse(B,A,totLv); for(int i=0;i&lt;=totA;++i) printf("%lld ", B[i]); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>NTT</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2019 弹跳]]></title>
    <url>%2F2019%2F10%2F17%2FJump%2F</url>
    <content type="text"><![CDATA[平面上有 $n$ 个点，第 $i$ 个坐标为 $(x_i,y_i)$, 有 $m$ 次加边操作，第 $i$ 次从 $p_i$ 连至所有满足 $L_i\leq x\leq R_i$, $D_i\leq y\leq U_i$ 的点，长度为 $d_i$, 求从第一个点出发到所有其他点的最短路。 首先将所有的点读入，建立 K-D Tree. 然后对于每一个加边操作，在 K-D Tree 上从根开始处理，每到达一个点 $t$ 如果这个点代表的区间完全在边能够到达的矩形之内，那么从 $p$ 向 $t$ 连边，否则如果 $t$ 代表的点在边能够到达的矩形之内，那么从 $p$ 向 $t$ 代表的点连边。最后一次最短路即可。 除此之外我们需要加入一些优化。 不能将跑最短路的图真正建出来，只需要在每次树上查询的同时松弛即可。这一步的思路与上面建图是几乎一样的。 用 Dijkstra 代替 SPFA. 最后卡常即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201%:include&lt;bits/stdc++.h&gt;namespace FastIO&#123; inline int Read(void) &#123; int x = 0; static char ch = 0; static bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = getchar(); &#125; return x = sign ? -x : x; &#125; inline void WriteLine(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) &#123; putchar(stk[top--] + '0'); &#125; putchar('\n'); &#125;&#125;; using namespace FastIO;struct Vector2&#123; int y,x; Vector2()&#123;&#125; Vector2(const int&amp; iy,const int&amp; ix) : y(iy),x(ix) &#123;&#125; bool operator == (const Vector2&amp; comp) const &#123; return y==comp.y &amp;&amp; x==comp.x; &#125; bool operator &lt;= (const Vector2&amp; comp) const &#123; return y&lt;=comp.y &amp;&amp; x&lt;=comp.x; &#125; bool operator &gt;= (const Vector2&amp; comp) const &#123; return y&gt;=comp.y &amp;&amp; x&gt;=comp.x; &#125; bool operator != (const Vector2&amp; comp) const &#123; return x!=comp.x || y!=comp.x; &#125; int&amp; operator [] (const int&amp; ind) &#123; if(ind&lt;0 || ind&gt;=2) assert(false); if(ind == 0) return y; else return x; &#125;&#125;;typedef Vector2 Point;struct Rec&#123; Vector2 ld,rt; Rec()&#123; ld = Point(INT_MAX,INT_MAX); rt = Point(INT_MIN, INT_MIN); &#125; Rec(const int&amp; ay,const int&amp; ax,const int&amp; by,const int&amp; bx)&#123; ld = Point(ay,ax); rt = Point(by,bx); &#125; Rec(const Vector2&amp; ild,const Vector2&amp; irt) : ld(ild), rt(irt) &#123;&#125; bool Cover(const Vector2&amp; judge) const &#123; return ld&lt;=judge &amp;&amp; judge&lt;=rt; &#125; bool SubRec(const Rec&amp; judge) const&#123; return ld&lt;=judge.ld &amp;&amp; judge.rt&lt;=rt; &#125; Rec&amp; Attend(const Vector2&amp; add)&#123; ld.y = std::min(ld.y, add.y); ld.x = std::min(ld.x, add.x); rt.y = std::max(rt.y, add.y); rt.x = std::max(rt.x, add.x); return *this; &#125; Rec operator + (const Rec&amp; add) const &#123; Rec ans; ans.ld.y = std::min(ld.y, add.ld.y); ans.ld.x = std::min(ld.x, add.ld.x); ans.rt.y = std::max(rt.y, add.rt.y); ans.rt.x = std::max(rt.x, add.rt.x); return ans; &#125; Rec&amp; operator += (const Rec&amp; add)&#123; return *this = *this+add; &#125; Rec&amp; operator = (const Vector2&amp; equ)&#123; ld = rt = equ; return *this; &#125;&#125;;inline bool Cross(const Rec&amp; a,const Rec&amp; b)&#123; Vector2 ld,rt; ld.x = std::max(a.ld.x, b.ld.x); ld.y = std::max(a.ld.y, b.ld.y); rt.x = std::min(a.rt.x, b.rt.x); rt.y = std::min(a.rt.y, b.rt.y); return ld &lt;= rt;&#125;//---------------------------------------------------------------------------constexpr auto MAXN = 70005;constexpr auto MAXM = 150005;constexpr auto INF = 0x3f3f3f3f;struct Edge&#123; Rec to; int dis; Edge(const int&amp; ay,const int&amp; ax,const int&amp; by,const int&amp; bx,const int&amp; idis) : dis(idis) &#123; to = Rec(ay,ax,by,bx); &#125;&#125;;std::vector&lt;Edge&gt; G[MAXN];//K-Dtreestruct Node&#123; Rec area; Vector2 point; Node *ch[2]; int ptID; //nodeID = ptID+MAXN Node()&#123; ch[0] = ch[1] = nullptr; &#125; Node(const Vector2&amp; pt) : point(pt) &#123; area.ld = area.rt = pt; ch[0] = ch[1] = nullptr; &#125; inline Node&amp; Update(void)&#123; area = point; if(ch[0] != nullptr) area += ch[0]-&gt;area; if(ch[1] != nullptr) area += ch[1]-&gt;area; return *this; &#125; inline int ID/*nodeID*/(void)&#123; return ptID + MAXN; &#125;&#125;*root = nullptr;Node nodearr[MAXN],*nodeIDMap[MAXN],**node;Node* Build(Node* fr, Node* to, const int&amp; dimension=1)&#123; if(to-fr == 1) return fr; if(fr &lt; to)&#123; Node* mid = fr + (to-fr&gt;&gt;1); std::nth_element(fr, mid, to, [&amp;dimension](auto&amp; a,auto&amp; comp)&#123; return a.point[dimension]&lt;comp.point[dimension]; &#125;); mid-&gt;ch[0] = Build(fr, mid, dimension^1); mid-&gt;ch[1] = Build(mid+1, to, dimension^1); mid-&gt;Update(); return mid; &#125; return nullptr;&#125;//Dijkstraint dist[MAXN&lt;&lt;1];struct Status&#123; int pos,dis; Status()&#123;&#125; Status(const int&amp; ipos,const int&amp; idis) : pos(ipos),dis(idis) &#123;&#125; bool operator &lt; (const Status&amp; comp) const &#123; return dis &gt; comp.dis; &#125;&#125;;std::priority_queue&lt;Status&gt; que;//Jumpvoid Relax(const int&amp; preDis, const Edge&amp; it, Node* nowAt=root)&#123; if(nowAt == nullptr) return; if(it.to.SubRec(nowAt-&gt;area))&#123; if(dist[nowAt-&gt;ID()] &gt; preDis+it.dis)&#123; dist[nowAt-&gt;ID()] = preDis + it.dis; que.push(Status(nowAt-&gt;ID(), dist[nowAt-&gt;ID()])); &#125; &#125; else if(it.to.Cover(nowAt-&gt;point))&#123; if(dist[nowAt-&gt;ptID] &gt; preDis+it.dis)&#123; dist[nowAt-&gt;ptID] = preDis + it.dis; que.push(Status(nowAt-&gt;ptID, dist[nowAt-&gt;ptID])); &#125; Relax(preDis, it, nowAt-&gt;ch[0]); Relax(preDis, it, nowAt-&gt;ch[1]); &#125; else if(Cross(it.to, nowAt-&gt;area))&#123; Relax(preDis, it, nowAt-&gt;ch[0]); Relax(preDis, it, nowAt-&gt;ch[1]); &#125;&#125;signed main(void)&#123; int totNodes,totEdges,w,h,x,y; //ReadIN scanf("%d%d%d%d", &amp;totNodes,&amp;totEdges,&amp;w,&amp;h); for(register int i=0;i&lt;totNodes;++i)&#123; x = Read(); y = Read(); nodearr[i] = Node(Vector2(y,x)); &#125; //std::for_each(nodearr, nodearr+totNodes, [](auto&amp; it)&#123; int x,y; scanf("%d%d", &amp;x,&amp;y); it = Node(Vector2(y,x)); &#125;); for(register int i=0;i&lt;totNodes;++i) nodearr[i].ptID = i; root = Build(nodearr,nodearr+totNodes); node = nodeIDMap - MAXN; for(register int i=0;i&lt;totNodes;++i) nodeIDMap[nodearr[i].ptID] = nodearr+i; //for(int i=0;i&lt;totNodes;i++)&#123; assert(node[i+MAXN] == nodeIDMap[i]); assert(nodeIDMap[i]-&gt;ptID == i); &#125; //puts("OK"); int fr,dis,ay,ax,by,bx; for(register int i=0;i&lt;totEdges;++i)&#123; fr = Read()-1; dis = Read(); ax = Read(); bx = Read(); ay = Read(); by = Read(); G[fr].push_back(Edge(ay,ax,by,bx, dis)); &#125; //Dijkstra memset(dist,INF,sizeof(dist)); *dist = 0; que.push(Status(0,0)); Status nowAt; int nowNode,nowLft,nowRgt; while(!que.empty())&#123; nowAt = que.top(); que.pop(); if(nowAt.dis != dist[nowAt.pos]) continue; if(nowAt.pos &lt; MAXN)&#123; for(const auto&amp; it : G[nowAt.pos]) Relax(nowAt.dis, it); &#125; else &#123; nowNode = node[nowAt.pos]-&gt;ID(); if(dist[nowNode-MAXN] &gt; dist[nowNode])&#123; dist[nowNode-MAXN] = dist[nowNode]; que.push(Status(nowNode-MAXN, dist[nowNode])); &#125; if(node[nowAt.pos]-&gt;ch[0] != nullptr)&#123; nowLft = node[nowAt.pos]-&gt;ch[0]-&gt;ID(); if(dist[nowLft] &gt; nowAt.dis)&#123; dist[nowLft] = nowAt.dis; que.push(Status(nowLft, nowAt.dis)); &#125; &#125; if(node[nowAt.pos]-&gt;ch[1] != nullptr)&#123; nowRgt = node[nowAt.pos]-&gt;ch[1]-&gt;ID(); if(dist[nowRgt] &gt; nowAt.dis)&#123; dist[nowRgt] = nowAt.dis; que.push(Status(nowRgt, nowAt.dis)); &#125; &#125; &#125; &#125; //Output for(register int i=1;i&lt;totNodes;++i) WriteLine(dist[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>K-Dtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2016 大森林]]></title>
    <url>%2F2019%2F10%2F15%2Fbft%2F</url>
    <content type="text"><![CDATA[你需要维护一个包含 $n$ 棵树的森林(一开始每棵树仅有根节点编号为 $1$)，并处理 $m$ 次操作： 将第 $l$ 棵树到第 $r$ 棵树的生长节点下面长出一个子节点，子节点编号为上一个 0 操作长出节点编号加 $1$. 将第 $l$ 棵树到第 $r$ 棵树的生长节点更改为 $x$ 节点。 询问第 $x$ 棵树中节点 $u$ 到节点 $v$ 的距离。 如果仅存在一棵树，那么我们可以使用 LCT 维护，可以轻松支持 0 和 1 操作，对于 2 操作需要将边拆成点，两次 Access to Root, 较后一次 Access 最后打通的节点就是 LCA, LCT 上差分一下即可。 每一个操作带来的树形态更改都是非常微小的，但是由于每次都作用在一个区间所有树上，所以时间开销巨大。考虑忽略操作 1 中修改区间 $[l,r]$, 发现如果我们每一次操作 1 都作用在 $[1,n]$ 所有树上，那么最终查询答案的时候不会有任何影响。 接下来考虑一个 1 操作，如果这个操作将生长节点从 $u$ 修改为了 $v$, 作用区间是 $[l,r]$, 此时树上存在的所有节点中编号最大的是 $x$. 观察不受这个操作影响的树 $l-1$, 发现接下来所有的 0 操作长出的节点都还是在 $u$ 上的(假定不会再有 1 操作)，观察树 $l$, 发现它与 $l-1$ 的区别就是编号大于 $x$ 的节点的父亲不同。因此从树 $l-1$ 到 $l$ 就是将所有编号大于 $x$ 的节点更改父亲。 实现过程中，我们可以将操作离线，首先不考虑 1 操作建出一棵树，再将每一个 1 操作转换成 $l-1\to l$ 和 $r\to r+1$ 的变化，建立一个虚拟节点，并在这棵树上把生长节点改成这个虚拟节点，遇到需要变化形态的地方直接找到对应的虚拟节点然后 Link 和 Cut 即可。 这样 LCT 上需要维护最多 $2n+m$ 个节点，具体实现需要注意一些细节。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139%:include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)2e5;constexpr auto MAXM = (int)3e5;struct Node&#123; int val,sumVal; Node *fa,*ch[2]; Node()&#123; val = sumVal = 0; fa = ch[0] = ch[1] = nullptr; &#125; Node(const int&amp; ival) : val(ival)&#123; sumVal = val; fa = ch[0] = ch[1] = nullptr; &#125; Node&amp; Update(void)&#123; sumVal = val; if(ch[0] != nullptr) sumVal += ch[0]-&gt;sumVal; if(ch[1] != nullptr) sumVal += ch[1]-&gt;sumVal; return *this; &#125; bool IsRoot(void)&#123; if(fa == nullptr) return true; return fa-&gt;ch[0]!=this &amp;&amp; fa-&gt;ch[1]!=this; &#125; int Pos(Node* targ)&#123; if(ch[0] == targ) return 0; else if(ch[1] == targ) return 1; else return -1; &#125;&#125;;void Rotate(Node* targ)&#123; const bool pos = targ-&gt;fa-&gt;ch[1] == targ; Node *faa = targ-&gt;fa; faa-&gt;ch[pos] = targ-&gt;ch[pos^1]; if(faa-&gt;ch[pos] != nullptr) faa-&gt;ch[pos]-&gt;fa = faa; targ-&gt;ch[pos^1] = faa; targ-&gt;fa = faa-&gt;fa; faa-&gt;fa = targ; if(targ-&gt;fa != nullptr) if(targ-&gt;fa-&gt;ch[0] == faa) targ-&gt;fa-&gt;ch[0] = targ; else if(targ-&gt;fa-&gt;ch[1] == faa) targ-&gt;fa-&gt;ch[1] = targ; faa-&gt;Update(); targ-&gt;Update();&#125;void Spaly(Node* nowAt)&#123; for(;!nowAt-&gt;IsRoot() &amp;&amp; !nowAt-&gt;fa-&gt;IsRoot();Rotate(nowAt)) if(nowAt-&gt;fa-&gt;Pos(nowAt) == nowAt-&gt;fa-&gt;fa-&gt;Pos(nowAt-&gt;fa)) Rotate(nowAt-&gt;fa); else Rotate(nowAt); if(!nowAt-&gt;IsRoot()) Rotate(nowAt);&#125;Node* Access(Node* nowAt)&#123; Node* last = nullptr; for(Node* prev=nullptr; nowAt!=nullptr; nowAt=nowAt-&gt;fa)&#123; Spaly(nowAt); nowAt-&gt;ch[1] = prev; nowAt-&gt;Update(); prev = nowAt; last = nowAt; &#125; return last;&#125;void Link(Node* a,Node* b)&#123; Spaly(b); b-&gt;fa = a;&#125;void Cut(Node* targ)&#123; Access(targ); Spaly(targ); targ-&gt;ch[0]-&gt;fa = nullptr; targ-&gt;ch[0] = nullptr; targ-&gt;Update();&#125;int GetDistance(Node* a,Node* b)&#123; int disa,disb; Access(a); Spaly(a); disa = a-&gt;sumVal; Node* LCA = Access(b); Spaly(b); disb = b-&gt;sumVal; Access(LCA); Spaly(LCA); return disa+disb-(LCA-&gt;sumVal&lt;&lt;1);&#125;//------------------------------------------------------------------Node vetx[MAXM],fscut[MAXM];struct Area&#123; int fr,to; Area()&#123; fr = to = 0; &#125; Area(const int&amp; ifr,const int&amp; ito) : fr(ifr),to(ito) &#123;&#125;&#125;vetxExist[MAXM];struct Opert&#123; int pos,ID,fr,to; bool tofscut; Opert()&#123; tofscut = false; &#125; Opert(const int&amp; ipos,const int&amp; iID,const int&amp; ifr,const int&amp; ito) : fr(ifr),to(ito),pos(ipos),ID(iID) &#123; tofscut = false; &#125; bool operator () (const Opert&amp; a,const Opert&amp; comp) const &#123; return a.pos == comp.pos ? a.ID &lt; comp.ID : a.pos &lt; comp.pos; &#125;&#125;opert[MAXM&lt;&lt;1];int ans[MAXM];signed main(void)&#123; int totTree,totOptn,totVertex=1,totQuery=0,totOpts=0,linkTo=1; int opt,fr,to,targ; scanf("%d%d", &amp;totTree,&amp;totOptn); vetx-&gt;val = 1; vetx-&gt;sumVal = 1; *vetxExist = Area(0,totTree-1); Link(vetx, fscut); //ReadIN while(totOptn--)&#123; scanf("%d", &amp;opt); switch(opt)&#123; case 0: scanf("%d%d", &amp;fr,&amp;to); vetxExist[totVertex] = Area(fr,to); vetx[totVertex].fa = new Node(1); Link(fscut+linkTo-1, vetx[totVertex++].fa); break; case 1: scanf("%d%d%d", &amp;fr,&amp;to,&amp;targ); --targ; fr = std::max(fr, vetxExist[targ].fr); to = std::min(to, vetxExist[targ].to); if(fr &lt;= to)&#123; opert[totOpts++] = Opert(fr,-1,linkTo,targ); opert[totOpts] = Opert(to+1,-1,linkTo,linkTo-1); opert[totOpts++].tofscut = true; ++linkTo; Link(fscut+linkTo-2, fscut+linkTo-1); &#125; break; case 2: scanf("%d%d%d", &amp;targ,&amp;fr,&amp;to); --fr; --to; opert[totOpts++] = Opert(targ,totQuery++,fr,to); break; default: assert(false); break; &#125; &#125; //Calc std::sort(opert,opert+totOpts,Opert()); for(int i=0;i&lt;totOpts;i++) if(opert[i].ID &lt; 0)&#123; Cut(fscut+opert[i].fr); if(opert[i].tofscut) Link(fscut+opert[i].to, fscut+opert[i].fr); else Link(vetx+opert[i].to, fscut+opert[i].fr); &#125; else ans[opert[i].ID] = GetDistance(vetx+opert[i].fr, vetx+opert[i].to); //Output std::for_each(ans,ans+totQuery,[](const auto&amp; it)&#123; printf("%d\n", it); &#125;); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1238E Keyboard Purchase]]></title>
    <url>%2F2019%2F10%2F10%2FKeyboardPurchase%2F</url>
    <content type="text"><![CDATA[题目链接: Codeforces 1238E. Keyboard Purchase 给定一个长度为 $n$ 的文本串 $s$, 由不超过 $m$ 种字母构成，你需要设计一个键盘，它是这 $m$ 个字母的一个排列，其中第 $i$ 个字母在键盘上的位置为 $p_i$. 定义用这个键盘打出 $s$ 的代价是 \sum_{i=1}^{n-1}|p_{s_i}-p_{s_{i-1}}|求最小代价。 注意到 $m$ 特别小，考虑状态压缩动态规划。 定义 $D_S$ 为安排完成 $S$ 中字符后的代价。由于后面不在 $S$ 中的字母顺序未定，如果这个代价代表的是所有 $s_i\in S$ 且 $s_{i+1}\in S$ 产生的，那么不太容易计算。由于这里 $S$ 中字母已经顺序确定，我们现在考虑新加入一个字母 $a$, 这个 $a$ 放在键盘的最右端，这样所有原先属于 $S$ 中的元素到不属于 $S$ 中的元素的代价就会多 $1$. 因此我们在枚举 $a$ 时，多出的代价就是 g_S=\sum_{i\in S}\sum_{j\not\in S}c_{i,j}其中 $c_{i,j}$ 代表字符 $i$ 和 $j$ 在文本 $s$ 中相邻的次数。这样，转移方程就是 D_S=\min\{D_{S-a}+g_S\}边界是 $D_\varnothing=0$, 答案是 $D_M$. 中间的每一个状态 $D_S$ 代表将 $S$ 中的元素按照某种顺序从左至右放在键盘上，剩下的字符都假定暂时在键盘从左至右第 $|S|+1$ 个位置上 的最小代价。 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;int ReadChar(void)&#123; int in; do in = getchar()-'a'; while(!(0&lt;=in &amp;&amp; in&lt;20)); return in;&#125;constexpr auto MAXN = (int)1e5+1;constexpr auto MAXK = 20;int s[MAXN];int cnt[MAXK][MAXK];int g[1&lt;&lt;MAXK],D[1&lt;&lt;MAXK];signed main(void)&#123; int totLen,totKey,delta,target; std::cin&gt;&gt;totLen&gt;&gt;totKey; std::for_each(s,s+totLen,[](auto&amp; it)&#123; it = ReadChar(); &#125;); for(int i=1;i&lt;totLen;i++) ++cnt[s[i]][s[i-1]], ++cnt[s[i-1]][s[i]]; g[(1&lt;&lt;totKey)-1] = 0; for(int i=(1&lt;&lt;totKey)-2;i&gt;=0;i--)&#123; for(target=0;0!=((i&gt;&gt;target)&amp;1);target++); delta = 0; for(int j=0;j&lt;totKey;j++) if(j!=target &amp;&amp; 0==((i&gt;&gt;j)&amp;1)) delta -= cnt[target][j]; for(int j=0;j&lt;totKey;j++) if((i&gt;&gt;j)&amp;1) delta += cnt[target][j]; g[i] = g[i|(1&lt;&lt;target)] + delta; &#125; *D = 0; int top = 1&lt;&lt;totKey; for(int i=1;i&lt;top;i++)&#123; D[i] = INT_MAX; for(int j=0;j&lt;totKey;j++) if((i&gt;&gt;j) &amp; 1) D[i] = std::min(D[i], D[i^(1&lt;&lt;j)]); D[i] += g[i]; &#125; printf("%d\n", D[top-1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FJOI2015 火星商店问题]]></title>
    <url>%2F2019%2F09%2F25%2FMarsShop%2F</url>
    <content type="text"><![CDATA[火星商业街上有 $n$ 个商店，商店每天都可能会进一些新商品。火星人在购物时会选择编号在 $[L,R]$ 中的商店，并从这些商店最近 $d$ 天进的商品中选择一种购买，以使得商品价格 $c$ 与这个人的购物喜好 $x$ 异或起来尽可能大。每种商品在进货后能无限供应，同时每个商店有一件特殊商品，第 $i$ 个商店的标价是 $a_i$，能够不受时间限制地被选择。我们需要处理总共 $m$ 个进货和购物事件，并回答对于所有购物事件 $x~\mbox{xor}~c$ 的最大值。 题目链接 首先忽略掉修改不看，单独处理一开始就有的特殊商品，这时每个人都需要在一个给定的区间 $[L,R]$ 内找到使得 $x~\mbox{xor}~c$ 最大的 $x$, 也就是最大异或和问题。 接下来考虑每一个询问，这些询问都有两个维度的限制，规定只能考虑时间 $[l,r]$ 空间 $[L,R]$ 中所有的点。我们可以考虑将时间拆分成很多段，然后再分别考虑相应时间段内点的贡献，就像线段树分治那样，拆分成为线段树上一些区间。我们在线段树上每一个节点都开一个变长数组记录它们，对于变长数组中的所有元素，它们只剩下空间上的限制 $[L,R]$, 时间与这个点代表的区间相同。接下来只需要将所有修改看做点，按空间排序后一起放在线段树所有满足时间条件的点上。由于空间已经是有序的，所以只用插入到可持久化 Trie 中，再对于每一个询问逐一求最大异或，最终对一个询问所有求得的值取 $\max$ 就是答案。 考虑每一个修改最多作用到 $\log M$ 个区间上，每一个询问最多被拆分为 $\log M$ 段，而在可持久化 Trie 上的操作都是一次 $\log a$, 因此总时间复杂度为 $O(N\log^2 M)$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 100050;constexpr auto MAXM = MAXN;constexpr auto MAXBITS = 18;class Trie&#123;private: struct Node&#123; int siz; Node* ch[2]; Node()&#123; siz = 0; ch[0] = ch[1] = nullptr; &#125; &#125;; std::vector&lt;Node*&gt; ver; public: Trie&amp; Cls(void)&#123; std::vector&lt;Node*&gt; T; std::swap(ver, T); return *this; &#125; void Insert(const int&amp; val)&#123; Node *last = (ver.empty() ? nullptr : ver.back()), *nowAt, *add; nowAt = new Node(); add = nowAt; for(int i=MAXBITS;i&gt;=0;i--)&#123; const short bit = (val&gt;&gt;i)&amp;1; nowAt-&gt;ch[bit] = new Node(); nowAt-&gt;ch[bit]-&gt;siz = 1; if(last != nullptr)&#123; nowAt-&gt;ch[bit]-&gt;siz += (last-&gt;ch[bit]==nullptr ? 0 : last-&gt;ch[bit]-&gt;siz); nowAt-&gt;ch[bit^1] = last-&gt;ch[bit^1]; last = last-&gt;ch[bit]; &#125; else nowAt-&gt;ch[bit^1] = nullptr; nowAt = nowAt-&gt;ch[bit]; &#125; ver.push_back(add); &#125; int FindMax(const int&amp; beg,const int&amp; end,const int&amp; val)&#123; Node *last = (beg==0?nullptr:ver[beg-1]),*nowAt = ver[end]; int ans = 0; for(int i=MAXBITS;i&gt;=0;i--)&#123; if(nowAt == nullptr) return 0; const short&amp; bit = ((val&gt;&gt;i)&amp;1)^1; if(last != nullptr)&#123; if(nowAt-&gt;ch[bit]!=nullptr &amp;&amp; nowAt-&gt;ch[bit]-&gt;siz - (last-&gt;ch[bit]==nullptr?0:last-&gt;ch[bit]-&gt;siz) &gt; 0)&#123; ans |= (1&lt;&lt;i); nowAt = nowAt-&gt;ch[bit]; last = last-&gt;ch[bit]; &#125; else &#123; nowAt = nowAt-&gt;ch[bit^1]; last = last-&gt;ch[bit^1]; &#125; &#125; else &#123; if(nowAt-&gt;ch[bit]!=nullptr &amp;&amp; nowAt-&gt;ch[bit]-&gt;siz &gt; 0)&#123; ans |= (1&lt;&lt;i); nowAt = nowAt-&gt;ch[bit]; &#125; else nowAt = nowAt-&gt;ch[bit^1]; &#125; &#125; return ans; &#125;&#125;spc;//----------------------------------------int ans[MAXN];struct Item&#123; int shop,val,day; Item()&#123;&#125; Item(const int&amp; ishop,const int&amp; ival,const int&amp; iday) : shop(ishop),val(ival),day(iday) &#123;&#125; bool operator () (const Item&amp; a,const Item&amp; comp) const &#123; return a.shop &lt; comp.shop; &#125;&#125;item[MAXN];struct Query&#123; int shopfr,shopto,timefr,timeto,val,ID; Query()&#123;&#125; Query(const int&amp; iL,const int&amp; iR,const int&amp; ifr,const int&amp; ito,const int&amp; ival,const int&amp; iID) : shopfr(iL),shopto(iR),timefr(ifr),timeto(ito),val(ival),ID(iID) &#123;&#125;&#125;que[MAXM];//Segment Treestruct Node&#123; int fr,to; std::vector&lt;Query&gt; G; //Array of Queries Node *lft,*rgt; Node()&#123; lft = rgt = nullptr; &#125; Node(const int&amp; ifr,const int&amp; ito) : fr(ifr),to(ito) &#123; lft = rgt = nullptr; &#125;&#125;*root;void Build(const int&amp; siz)&#123; Node *a,*b,*t; std::queue&lt;Node*&gt; que,add; for(int i=0;i&lt;=siz;i++)&#123; t = new Node(i,i); que.push(t); &#125; for(;que.size()&gt;=2;std::swap(que,add))&#123; while(que.size()&gt;=2)&#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = new Node(a-&gt;fr,b-&gt;to); t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if(!que.empty())&#123; add.push(que.front()); que.pop(); &#125; &#125; root = que.front();&#125;void Insert(const Query&amp; ins,Node* nowAt = root)&#123; if(ins.timeto&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;ins.timefr) return; if(ins.timefr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=ins.timeto) nowAt-&gt;G.push_back(ins); else&#123; Insert(ins,nowAt-&gt;lft); Insert(ins,nowAt-&gt;rgt); &#125;&#125;//Solverint range[MAXN],top;void Calc(Node* nowAt,const int&amp; fr,const int&amp; to)&#123; if(nowAt-&gt;G.size() &lt;= 0) return; top = 0; spc.Cls(); for(int i=fr;i&lt;=to;++i)&#123; range[top++] = item[i].shop; spc.Insert(item[i].val); &#125; int beg,end; for(const auto&amp; it : nowAt-&gt;G)&#123; beg = std::upper_bound(range,range+top,it.shopfr)-range-1; end = std::upper_bound(range,range+top,it.shopto)-range-1; if(end &lt; 0) continue; if(beg &lt; 0) beg = 0; if(range[beg] &lt; it.shopfr) ++beg; ans[it.ID] = std::max(ans[it.ID], spc.FindMax(beg,end,it.val)); &#125;&#125;Item larr[MAXN],rarr[MAXN];void Divide(Node* nowAt,const int&amp; fr,const int&amp; to)&#123; if(fr &gt; to || nowAt == nullptr) return; Calc(nowAt,fr,to); if(nowAt-&gt;fr == nowAt-&gt;to) return; int mid = nowAt-&gt;rgt-&gt;fr; int t0=0,t1=0; for(int i=fr;i&lt;=to;i++) if(item[i].day &lt; mid) larr[t0++] = item[i]; else rarr[t1++] = item[i]; for(int i=0;i&lt;t0;i++) item[fr+i] = larr[i]; for(int i=0;i&lt;t1;i++) item[fr+i+t0] = rarr[i]; Divide(nowAt-&gt;lft,fr,fr+t0-1); Divide(nowAt-&gt;rgt,fr+t0,to);&#125;signed main(void)&#123; int totShops,totOptn,totQuery=0,totDays=0; int deltaDay,opt,fr,to,val,targ; scanf("%d%d", &amp;totShops,&amp;totOptn); for(int i=0;i&lt;totShops;i++)&#123; scanf("%d", &amp;val); spc.Insert(val); &#125; for(int i=0;i&lt;totOptn;i++)&#123; scanf("%d", &amp;opt); switch(opt)&#123; case 0://Item scanf("%d%d", &amp;targ,&amp;val); --targ; ++totDays; item[totDays] = Item(targ,val,totDays); break; case 1://Query scanf("%d%d%d%d", &amp;fr,&amp;to,&amp;val,&amp;deltaDay); --fr; --to; que[totQuery] = Query(fr,to,std::max(0,totDays-deltaDay+1),totDays,val,totQuery); ans[totQuery++] = spc.FindMax(fr,to,val); break; default: assert(false); break; &#125; &#125; Build(totDays); std::for_each(que,que+totQuery,[](const auto&amp; it)&#123; Insert(it); &#125;); std::sort(item+1,item+totDays+1,Item()); Divide(root,1,totDays); std::for_each(ans,ans+totQuery,[](const auto&amp; it)&#123; printf("%d\n", it); &#125;); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1220D Alex and Julian]]></title>
    <url>%2F2019%2F09%2F19%2FAlex_and_Julian%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个集合 $B$ , 定义按照 $B$ 的生成图：将所有整数视作点，数值为点权，两点 $a,b$ 之间有连边当且仅当 $|a-b|\in B$. 我们需要去掉 $B$ 中若干元素，使得 $B$ 的生成图是一个二分图，在此基础之上，删除的数的数量要尽可能小。 考虑最终有那些元素能够留在 $B$ 中。将 $B$ 中元素按照二进制表示下末尾 0 的个数多少分组，如果 $B$ 中存在两个元素不在同一组中，那么 $B$ 的生成图一定不是一个二分图。这是由于，所有同组元素不会构成奇环，而只要 $\exist a,b\in B$ 且 $a,b$ 不同组，一定可以构成奇环。 第一个结论用反证法证明。记 $B$ 中元素二进制下最后一个 1 位置为 $p$. 如果存在一个奇环，我们记这个奇环最小点权的点为 $s$, 最大的为 $t$, 同时有两条链构成一个环 s\leftrightarrow a_1\leftrightarrow a_2\leftrightarrow\cdots a_n\leftrightarrow t\leftrightarrow b_1\leftrightarrow b_2\leftrightarrow\cdots b_m\leftrightarrow s由于这是一个奇环，所以 $n+m$ 为奇数。不失一般性，我们假定 $n$ 为奇数，$m$ 为偶数，这样从 $s$ 到 $t$ 本质上是奇数个 $B$ 中元素相加，二进制下这些数第 $p$ 位都是 1, 因此最终结果第 $p$ 位是 1, 同理推导出从 $s$ 到 $t$ 本质上是偶数个 $B$ 中元素相加，最终结果第 $p$ 位是 0. 接下来考虑第二种情形，令 $a$ 末尾 0 的个数为 $p_a$, $b$ 个数为 $p_b$, 其中 $p_a&lt;p_b$. 要想使得他们末尾 0 个数一样，需要将 $b$ 扩大 $2^{p_b-p_a}$ 倍得到 $c$，也就是将 $2^{p_b-p_a}+1$ 个点组成一个链，然后根据之前的结论，$a,c$ 这两个数构成的一定是偶环，但是我们在组成 $c$ 时需要一个多出来的结点，这个结点使得 $a,b$ 构成的是奇环。 代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;signed main(void)&#123; int totNums; long long num; std::vector&lt;long long&gt; arr[100]; std::cin&gt;&gt;totNums; for(int i=0;i&lt;totNums;i++)&#123; std::cin&gt;&gt;num; long long cnt=0,remain=num; while((remain&amp;1) == 0)&#123; remain &gt;&gt;= 1; ++cnt; &#125; arr[cnt].push_back(num); &#125; std::vector&lt;long long&gt;* max = arr; std::for_each(arr+1,arr+100,[&amp;max](auto&amp; it)&#123; if(it.size() &gt; max-&gt;size()) max = &amp;it; &#125;); std::cout&lt;&lt;totNums - max-&gt;size()&lt;&lt;std::endl; std::for_each(arr,arr+100,[&amp;max](const auto&amp; itarr)&#123; if(max != &amp;itarr) for(const auto&amp; it : itarr) std::cout&lt;&lt;it&lt;&lt;' '; &#125;); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF986C AND Graph]]></title>
    <url>%2F2019%2F09%2F11%2FAnd_Graph%2F</url>
    <content type="text"><![CDATA[题目链接 给定 $m$ 个属于 $[0,2^n)$ 的整数，按照以下方式建立无向图：两个整数 $x,y$ 如果满足 $x\&amp;y=0$, 那么在他们之间连边。这里 $\&amp;$ 是 按位与 操作。需要求出图中的联通块个数。 直接暴力建图肯定是不行的。考虑在联通的点之间找到某种特征，用其他的方式建图。 对于每一个整数代表的点 $x$ ，拆分他们为入点 $x$ 和出点 $x^\prime$. 对于所有给定的 $x$ 有一条有向边 $x\to x^\prime$. 对于所有整数 $x$, $(\mbox{~}x)^\prime\to x$. 对于整数 $x,k$ 如果满足 $x$ 的第 $k$ 个二进制位不是 1, $x^\prime\to \left(x|(1&lt;&lt;k)\right)^\prime$. 然后按照从小到大的顺序依次检查每一个给定的整数，如果它还没有被之前的整数标记，那么从这个整数代表的点 $x$ 开始，沿着这些有向边搜索下去，沿路标记遇到的其他给定整数。 时间复杂度为 $O(N2^N)$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 23;constexpr auto MAXM = (1&lt;&lt;23)+50;int topbits,top;bool vis[MAXM],mark[MAXM];std::queue&lt;int&gt; que;void Bfs(int nowAt)&#123; &#123; std::queue&lt;int&gt; T; std::swap(que,T); &#125; vis[nowAt] = true; que.push(nowAt); int nxt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); switch(nowAt &lt; top)&#123; case true: nxt = nowAt + top; if(!vis[nxt])&#123; vis[nxt] = true; que.push(nxt); &#125; break; case false: nowAt -= top; nxt = top-1 ^ nowAt; if(!vis[nxt] &amp;&amp; mark[nxt])&#123; vis[nxt] = true; que.push(nxt); &#125; nxt = nowAt; for(int i=0;i&lt;topbits;i++)&#123; nxt = nowAt|(1&lt;&lt;i); if(nxt != nowAt &amp;&amp; !vis[nxt+top])&#123; vis[nxt+top] = true; que.push(nxt+top); &#125; &#125; break; default: assert(false); break; &#125; &#125;&#125;signed main(void)&#123; memset(mark,false,sizeof(mark)); memset(vis,false,sizeof(vis)); int totNums,num,ans=0; std::cin&gt;&gt;topbits&gt;&gt;totNums; top = 1&lt;&lt;topbits; for(int i=0;i&lt;totNums;i++)&#123; std::cin&gt;&gt;num; mark[num] = true; &#125; for(int i=0;i&lt;top;i++) if(mark[i] &amp;&amp; !vis[i])&#123; Bfs(i); ++ans; &#125; std::cout&lt;&lt;ans&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WC2011 Xor]]></title>
    <url>%2F2019%2F08%2F09%2FXrd%2F</url>
    <content type="text"><![CDATA[给定一张无向连通图 $G$, 边有边权，问从 1 到 $n$ 的所有路径中，经过边的边权异或和最大是多少？相同的点和边都可以多次出现在这条路径中。 由于我们要求的是最大异或和，所以一条相同的路径走两次之后对答案的贡献就是 0. 可以发现，任何一条从 1 到 $n$ 的路径边权异或和都可以表示为另一条从 1 到 $n$ 路径边权异或和异或上一个环的所有边权异或和。这是因为如果我们从路径上某一个点走 $s$ 出去，走一条环，然后又走回来，连接 $s$ 和环的边对答案没有贡献。另一种情况是，从当前路径上一点 $s$ 走出去，然后经过一条路径 $l_1$ 回到当前路径上的一个点 $t$, 那么此时的答案就相当于原先路径异或上 $s\to t\to s$ 这样一个环(前面 $s\to t$ 存在与原来的路径上，然后 $t\to s$ 是路径 $l_1$). 这样，问题就转换为：任意一条 $s\to t$ 的路径，可以异或若干个环，使得最终异或和最大。 由于比较复杂的环都可以从简单环得到，我们只用一次深搜找到所有的简单环，然后全部插入线性基中。最后随便找一条路径 $s\to t$, 然后利用线性基求出最大异或和路径。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;constexpr auto maxbits = 64;constexpr auto MAXN = 50000+50;constexpr auto MAXM = 100000+50;//Liner Basislong long a[maxbits];void Insert(long long ins)&#123; for(int i=maxbits-1;i&gt;=0;i--)&#123; if((ins&amp;(1LL&lt;&lt;i)) == 0) continue; if(a[i]) ins ^= a[i]; else&#123; for(int j=i-1;j&gt;=0;j--) if(ins&amp;(1LL&lt;&lt;j)) ins ^= a[j]; for(int j=maxbits-1;j&gt;i;j--) if(a[i]&amp;(1LL&lt;&lt;i)) a[i] ^= ins; a[i] = ins; break; &#125; &#125;&#125;struct Line&#123; int to; long long val; Line()&#123;&#125; Line(const int&amp; ito,const long long&amp; ival):to(ito),val(ival)&#123;&#125; &#125;;std::vector&lt;Line&gt; G[MAXN];int totNodes;bool vis[MAXN];long long xsum[MAXN],ans;void Dfs(const int&amp; nowAt, const int fa = 0)&#123; vis[nowAt] = true; if(nowAt == totNodes) ans = xsum[nowAt]; for(const auto &amp;it : G[nowAt])&#123; if(it.to == fa) continue; if(vis[it.to])&#123; Insert(xsum[it.to] ^ xsum[nowAt] ^ it.val); //std::cout&lt;&lt;"Ins:"&lt;&lt;(xsum[it.to]^xsum[nowAt]^it.val)&lt;&lt;std::endl; &#125; else &#123; xsum[it.to] = xsum[nowAt]^it.val; Dfs(it.to,nowAt); &#125; &#125;&#125;signed main(void)&#123; int totEdges; int a,b; long long val; scanf("%d%d", &amp;totNodes,&amp;totEdges); for(int i=0;i&lt;totEdges;i++)&#123; scanf("%d%d%lld", &amp;a,&amp;b,&amp;val); G[a].push_back(Line(b,val)); G[b].push_back(Line(a,val)); &#125; Dfs(1); for(int i=maxbits-1;i&gt;=0;i--) if((ans&amp;(1LL&lt;&lt;i)) == 0) ans ^= ::a[i]; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CQOI2016 不同的最小割]]></title>
    <url>%2F2019%2F08%2F07%2FDif%2F</url>
    <content type="text"><![CDATA[题目链接 给定一张 $n$ 个点的无向连通图 $G=(V,E)$, 求所有不同点对的最小割容量的数量。 直接建立最小割树，树上两点的最小割容量就是他们之间路径中权值最小的边的边权，统计一下有多少不同边权即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 1500;constexpr auto MAXK = 20;struct Edge&#123; int fr,to,residual,cap; Edge()&#123;&#125; Edge(const int&amp; ifr,const int&amp; ito,const int&amp; ire,const int&amp; icap) : fr(ifr),to(ito),residual(ire),cap(icap) &#123;&#125;&#125;;std::vector&lt;Edge&gt;edges;std::vector&lt;int&gt; G[MAXN];void AddEdge(const int&amp; fr,const int&amp; to,const int&amp; res,const int&amp; cap)&#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr,to,res,cap)); G[to].push_back(edges.size()); edges.push_back(Edge(to,fr,res,cap));&#125;int cur[MAXN],dis[MAXN];bool BFS(const int&amp; s,const int&amp; t)&#123; std::queue&lt;int&gt; que; que.push(s); std::fill(dis,dis+MAXN,INT_MAX); dis[s] = 0; int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(int i=0;i&lt;G[nowAt].size();i++)&#123; const Edge&amp; it = edges[G[nowAt][i]]; if(it.residual&gt;0 &amp;&amp; dis[it.to]&gt;dis[nowAt]+1)&#123; dis[it.to] = dis[nowAt]+1; que.push(it.to); &#125; &#125; &#125; return dis[t] &lt; INT_MAX;&#125;int Dinic(const int&amp; nowAt,const int&amp; t,int maxFlow)&#123; if(nowAt==t || maxFlow&lt;=0) return maxFlow; int flow=0,deltaFlow; for(int&amp; i=cur[nowAt];i&lt;G[nowAt].size();i++)&#123; Edge&amp; it = edges[G[nowAt][i]]; if(dis[nowAt]+1==dis[it.to] &amp;&amp; 0&lt;(deltaFlow=Dinic(it.to,t,std::min(it.residual,maxFlow))))&#123; it.residual -= deltaFlow; edges[G[nowAt][i]^1].residual += deltaFlow; flow += deltaFlow; maxFlow -= deltaFlow; if(maxFlow &lt;= 0) break; &#125; &#125; return flow;&#125;int MaxFlow(const int&amp; s,const int&amp; t)&#123; int ans = 0; while(BFS(s,t))&#123; memset(cur,0,sizeof(cur)); ans += Dinic(s,t,INT_MAX); &#125; return ans;&#125;int cnt;std::set&lt;int&gt; S;struct Line&#123; int to,len; Line()&#123;&#125; Line(const int&amp; ito,const int&amp; ilen) : to(ito),len(ilen)&#123;&#125; &#125;;std::vector&lt;Line&gt; ch[MAXN]; int l[MAXN],r[MAXN], totNodes;void AddEdge(const int&amp; fr,const int&amp; to,const int&amp; len)&#123; ch[fr].push_back(Line(to,len)); ch[to].push_back(Line(fr,len));&#125;void Build(int* beg,int* end)&#123; if(end-beg &lt;= 1) return; for(auto &amp;it : edges) it.residual = it.cap; int w = MaxFlow(*beg,*(beg+1)); AddEdge(*beg, *(beg+1), w); if(!S.count(w)) ++cnt; S.insert(w); int len = 0; for(int* i=beg;i&lt;end;i++) if(dis[*i] &lt; INT_MAX) l[len++] = *i; else r[i-beg-len] = *i; for(int i=0;i&lt;len;i++) *(beg+i) = l[i]; for(int i=len;i&lt;(end-beg);i++) *(beg+i) = r[i-len]; Build(beg,beg+len); Build(beg+len,end);&#125;int num[MAXN];signed main(void)&#123; int totEdges,totQuery,fr,to,res; scanf("%d%d", &amp;totNodes,&amp;totEdges); for(int i=0;i&lt;totEdges;i++)&#123; scanf("%d%d%d", &amp;fr,&amp;to,&amp;res); AddEdge(fr,to,res,res); &#125; for(int i=1;i&lt;=totNodes;i++) num[i-1] = i; Build(num,num+totNodes); printf("%d\n", cnt); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基]]></title>
    <url>%2F2019%2F08%2F07%2FLinerBasis%2F</url>
    <content type="text"><![CDATA[线性基(Liner Basis)在 OI 中常用于解决子集异或问题。 如无特殊说明，全文线性基定义均为线性基在 OI 中的定义。 概念与定义异或和无符号整数集 $S$ 的异或和为将其中元素依次异或得到的值。记为 \mathrm{Xorsum}(S)=S_1~\mbox{xor}~S_2~\mbox{xor}\cdots\mbox{xor}~S_{|S|}张成设 $T\subseteq S$, 所有 $T$ 异或和组成的集合成为 $S$ 的张成，记作 $\mathrm{span}(S)$. 线性相关对于一个集合 $S$, 如果存在一个元素 $S_j$, $S$ 去掉这个元素之后得到集合 $S^\prime$, 满足 $S_j\in\mathrm{span}(S^\prime)$. 则称 $S$ 线性相关。 反之，如果不存在这样一个元素，则称 $S$ 线性无关。 线性基称集合 $B$ 为集合 $S$ 的线性基，当且仅当： $S\subseteq\mathrm{span}(B)$. $B$ 线性无关。 集合 $B$ 中元素个数，成为张成的 长度。 可见，线性基中的任何一个元素不能被其他的元素表示出来，而且使用线性基中的一个或多个元素能够表示 $S$ 中的任何元素。 构造令 $a$ 为一个整数，记 $a$ 二进制表示下从低到高第 $i$ 位二进制为 $a_i$. 设集合 $S$ 中最大的数在二进制表示下有 $L$ 位，我们使用一个长度为 $L$ 的数组 $A$ 存储线性基。如果 $A$ 中的一个元素 $A_i\not=0$, 那么它存在于线性基中。 性质$\forall i,A_i\not=0$ $\forall j\in(i,L],\;(A_i)_j=0$ $(A_i)_i=1$ $\forall j\in[0,L],j\not=i,\;(A_j)_i=0$ 流程线性基是线性构造的，假定我们需要向 $S$ 中插入一个新元素 $t$, 并更新它的线性基。 我们从高位向低位枚举 $t$ 的每一个二进制位 $i$: $t_i=0$, $i\leftarrow i-1$. $t_i\not=0,A_i\not=0$, $t\leftarrow t~\mbox{xor}~A_i$. 否则，从高位到低位枚举 $j\in(i,0]$, $t\leftarrow t~\mbox{xor}~A_j$. 然后，从高位到低位枚举 $j\in[L,i)$, 如果 $(A_j)_i\not=0$, $A_j\leftarrow A_j~\mbox{xor}~t$. 最终 $A_i\leftarrow t$. 代码 12345678910111213141516171819constexpr auto MAXBITS = 64;long long a[MAXBITS];void Insert(long long ins)&#123; for(int i=MAXBITS-1;i&gt;=0;i--)&#123; if((ins&amp;(1LL&lt;&lt;i)) == 0) continue; if(a[i]) ins ^= a[i]; else&#123; for(int j=i-1;j&gt;=0;j--) if(ins&amp;(1LL&lt;&lt;j)) ins ^= a[j]; for(int j=MAXBITS-1;j&gt;i;j--) if(a[j]&amp;(1LL&lt;&lt;i)) a[j] ^= ins; a[i] = ins; return; &#125; &#125;&#125; 正确性证明显然按照上述步骤插入元素，得到的线性基满足所有的性质。因为在从高位向低位枚举的过程中，如果 $t_i\not=0$, 此时它第 $i$ 位上的 1 要么被 $(A_i)_i$ 异或消掉(此时不会让更高位得到 1，因为 $\forall j&gt;i(A_i)_j=0$). 而一旦找到了一个合适的位置($t_i=1,A_i=0$), 我们先用 $ji$ 的 $(A_j)_i\not=0$, 将他们消去，最终所有性质得到满足。考虑新的线性基如何表示所有的数，同时线性无关。 用数学归纳法。 如果 $S$ 为空集，那么线性基中没有元素。 考虑加入一个数 $t$ 的过程，我们为了满足线性基的性质，不断将这个数与线性基中已有的元素异或，如果异或了某一个元素 $A_j$, 那么我们最终还是可以通过将他们再次异或，还原出两个原来的数，也就是说，我们在异或 $t$ 和线性基中的某一个 $A_j$ 时，始终不会改变线性基的张成。而最终我们在数组中找到一个位置 $A_j=0$, 我们就没有办法再通过异或线性基中的元素，将 $t_j$ 变成 0(同时保证更高位为 0)，因此我们插入当前元素，调整其他元素使得线性基满足所有性质。 考虑线性基中所有的 $A_i\not=0$, 它拥有一位 $(A_i)_i=1$, 同时所有的 $j\not=i$ 都满足 $(A_j)_i=0$, 所以线性基中不存在一个非 0 的数能够表示为另外两个非 0 的数的异或和。也就是说此时线性基线性无关。 应用判断一个数能否由若干数的子集异或得到将这个数插入线性基，如果最终没有使得数组中某一个等于 0 的元素非 0，那么它可以被表示。 最大子集异或和将所有数插入到线性基中，然后记答案变量为 $a$. 从高到低考虑每一位，如果 $a_i=0$, 那么 $a_i\leftarrow a_i~\mbox{xor}~A_i$, 因为如果 $A_i\not=0$, 那么异或它可以使得 $a_i=1$. 如果不异或，以后就不可能再让 $a_i=1$. 模板题目链接 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 50+50;constexpr auto MAXBITS = 64;long long a[MAXBITS];void Insert(long long ins)&#123; for(int i=MAXBITS-1;i&gt;=0;i--)&#123; if((ins&amp;(1LL&lt;&lt;i)) == 0) continue; if(a[i]) ins ^= a[i]; else&#123; for(int j=i-1;j&gt;=0;j--) if(ins&amp;(1LL&lt;&lt;j)) ins ^= a[j]; for(int j=MAXBITS-1;j&gt;i;j--) if(a[j]&amp;(1LL&lt;&lt;i)) a[j] ^= ins; a[i] = ins; return; &#125; &#125;&#125;signed main(void)&#123; int totElements; long long ins; scanf("%d", &amp;totElements); for(int i=0;i&lt;totElements;i++)&#123; scanf("%lld", &amp;ins); Insert(ins); &#125; long long ans = 0; for(int i=MAXBITS-1;i&gt;=0;i--) ans ^= a[i]; std::cout&lt;&lt;ans&lt;&lt;std::endl; return 0;&#125; 子集异或和第 $k$ 小先将所有元素插入线性基，此时我们用于保存线性基的数组 $A$ 中可能存在部分元素为 0. 我们将 $A$ 中所有 0 去掉，生成另一个数组 $B$(这个过程中不能改变 $A$ 中元素相对顺序)，这样 $B$ 中所有的元素都存在于线性基中。(以下部分地方记线性基为 $B$) 由于线性基是线性无关的，$\forall a\in\mathrm{span}(B)$ 都只有唯一一种方法选择 $B$ 中的若干个元素使得他们异或和为 $a$. 同时，$\forall (B_i)_j=1$, 不存在 $k$ 使得 $(B_k)_j=1$. 所以 $\forall j\not=i, B_i~\mbox{xor}~B_j&gt;B_i$, $\forall i&lt;|B|$, 令 $S_i=\{B_j|j\leq i\}$, $B_{i+1}&gt;\mathrm{Xorsum}(S_i)$. 如果我们需要得到第 $k$ 小的自己异或和，将 $k$ 二进制拆分，如果 $k_i=1$ ，将答案异或上 $B_i$. 需要特别注意的是，如果我们一共往线性基中插入了 $n$ 个数，而最终 $|B|&lt;n$, 说明至少一个元素可以被其他元素表示，也就是说存在一个子集异或和为 0, 这时需要令 $k\leftarrow k-1$, 然后再计算答案。 模板题目链接 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;const int MAXN = 10000+50;const int MAXQ = 10000+50;const int maxbits = 64;long long a[maxbits];std::vector&lt;long long&gt; B;void Insert(long long ins)&#123; for(int i=maxbits-1;i&gt;=0;i--)&#123; if((ins&amp;(1LL&lt;&lt;i)) == 0) continue; if(a[i]) ins ^= a[i]; else&#123; for(int j=i-1;j&gt;=0;j--) if(ins&amp;(1LL&lt;&lt;j)) ins ^= a[j]; for(int j=maxbits-1;j&gt;i;j--) if(a[j]&amp;(1LL&lt;&lt;i)) a[j] ^= ins; a[i] = ins; break; &#125; &#125;&#125;long long Query(long long kth)&#123; if(kth &gt;= (1LL&lt;&lt;B.size())) return -1; long long ans = 0; for(int i=0;i&lt;B.size();i++) if(kth&amp;(1LL&lt;&lt;i)) ans ^= B[i]; return ans;&#125;signed main(void)&#123; int totCases,totElements,totQuery,delta; long long ins,kth; scanf("%d", &amp;totCases); for(int nowCase=1;nowCase&lt;=totCases;nowCase++)&#123; memset(a,0,sizeof(a)); B.clear(); printf("Case #%d:\n", nowCase); scanf("%d", &amp;totElements); for(int i=0;i&lt;totElements;i++)&#123; scanf("%lld", &amp;ins); Insert(ins); &#125; for(int i=0;i&lt;maxbits;i++) if(a[i]) B.push_back(a[i]); delta = B.size()==totElements ? 0 : -1; //std::cout&lt;&lt;"Delta="&lt;&lt;delta&lt;&lt;std::endl; scanf("%d", &amp;totQuery); while(totQuery--)&#123; scanf("%lld",&amp;kth); printf("%lld\n", Query(kth + delta)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AT2306 Rearranging]]></title>
    <url>%2F2019%2F08%2F07%2FRearranging%2F</url>
    <content type="text"><![CDATA[有一个 $n$ 个数组成的序列 $a_i$. 高桥君会把整个序列任意排列，然后青木君可以选择两个相邻的互质的数交换位置。 高桥君希望最终序列的字典序尽量小，而青木君希望字典序尽量大。求最终序列。 考虑一个长度为 $n$ 的序列 $A$, 其中第 $i$ 项为 $A_i$. 如果存在两个数 $j&lt;i$, 满足 $A_j\perp A_i$, 那么容易看出这两个数之间的相对位置不会发生变化。 我们直接将原序列互素的数之间连无向边，最终得到一个有 $m$ 个强连通分量的图，对于其中任何一个强连通分量，如果将无向边变成有向边，那么对其拓扑排序，每次都取能取的最大的数，得到的就是这个强连通分量各个元素之间的相对位置关系。由于在排列时会控制字典序尽量小，所以对于一条无向边，我们总是将其变成小的数连向大的数的边。 将所有联通分量处理完之后，借助优先队列一次拓扑排序即可求得答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 2000+550;int num[MAXN]; bool vis[MAXN];std::vector&lt;int&gt; link[MAXN],G[MAXN];int inc[MAXN];void Dfs(const int&amp; nowAt)&#123; vis[nowAt] = true; for(const auto &amp;it : link[nowAt]) if(!vis[it])&#123; G[nowAt].push_back(it); inc[it]++; Dfs(it); &#125;&#125;signed main(void)&#123; int totNums; scanf("%d", &amp;totNums); for(int i=0;i&lt;totNums;i++) scanf("%d", num+i); std::sort(num,num+totNums); for(int i=0;i&lt;totNums;i++) for(int j=i+1;j&lt;totNums;j++) if(std::__gcd(num[i],num[j]) &gt; 1)&#123; link[i].push_back(j); link[j].push_back(i); &#125; memset(vis,false,sizeof(vis)); for(int i=0;i&lt;totNums;i++) if(!vis[i]) Dfs(i); std::priority_queue&lt;int,std::vector&lt;int&gt;,std::less&lt;int&gt;&gt; que; for(int i=0;i&lt;totNums;i++) if(inc[i] == 0) que.push(i); int nowAt; while(!que.empty())&#123; nowAt = que.top(); que.pop(); printf("%d ", num[nowAt]); for(const auto &amp;it : G[nowAt]) if(--inc[it] == 0) que.push(it); &#125; putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2015 品酒大会]]></title>
    <url>%2F2019%2F08%2F07%2FWine%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个长度为 $n$ 的字符串 $s$, 定义这个字符串两个不同后缀 $u,v$ 是 $i$ 相似的当$s_u=s_v,s_{u+1},s_{v+1},\cdots,s_{u+i}=s_{v+1}$. $s$ 中的每一个字符有一个权值 $a_i$. 对于整数 $i\in[0,n)$, 输出在 $s$ 中选择两个 $i$ 相似字符串 $u,v$ 的方案数，以及 $\max\{a_u\cdot a_v\}$ 这里两个 $i$ 相似的后缀就是这两个后缀的前缀有至少 $i$ 位是一样的，同时这两个后缀必定也 $0$ 相似，$1$ 相似，$\cdots$，$i-1$ 相似。 我们先对 $s$ 建立后缀树，然后在后缀树上 DP, 每个结点 $s$ 记录下有多少个后缀经过 $s$ ，以及这些后缀起始点权值组成的集合中的最大值，次大值，最小值，次小值。如果 $t$ 个后缀经过 $s$, 那么对这一段区间 $(s_{totlen}-s_{len},s_{totlen}]$ 的贡献就是 $\frac{t(t-1)}2$. 同时根据记录的几个值求出最大权值积(注意负数)，在这个区间上取 $\max$. 这些信息可以用两个差分数组维护。 最终将两个差分数组从后往前扫一遍，答案倒序输出即可。 总时间复杂度为 $O(N)$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 300000+500;constexpr auto MAXK = 28;constexpr auto $ = MAXK - 1;//Suffix Treestruct Node&#123; int start,len,totLen; long long rk1,rk2,rk_1,rk_2,appear; Node *link,*ch[MAXK]; Node(void) &#123; rk_1 = rk_2 = INT64_MAX; rk1 = rk2 = INT64_MIN; memset(ch,0,sizeof(ch)); link = nullptr; &#125; Node(const int&amp; ist, const int&amp; ilen) : start(ist), len(ilen) &#123; rk_1 = rk_2 = INT64_MAX; rk1 = rk2 = INT64_MIN; memset(ch,0,sizeof(ch)); link = nullptr; &#125;&#125;*t0,*nowAt,*virt;int s[MAXN],remain,totLen;void Build(void)&#123; totLen = remain = 0; nowAt = t0 = new Node(-1,1); virt = new Node();&#125;void Attend(const int&amp; add)&#123; s[totLen++] = add; ++remain; for(Node* last = virt,*t; remain;)&#123; while(nowAt-&gt;ch[s[totLen-remain]] != nullptr &amp;&amp; nowAt-&gt;ch[s[totLen-remain]]-&gt;len &lt; remain)&#123; t = nowAt-&gt;ch[s[totLen-remain]]; nowAt = t; remain -= t-&gt;len; &#125; Node*&amp; v = nowAt-&gt;ch[s[totLen-remain]]; int endChar_v = v==nullptr?MAXK-2:s[v-&gt;start+remain-1]; if(v == nullptr || endChar_v == add)&#123; last-&gt;link = nowAt; last = nowAt; if(v == nullptr) v = new Node(totLen-remain,INT_MAX); else break; &#125; else &#123; Node* split = new Node(v-&gt;start,remain-1); v-&gt;start += remain-1; v-&gt;len -= remain-1; split-&gt;ch[endChar_v] = v; split-&gt;ch[add] = new Node(totLen-1,INT_MAX); last-&gt;link = v = split; last = split; &#125; if(nowAt == t0) --remain; else nowAt = nowAt-&gt;link; &#125;&#125;void Pretreatment(Node* nowAt = t0)&#123; if(nowAt == nullptr) return; int ch = 0; nowAt-&gt;appear = 0; for(int i=0;i&lt;MAXK;++i) if(nowAt-&gt;ch[i] != nullptr)&#123; Pretreatment(nowAt-&gt;ch[i]); nowAt-&gt;appear += nowAt-&gt;ch[i]-&gt;appear; ++ch; &#125; if(ch == 0)&#123; nowAt-&gt;len = totLen-nowAt-&gt;start; nowAt-&gt;appear = 1; &#125;&#125;void Pretreatment2(long long *val, Node* nowAt = t0)&#123; if(nowAt == nullptr) return; int ch = 0; for(int i=0;i&lt;MAXK;++i) if(nowAt-&gt;ch[i] != nullptr)&#123; nowAt-&gt;ch[i]-&gt;totLen = nowAt-&gt;totLen + nowAt-&gt;ch[i]-&gt;len; Pretreatment2(val,nowAt-&gt;ch[i]); if(nowAt-&gt;ch[i]-&gt;rk1 &gt; nowAt-&gt;rk1)&#123; nowAt-&gt;rk2 = nowAt-&gt;rk1; nowAt-&gt;rk1 = nowAt-&gt;ch[i]-&gt;rk1; &#125; else nowAt-&gt;rk2 = std::max(nowAt-&gt;rk2, nowAt-&gt;ch[i]-&gt;rk1); nowAt-&gt;rk2 = std::max(nowAt-&gt;rk2, nowAt-&gt;ch[i]-&gt;rk2); if(nowAt-&gt;ch[i]-&gt;rk_1 &lt; nowAt-&gt;rk_1)&#123; nowAt-&gt;rk_2 = nowAt-&gt;rk_1; nowAt-&gt;rk_1 = nowAt-&gt;ch[i]-&gt;rk_1; &#125; else nowAt-&gt;rk_2 = std::min(nowAt-&gt;rk_2, nowAt-&gt;ch[i]-&gt;rk_1); nowAt-&gt;rk_2 = std::min(nowAt-&gt;rk_2, nowAt-&gt;ch[i]-&gt;rk_2); ++ch; &#125; if(ch == 0) nowAt-&gt;rk_1 = nowAt-&gt;rk1 = val[totLen-nowAt-&gt;totLen];&#125;char ReadChar(void);void Dfs(Node*);int maxR;long long val[MAXN];long long sum[MAXN],max[MAXN];signed main(void)&#123; int totNums; scanf("%d", &amp;totNums); Build(); for(int i=0;i&lt;totNums;i++) Attend(ReadChar()); Attend($); Pretreatment(); for(int i=0;i&lt;totNums;i++) scanf("%lld", val+i); Pretreatment2(val); std::fill(max,max+MAXN,INT64_MIN); Dfs(t0); long long ssum = 0,mmax = INT64_MIN; std::stack&lt;std::pair&lt;long long,long long&gt;&gt; St; for(int i=totNums-1;i&gt;=0;i--)&#123; ssum += sum[i]; mmax = std::max(mmax, max[i]); St.push(std::make_pair(ssum,(mmax==INT64_MIN?0:mmax))); &#125; printf("%lld %lld\n", (long long)totNums*(totNums-1)&gt;&gt;1, St.top().second); St.pop(); while(!St.empty())&#123; printf("%lld %lld\n", St.top().first, St.top().second); St.pop(); &#125; return 0;&#125;void Dfs(Node* nowAt)&#123; if(nowAt == nullptr || nowAt-&gt;appear &lt;= 1) return; maxR = std::max(maxR, nowAt-&gt;totLen); long long deltaCnt = nowAt-&gt;appear*(nowAt-&gt;appear-1)&gt;&gt;1, D; if(nowAt-&gt;rk_2 == INT64_MAX || nowAt-&gt;rk2 == INT64_MIN)&#123; if(nowAt-&gt;rk_2 == INT64_MAX &amp;&amp; nowAt-&gt;rk2 == INT64_MIN) D = nowAt-&gt;rk_1*nowAt-&gt;rk1; else if(nowAt-&gt;rk_2 == INT64_MAX) D = nowAt-&gt;rk1*nowAt-&gt;rk2; else D = nowAt-&gt;rk_1*nowAt-&gt;rk_2; &#125; else D = std::max(nowAt-&gt;rk1*nowAt-&gt;rk2, nowAt-&gt;rk_1*nowAt-&gt;rk_2); if(nowAt-&gt;totLen-nowAt-&gt;len &gt;= 0) sum[nowAt-&gt;totLen-nowAt-&gt;len] -= deltaCnt; sum[nowAt-&gt;totLen] += deltaCnt; max[nowAt-&gt;totLen] = std::max(max[nowAt-&gt;totLen], D); for(int i=0;i&lt;MAXK;++i) if(nowAt-&gt;ch[i] != nullptr) Dfs(nowAt-&gt;ch[i]);&#125;char ReadChar(void)&#123; char in; do in = getchar(); while(!('a'&lt;=in&amp;&amp;in&lt;='z')); return in-'a';&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀树</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小割树]]></title>
    <url>%2F2019%2F08%2F06%2FGomory-Hu_Tree%2F</url>
    <content type="text"><![CDATA[最小割树(Gomory-Hu Tree)可以用于解决如下问题： 给定一个 $n$ 个点 $m$ 条边的无向连通图，多次询问两点之间的最小割。 思想在最小割树中，我们将两点之间的最小割(最大流)转换为树上两点之间的最小权值。 考虑图 $G$ 中两点 $u\to v$ 的最大流流量为 $w$. 那么利用这个最小割将图划分为两个割集 $S,T$, 那么 $\forall i\in S,j\in T$, 原图 $G$ 中 $i\to j$ 的最大流流量一定不大于 $w$. 流程假定我们目前需要处理的点集为 $S$. 如果 $S$ 中元素不足两个，那么直接退出。 任取 $i\in S,j\in S,i\not=j$, 算出 $i\to j$ 在原图 $G$ 中的最大流 $w$, 在新图 $G^\prime$ 中连边 $i\to j$, 边权为 $w$. 此时将所有从 $i$ 出发可以到达的点划分为一个集合，以 $S$ 为全集的补集作为另外一个集合。 递归地处理这两个集合中的点。 最终得到的 $G^\prime$ 一定是一棵树，在上面求出两个点的带权 LCA, 就是他们在原图 $G$ 中的最小割。 模板模板题目链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 1500;constexpr auto MAXK = 20;struct Edge&#123; int fr,to,residual,cap; Edge()&#123;&#125; Edge(const int&amp; ifr,const int&amp; ito,const int&amp; ire,const int&amp; icap) : fr(ifr),to(ito),residual(ire),cap(icap) &#123;&#125;&#125;;std::vector&lt;Edge&gt;edges;std::vector&lt;int&gt; G[MAXN];void AddEdge(const int&amp; fr,const int&amp; to,const int&amp; res,const int&amp; cap)&#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr,to,res,cap)); G[to].push_back(edges.size()); edges.push_back(Edge(to,fr,res,cap));&#125;int cur[MAXN],dis[MAXN];bool BFS(const int&amp; s,const int&amp; t)&#123; std::queue&lt;int&gt; que; que.push(s); std::fill(dis,dis+MAXN,INT_MAX); dis[s] = 0; int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(int i=0;i&lt;G[nowAt].size();i++)&#123; const Edge&amp; it = edges[G[nowAt][i]]; if(it.residual&gt;0 &amp;&amp; dis[it.to]&gt;dis[nowAt]+1)&#123; dis[it.to] = dis[nowAt]+1; que.push(it.to); &#125; &#125; &#125; return dis[t] &lt; INT_MAX;&#125;int Dinic(const int&amp; nowAt,const int&amp; t,int maxFlow)&#123; if(nowAt==t || maxFlow&lt;=0) return maxFlow; int flow=0,deltaFlow; for(int&amp; i=cur[nowAt];i&lt;G[nowAt].size();i++)&#123; Edge&amp; it = edges[G[nowAt][i]]; if(dis[nowAt]+1==dis[it.to] &amp;&amp; 0&lt;(deltaFlow=Dinic(it.to,t,std::min(it.residual,maxFlow))))&#123; it.residual -= deltaFlow; edges[G[nowAt][i]^1].residual += deltaFlow; flow += deltaFlow; maxFlow -= deltaFlow; if(maxFlow &lt;= 0) break; &#125; &#125; return flow;&#125;int MaxFlow(const int&amp; s,const int&amp; t)&#123; int ans = 0; while(BFS(s,t))&#123; memset(cur,0,sizeof(cur)); ans += Dinic(s,t,INT_MAX); &#125; return ans;&#125;struct Line&#123; int to,len; Line()&#123;&#125; Line(const int&amp; ito,const int&amp; ilen) : to(ito),len(ilen)&#123;&#125; &#125;;std::vector&lt;Line&gt; ch[MAXN]; int l[MAXN],r[MAXN], totNodes;void AddEdge(const int&amp; fr,const int&amp; to,const int&amp; len)&#123; ch[fr].push_back(Line(to,len)); ch[to].push_back(Line(fr,len));&#125;void Build(int* beg,int* end)&#123; if(end-beg &lt;= 1) return; for(auto &amp;it : edges) it.residual = it.cap; AddEdge(*beg, *(beg+1), MaxFlow(*beg,*(beg+1))); int len = 0; for(int* i=beg;i&lt;end;i++) if(dis[*i] &lt; INT_MAX) l[len++] = *i; else r[i-beg-len] = *i; for(int i=0;i&lt;len;i++) *(beg+i) = l[i]; for(int i=len;i&lt;(end-beg);i++) *(beg+i) = r[i-len]; Build(beg,beg+len); Build(beg+len,end);&#125;int up[MAXN][MAXK],min[MAXN][MAXK],depth[MAXN];void Dfs(const int&amp; nowAt,const int fa=0,const int len=0)&#123; up[nowAt][0] = fa; min[nowAt][0] = len; depth[nowAt] = depth[fa]+1; for(int i=1;i&lt;MAXK;i++)&#123; up[nowAt][i] = up[up[nowAt][i-1]][i-1]; min[nowAt][i] = std::min(min[nowAt][i-1], min[up[nowAt][i-1]][i-1]); &#125; for(const auto &amp;it : ch[nowAt]) if(it.to != fa) Dfs(it.to,nowAt,it.len);&#125;int Query(int a,int b)&#123; if(depth[a] &lt; depth[b]) std::swap(a,b); int ans = INT_MAX; for(int i=MAXK-1;i&gt;=0;i--) if(depth[up[a][i]] &gt;= depth[b])&#123; ans = std::min(ans,min[a][i]); a = up[a][i]; &#125; if(a==b) return ans; for(int i=MAXK-1;i&gt;=0;i--) if(up[a][i] != up[b][i])&#123; ans = std::min(ans,std::min(min[a][i],min[b][i])); a = up[a][i]; b = up[b][i]; &#125; return std::min(ans,std::min(*min[a],*min[b]));&#125;int num[MAXN];signed main(void)&#123; int totEdges,totQuery,fr,to,res; scanf("%d%d", &amp;totNodes,&amp;totEdges); ++totNodes; for(int i=0;i&lt;totEdges;i++)&#123; scanf("%d%d%d", &amp;fr,&amp;to,&amp;res); ++fr; ++to; AddEdge(fr,to,res,res); &#125; for(int i=1;i&lt;=totNodes;i++) num[i-1] = i; Build(num,num+totNodes); Dfs(1); scanf("%d", &amp;totQuery); while(totQuery--)&#123; scanf("%d%d", &amp;fr,&amp;to); ++fr; ++to; printf("%d\n", Query(fr,to)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上下界网络流问题]]></title>
    <url>%2F2019%2F08%2F06%2FNetworkFlowSS%2F</url>
    <content type="text"><![CDATA[在一个网络流问题中，如果限定每条边 $i$ 流量必须满足不低于下界 $d_i$, 同时又不高于上界 $u_i$, 那么这就是一个含有上下界的网络流问题，满足条件的流称为 可行流。可以通过特殊方法建图，转换成为普通的网络流问题。 无源汇可行流模型一个网络，求出一个流，使得每条边 $i$ 的流量必须不小于 $d_i$ 且不大于 $u_i$. 每个点必须满足总流入量 $=$ 总流出量(流量守恒)(这个流的特点是循环往复，无始无终). 求解方法首先，在建出原网络之后，将每条边 $i$ 的容量设置为 $u_i-d_i$. 这就相当于默认了它已经流了 $d_i$ 流量。这样构造出来的流不一定是可行流，我们需要在残量网络中不断调整，直到可行为止。 处理出来一个数组 $f_i$ 代表 $i$ 的入出流量之差，如果 $f_i0$ 说明这里少了 $f_i$ 的流量。如果 $f_i=0$ 说明这个地方符合要求，不需要调整。建立源点 $s$ 和汇点 $t$ 用于给出/处理掉调整时的流量, 对于第一种和第二种情况， 连边 $i\to t$, 容量为 $-f_i$. 连边 $s\to i$, 容量为 $f_i$. 在这个有源有汇的新图上面跑一次最大流，如果新加进来的这些边流量全部流满了，说明将当前调整应用到原图上就可以抵消掉之前多的/少的流量，使其成为一个可行流。 模板题目链接 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;const int MAXN = 1000;const int MAXM = MAXN*MAXN;struct Edge&#123; int fr,to,ID; long long min,residual; Edge()&#123;&#125; Edge(const int&amp; ifr,const int&amp; ito,const long long&amp; imin,const long long&amp; ire,const int&amp; iID) : fr(ifr),to(ito),min(imin),residual(ire),ID(iID) &#123;&#125;&#125;;int s=MAXN-1,t=MAXN-2;std::vector&lt;Edge&gt; edges;std::vector&lt;int&gt; G[MAXN];void AddEdge(const int&amp; fr,const int&amp; to,const long long&amp; min,const long long&amp; res,const int&amp; ID)&#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr,to,min,res,ID)); G[to].push_back(edges.size()); edges.push_back(Edge(to,fr,0,0,-ID));&#125;int cur[MAXN],dis[MAXN];bool BFS(void)&#123; std::queue&lt;int&gt; que; que.push(s); std::fill(dis,dis+MAXN,INT_MAX); dis[s] = 0; int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(int i=0;i&lt;G[nowAt].size();i++)&#123; const Edge&amp; it = edges[G[nowAt][i]]; if(it.residual&gt;0 &amp;&amp; dis[it.to]&gt;dis[nowAt]+1)&#123; dis[it.to] = dis[nowAt]+1; que.push(it.to); &#125; &#125; &#125; return dis[t]&lt;INT_MAX;&#125;long long Dinic(const int&amp; nowAt,long long maxFlow)&#123; if(nowAt==t || maxFlow&lt;=0) return maxFlow; long long flow=0,deltaFlow; for(int&amp; i=cur[nowAt]; i&lt;G[nowAt].size();i++)&#123; Edge&amp; it = edges[G[nowAt][i]]; if(dis[nowAt]+1==dis[it.to] &amp;&amp; 0&lt;(deltaFlow=Dinic(it.to,std::min(maxFlow,it.residual))))&#123; it.residual -= deltaFlow; edges[G[nowAt][i]^1].residual += deltaFlow; maxFlow -= deltaFlow; flow += deltaFlow; if(maxFlow &lt;= 0)break; &#125; &#125; return flow;&#125;long long MaxFlow(void)&#123; long long ans = 0; while(BFS())&#123; memset(cur,0,sizeof(cur)); ans += Dinic(s,INT64_MAX); &#125; return ans;&#125;signed main(void)&#123; int totCases,totNums,totEdges,fr,to; long long min,max; long long flowtot[MAXN],ans[MAXM],sum; scanf("%d", &amp;totCases); while(totCases--)&#123; scanf("%d%d", &amp;totNums,&amp;totEdges); &#123; std::vector&lt;Edge&gt; T; std::swap(T,edges); for(int i=0;i&lt;totNums;i++)&#123; std::vector&lt;int&gt; TT; std::swap(TT,G[i]); &#125; std::vector&lt;int&gt; TTT,TTTT; std::swap(TTT,G[s]); std::swap(TTTT,G[t]); memset(flowtot,0,sizeof(flowtot)); memset(ans,0,sizeof(ans)); &#125; for(int i=0;i&lt;totEdges;i++)&#123; scanf("%d%d%lld%lld", &amp;fr,&amp;to,&amp;min,&amp;max); --fr;--to; flowtot[fr] -= min; flowtot[to] += min; AddEdge(fr,to,min,max-min,i+1); &#125; sum = 0; for(int i=0;i&lt;totNums;i++) if(flowtot[i] &lt; 0) AddEdge(i,t,0,-flowtot[i],0); else &#123; sum += flowtot[i]; AddEdge(s,i,0,flowtot[i],0); &#125; //std::cout&lt;&lt;sum&lt;&lt;std::endl; if((max=MaxFlow()) == sum)&#123; puts("YES"); for(int i=0;i&lt;totNums;i++) for(int j=0;j&lt;G[i].size();j++)&#123; const Edge&amp; it = edges[G[i][j]]; if(it.ID &gt; 0) ans[it.ID] = it.min + edges[G[i][j]^1].residual; &#125; for(int i=1;i&lt;=totEdges;i++) printf("%lld\n", ans[i]); &#125; else puts("NO"); //std::cout&lt;&lt;max&lt;&lt;std::endl; if(totCases) putchar('\n'); &#125; return 0;&#125; 有源汇可行流模型一个网络，源点为 $s$, 汇点为 $t$. 求出一个流，使得每条边 $i$ 的流量必须不小于 $d_i$ 且不大于 $u_i$. 除源汇外每个点必须满足总流入量 $=$ 总流出量. 求解方法在这个网络中，源点流出去的流量等于汇点流入的流量，如果我们建立一条边 $t\to s$, 上界为 $\infty$, 那么所有的流量就又形成了一个循环，问题就转换为了无源汇可行流。 有源汇最大流模型一个网络，源点为 $s$, 汇点为 $t$. 求出一个流，使得每条边 $i$ 的流量必须不小于 $d_i$ 且不大于 $u_i$. 除源汇外每个点必须满足总流入量 $=$ 总流出量. 求这个网络的最大流。 求解方法先求一遍有源汇可行流，这个时候得到的流是可行的，流量为 $t\to s$ 反向边的残量。 我们在这个基础之上，继续进行增广。由于现在所有的边都已经满足下界，所以只用记一个变量表示当前容量比下界多了多少，我们可以直接将它看成剩余容量，求 $s\to t$ 最大流，最终流量再加上原先可行流流量即可。 模板题目地址 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 50003+500;struct Edge&#123; int fr,to; long long residual; Edge()&#123;&#125; Edge(const int&amp; ifr,const int&amp; ito,const long long&amp; ire) : fr(ifr),to(ito),residual(ire) &#123;&#125;&#125;;std::vector&lt;Edge&gt; edges;std::vector&lt;int&gt; G[MAXN];int ss=MAXN-2,tt=MAXN-1;void AddEdge(const int&amp; fr,const int&amp; to,const long long&amp; res)&#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr,to,res)); G[to].push_back(edges.size()); edges.push_back(Edge(to,fr,0));&#125;int cur[MAXN],dis[MAXN];bool BFS(const int&amp; s,const int&amp; t)&#123; std::fill(dis,dis+MAXN,INT_MAX); dis[s] = 0; std::queue&lt;int&gt; que; que.push(s); int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(int i=0;i&lt;G[nowAt].size();i++)&#123; const Edge&amp; it = edges[G[nowAt][i]]; if(it.residual&gt;0 &amp;&amp; dis[it.to]&gt;dis[nowAt]+1)&#123; dis[it.to] = dis[nowAt]+1; que.push(it.to); &#125; &#125; &#125; return dis[t] &lt; INT_MAX;&#125;long long Dinic(const int&amp; nowAt, const int&amp; t,long long maxFlow)&#123; if(nowAt==t || maxFlow&lt;=0) return maxFlow; long long flow=0,deltaFlow; for(int &amp;i=cur[nowAt];i&lt;G[nowAt].size();i++)&#123; auto&amp; it = edges[G[nowAt][i]]; if(dis[nowAt]+1==dis[it.to] &amp;&amp; 0&lt;(deltaFlow=Dinic(it.to,t,std::min(maxFlow,it.residual))))&#123; it.residual -= deltaFlow; edges[G[nowAt][i]^1].residual += deltaFlow; flow += deltaFlow; maxFlow -= deltaFlow; if(maxFlow &lt;= 0) break; &#125; &#125; return flow;&#125;long long MaxFlow(const int&amp; s,const int&amp; t)&#123; long long ans = 0; while(BFS(s,t))&#123; memset(cur,0,sizeof(cur)); ans += Dinic(s,t,INT64_MAX); &#125; return ans;&#125;signed main(void)&#123; long long totFlow[MAXN]=&#123;&#125;,sum=0; int totNodes,s,t,a,b,totEdges; long long min,max; scanf("%d%d%d%d", &amp;totNodes,&amp;totEdges,&amp;s,&amp;t); for(int i=0;i&lt;totEdges;i++)&#123; scanf("%d%d%lld%lld", &amp;a,&amp;b,&amp;min,&amp;max); totFlow[a] -= min; totFlow[b] += min; AddEdge(a,b,max-min); &#125; for(int i=1;i&lt;=totNodes;i++) if(totFlow[i] &lt; 0) AddEdge(i,tt,-totFlow[i]); else&#123; AddEdge(ss,i,totFlow[i]); sum += totFlow[i]; &#125; AddEdge(t,s,INT64_MAX); if(MaxFlow(ss,tt) != sum)&#123; puts("please go home to sleep"); goto END; &#125; printf("%lld\n", edges.end()-&gt;residual+MaxFlow(s,t)); END: return 0;&#125; 有源汇最小流模型一个网络，源点为 $s$, 汇点为 $t$. 求出一个流，使得每条边 $i$ 的流量必须不小于 $d_i$ 且不大于 $u_i$. 除源汇外每个点必须满足总流入量 $=$ 总流出量. 求这个网络的最小流。 求解方法与有源汇最大流类似。 还是先求可行流，这个可行流同样不一定是最小流。我们求出 $t\to s$ 最大流，用 $t\to s$ 反向边容量减去它就是答案。 这种做法是正确的，因为我们在求出可行流的时候，每条边的流量都是相对于最小流量而言的，它的反向边代表的就是可以回流多少流量而仍然满足下界限制。这个时候我们 $t\to s$ 最大流，本质上就是将原本的流量缩到最小，而求出可行流之后每条边无论怎么调整，流量都是在限定在可行的范围内，因此可以求出正确的答案。 注意在求 $t\to s$ 最大流时需要先将之前添加的一条 $t\to s$ 容量 $\infty$ 的边删去。 模板题目链接 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 700;struct Edge&#123; int fr,to; long long residual; Edge()&#123;&#125; Edge(const int&amp; ifr,const int&amp; ito,const long long&amp; ire) : fr(ifr),to(ito),residual(ire) &#123;&#125;&#125;;std::vector&lt;Edge&gt; edges;std::vector&lt;int&gt; G[MAXN];int ss=MAXN-2,tt=MAXN-1;void AddEdge(const int&amp; fr,const int&amp; to,const long long&amp; res)&#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr,to,res)); G[to].push_back(edges.size()); edges.push_back(Edge(to,fr,0));&#125;int cur[MAXN],dis[MAXN];bool BFS(const int&amp; s,const int&amp; t)&#123; std::fill(dis,dis+MAXN,INT_MAX); dis[s] = 0; std::queue&lt;int&gt; que; que.push(s); int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(int i=0;i&lt;G[nowAt].size();i++)&#123; const Edge&amp; it = edges[G[nowAt][i]]; if(it.residual&gt;0 &amp;&amp; dis[it.to]&gt;dis[nowAt]+1)&#123; dis[it.to] = dis[nowAt]+1; que.push(it.to); &#125; &#125; &#125; return dis[t] &lt; INT_MAX;&#125;long long Dinic(const int&amp; nowAt, const int&amp; t,long long maxFlow)&#123; if(nowAt==t || maxFlow&lt;=0) return maxFlow; long long flow=0,deltaFlow; for(int &amp;i=cur[nowAt];i&lt;G[nowAt].size();i++)&#123; auto&amp; it = edges[G[nowAt][i]]; if(dis[nowAt]+1==dis[it.to] &amp;&amp; 0&lt;(deltaFlow=Dinic(it.to,t,std::min(maxFlow,it.residual))))&#123; it.residual -= deltaFlow; edges[G[nowAt][i]^1].residual += deltaFlow; flow += deltaFlow; maxFlow -= deltaFlow; if(maxFlow &lt;= 0) break; &#125; &#125; return flow;&#125;long long MaxFlow(const int&amp; s,const int&amp; t)&#123; long long ans = 0; while(BFS(s,t))&#123; memset(cur,0,sizeof(cur)); ans += Dinic(s,t,INT64_MAX); &#125; return ans;&#125;signed main(void)&#123; long long totFlow[MAXN]=&#123;&#125;,sum=0; int totNodes,s,t,a,b,totEdges; long long min,max; scanf("%d%d%d%d", &amp;totNodes,&amp;totEdges,&amp;s,&amp;t); for(int i=0;i&lt;totEdges;i++)&#123; scanf("%d%d%lld%lld", &amp;a,&amp;b,&amp;min,&amp;max); totFlow[a] -= min; totFlow[b] += min; AddEdge(a,b,max-min); &#125; for(int i=1;i&lt;=totNodes;i++) if(totFlow[i] &lt; 0) AddEdge(i,tt,-totFlow[i]); else&#123; AddEdge(ss,i,totFlow[i]); sum += totFlow[i]; &#125; AddEdge(t,s,INT64_MAX); if(MaxFlow(ss,tt) != sum)&#123; puts("please go home to sleep"); goto END; &#125; sum = edges[edges.size()-1].residual; edges.pop_back();edges.pop_back(); G[s].pop_back(); G[t].pop_back(); printf("%lld\n", sum-MaxFlow(t,s)); END: return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[士兵占领]]></title>
    <url>%2F2019%2F08%2F06%2FWeilinWONG%2F</url>
    <content type="text"><![CDATA[题目链接 有一个 $M\times N$ 的棋盘，有的格子是障碍。现在你要选择一些格子来放置一些士兵，一个格子里最多可以放置一个士兵，障碍格里不能放置士兵。我们称这些士兵占领了整个棋盘当满足第 $i$ 行至少放置了 $L_i$ 个士兵, 第 $j$ 列至少放置了 $C_j$ 个士兵。现在你的任务是要求使用最少个数的士兵来占领整个棋盘。 建立源点和汇点 $s,t$. 拆点。对于一个点 $(i,j)$, 拆为 $(i,j)_1$ 和 $(i,j)_2$ 两个点，如果这个点不是障碍，那么其中有一条边 $(i,j)_1\to(i,j)_2$ 容量(上界)为 1. 对于每一行最右边的点，从 $s$ 向其连边 $s\to(i,N)_1$, 下界为 $L_i$, 上界为 $\infty$. 对于每一列最下边的点，将其与 $t$ 连边 $(i,j)_2\to t$, 下界为 $C_j$, 上界为 $\infty$. 之后，我们将同一行、同一列的点依次串起来 $(i,j)_1\to (i,j-1)_1$, $(i,j)_2\to (i+1,j)_2$, 容量为 $\infty$. 这样，我们模型中走过一条边从 $(i,j)_1$ 到 $(i,j)_2$ 就说明这个点有一个士兵。在这个模型上使用上下界最小流即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 300+5;constexpr auto MAXM = 300+5;constexpr auto MAXT = MAXN*MAXM+50;constexpr auto GG = "JIONG!";constexpr auto Infty = MAXT+500;struct Edge&#123; int fr,to; int residual; Edge()&#123;&#125; Edge(const int&amp; ifr,const int&amp; ito,const int&amp; ire) : fr(ifr),to(ito),residual(ire) &#123;&#125;&#125;;std::vector&lt;int&gt; G[MAXT];std::vector&lt;Edge&gt; edges;void AddEdge(const int&amp; fr,const int&amp; to,const int &amp;res)&#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr,to,res)); G[to].push_back(edges.size()); edges.push_back(Edge(to,fr,0)); //printf("%d-&gt;%d res=%d\n", fr,to,res);&#125;int cur[MAXT],dis[MAXT];bool BFS(const int&amp; s,const int&amp; t)&#123; std::fill(dis,dis+MAXT,INT_MAX); dis[s] = 0; std::queue&lt;int&gt; que; que.push(s); int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(int i=0;i&lt;G[nowAt].size();i++)&#123; const Edge&amp; it = edges[G[nowAt][i]]; if(it.residual&gt;0 &amp;&amp; dis[it.to]&gt;dis[nowAt]+1)&#123; dis[it.to] = dis[nowAt] + 1; que.push(it.to); &#125; &#125; &#125; return dis[t] &lt; INT_MAX;&#125;int Dinic(const int&amp; nowAt,const int&amp; t,int maxFlow)&#123; if(nowAt==t || maxFlow&lt;=0) return maxFlow; int flow=0,deltaFlow; for(int&amp; i=cur[nowAt];i&lt;G[nowAt].size();i++)&#123; Edge&amp; it = edges[G[nowAt][i]]; if(dis[nowAt]+1==dis[it.to] &amp;&amp; 0&lt;(deltaFlow=Dinic(it.to,t,std::min(it.residual,maxFlow))))&#123; it.residual -= deltaFlow; edges[G[nowAt][i]^1].residual += deltaFlow; maxFlow -= deltaFlow; flow += deltaFlow; if(maxFlow &lt;= 0) break; &#125; &#125; return flow;&#125;int MaxFlow(const int&amp; s,const int&amp; t)&#123; int ans = 0; while(BFS(s,t))&#123; memset(cur,0,sizeof(cur)); ans += Dinic(s,t,INT_MAX); &#125; return ans;&#125;signed main(void)&#123; constexpr int s = MAXT-1, t = MAXT-2, ss = MAXT-3, tt = MAXT-4; int totLine,totList,tot,minLine[MAXT]=&#123;&#125;,minList[MAXT]=&#123;&#125;; int totFlow[MAXT]=&#123;&#125;, fr,to,pos,sum=0,x,y; bool avaliable[MAXN][MAXM]; memset(avaliable,true,sizeof(avaliable)); scanf("%d%d%d", &amp;totLine,&amp;totList,&amp;tot); for(int i=0;i&lt;totLine;i++) scanf("%d", minLine+i); for(int i=0;i&lt;totList;i++) scanf("%d", minList+i); for(int i=0;i&lt;tot;i++)&#123; scanf("%d%d", &amp;x,&amp;y); avaliable[y-1][x-1] = false; &#125; for(int i=0;i&lt;totLine;i++)&#123; pos = totList*i+totList-1&lt;&lt;1; AddEdge(s,pos,Infty-minLine[i]); totFlow[s] -= minLine[i]; totFlow[pos] += minLine[i]; &#125; for(int i=0;i&lt;totList;i++)&#123; pos = ((totLine-1)*totList+i&lt;&lt;1)|1; AddEdge(pos,t,Infty-minList[i]); totFlow[pos] -= minList[i]; totFlow[t] += minList[i]; &#125; for(int i=0;i&lt;totLine;i++) for(int j=0;j&lt;totList;j++) if(avaliable[i][j])&#123; fr = i*totList+j&lt;&lt;1; to = fr|1; AddEdge(fr,to,1); &#125; for(int i=0;i&lt;totLine;i++) for(int j=1;j&lt;totList;j++)&#123; fr = i*totList+j; to = fr-1; fr &lt;&lt;= 1; to &lt;&lt;= 1; AddEdge(fr,to,Infty); &#125; for(int i=1;i&lt;totLine;i++) for(int j=0;j&lt;totList;j++)&#123; fr = (i-1)*totLine+j; to = i*totLine+j; fr = (fr&lt;&lt;1)|1; to = (to&lt;&lt;1)|1; AddEdge(fr,to,Infty); &#125; for(int i=0;i&lt;(totLine*totList&lt;&lt;1);i++) if(totFlow[i] &lt; 0) AddEdge(i,tt,-totFlow[i]); else&#123; AddEdge(ss,i,totFlow[i]); sum += totFlow[i]; &#125; for(int i=MAXT-2;i&lt;MAXT;i++) if(totFlow[i] &lt; 0) AddEdge(i,tt,-totFlow[i]); else&#123; AddEdge(ss,i,totFlow[i]); sum += totFlow[i]; &#125; AddEdge(t,s,Infty); //std::cout&lt;&lt;sum&lt;&lt;std::endl; if(MaxFlow(ss,tt) != sum &amp;&amp; false)&#123; puts(GG); goto END; &#125; sum = edges[edges.size()-1].residual; //std::cout&lt;&lt;sum&lt;&lt;std::endl; edges.pop_back(); edges.pop_back(); G[t].pop_back(); G[s].pop_back(); printf("%d\n", sum-MaxFlow(t,s)); END: return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[狄利克雷卷积]]></title>
    <url>%2F2019%2F08%2F03%2FDirichlet%2F</url>
    <content type="text"><![CDATA[狄利克雷卷积(Dirichlet product) 是数论函数的重要运算之一。 数论函数在数论上，数论函数是定义域为正整数，陪域为复数的函数。 运算数论函数的加法为逐项相加 (f+g)(n)=f(n)+g(n)数论函数数乘是将这个数与函数每一项相乘 (xf)(n)=x\cdot f(n)狄利克雷卷积狄利克雷卷积是定义在两个数论函数上的运算($*$)： \begin{align}(f*g)(n)=&\sum_{i|n}f(i)g\left(\frac ni\right)\\ (f*g)(n)=&\sum_{ij=n}f(i)g(j)\end{align}性质交换律 f*g=g*f结合律 (f*g)*h=f*(g*h)因为 \sum_{(ij)k=n}(f(i)g(j))\ h(k)=\sum_{i(jk)}f(i)\ (g(j)h(k))分配律 (f+g)*h=f*h+g*h因为 \sum_{ij=n}(f(i)+g(i))h(j)=\sum_{ij=n}f(i)h(j)+g(i)h(j)=\sum_{ij=n}f(i)h(j)+\sum_{ij=n}g(i)h(j)同时亦有 (xf)*g=x(f*g)因为 \sum_{ij=n}xf(i)g(j)=x\sum_{ij=n}f(i)g(j)单位元 \exists\epsilon*f=f \epsilon(n)=[n=1]逆元如果一个数论函数 $f$ 满足 $f(1)\not=0$, 那么存在函数 $g$ 使得 $f*g=\epsilon$. 构造方法如下： g(n)=\frac 1{f(1)}\left([n=1]-\sum_{i|n,i\not=1}f(i)g\left(\frac ni\right)\right) \begin{align}\sum_{i|n}f(i)g\left(\frac ni\right)&=f(1)g(n)+\sum_{i|n,i\not=1}f(i)g\left(\frac ni\right)\\ &=[n=1] \end{align}积性函数如果一个数论函数 $f$ 满足当 $n\perp m$ 时 f(nm)=f(n)f(m)那么称 $f$ 为 积性函数，特别地，如果 $n\not\perp m$ 时也满足，则称 $f$ 为 完全积性函数。 完全积性函数一些常见的完全积性函数包括 \epsilon(n)=[n=1]\\ id(n)=n\\ id^k(n)=n^k\\ I(n)=1这些函数看上去非常简单，很容易看出它是完全积性的，而且通常可以很快求得他们的函数值甚至是前缀和，这样就可以利用他们与其他的函数一同参与卷积运算，在莫比乌斯反演或者杜教筛的时候派上用场。 积性函数除了这些完全积性函数，一些常见的积性函数包括 \sigma_0(n)=\sum_i[i|n]\\ \varphi(n)=\sum_i[\gcd(i,n)=1]\\ \mu(n)=\begin{cases}1&\mbox{if}~n=1\\ (-1)^k&\mbox{if}~n=\prod_{i=1}^kp_i\\ 0&\mbox{Otherwise} \end{cases}性质两个积性函数的狄利克雷卷积是积性函数。 记 $t=f*g$. 如果 $n\perp m$, 那么 \begin{align}t(nm)&=\sum_{d|nm}f(d)g\left(\frac {nm}d\right)\\ &=\sum_{a|n,b|m}f(ab)g\left(\frac {nm}{ab}\right)\\ &=\sum_{a|n,b|m}f(a)f(b)g\left(\frac na\right)g\left(\frac mb\right)\\ &=\left(\sum_{a|n}f(a)g\left(\frac na\right)\right)\left(\sum_{b|m}f(b)g\left(\frac mb\right)\right)\\ &=t(n)t(m) \end{align}积性函数的逆是积性函数。 假定 $f$ 是一个积性函数，那么它满足 $f(1)=1=f(1)f(1)$. 证明 g(n)=[n=1]-\sum_{i|n}f(i)g\left(\frac ni\right)\\ g(nm)=g(n)g(m)当 $nm=1$ 时，显然。 当 $nm&gt;1$ 是，如果 $n^\prime m^\prime&lt;nm$, 那么 $g(n^\prime m^\prime)=g(n^\prime)g(m^\prime)$. \begin{align} g(nm)&=-\sum_{d|nm,d\not=1}f(d)g\left(\frac{nm}d\right)\\ &=-\sum_{a|n,b|m,ab\not=1}f(ab)g\left(\frac{nm}{ab}\right)\\ &=-\sum_{a|n,b|m,ab\not=1}f(a)f(b)g\left(\frac na\right)g\left(\frac mb\right)\\ &=f(1)f(1)g(n)g(m)-\sum_{a|n,b|m}f(a)f(b)g\left(\frac na\right)g\left(\frac mb\right)\\ &=g(n)g(m)-\left(\sum_{a|n}f(a)g\left(\frac na\right)\right)\left(\sum_{b|m}f(b)g\left(\frac mb\right)\right)\\ &=g(n)g(m)-\Big((f*g)(n)\Big)\Big((f*g)(n)\Big)\\ &=g(n)g(m)-\epsilon(n)\epsilon(m)\\ &=g(n)g(m) \end{align}最后一步由于 $nm\not=1$ 所以 $\epsilon(n)$ 和 $\epsilon(m)$ 当中至少有一个是 0.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>狄利克雷卷积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速沃尔什变换]]></title>
    <url>%2F2019%2F08%2F03%2FFWT%2F</url>
    <content type="text"><![CDATA[快速沃尔什变换(Fast Walsh-Hadamard Transform)可以用来处理位运算卷积。具体地，给定多项式 $A,B$, 他们的位运算卷积定义为 C_n=\sum_{i\oplus j=n}A_iB_j其中 $\oplus$ 运算符为某种位运算，通常为 And, Or, Xor 中的一种。 思想考虑 FFT, 我们先将多项式 $A,B$ 在 $O(N\log N)$ 时间内转换为了点值表达式，这样才可以 $O(N)$ 算出 $C$ 的点值表达式，最后还要确保能将这个点值表达式 $O(N\log N)$ 转换回去。如果位运算卷积也可以像这样，通过某种可以分治的变换变换为另一种形式，然后直接相乘，最后再用另一种可以分治的变换变换回去，那么就可以将求卷积的时间从 $O(N^2)$ 降到 $O(N\log N)$. 具体来说，仿照 FFT 那样，我们每次将 $A$ 分为前半段 $A_0$ 和后半段 $A_1$ 然后 $DWT(A)=(DWT(c_1),DWT(c_2))$, 其中 $c_1,c_2$ 是一个长度为 $|A|$ 一半，由 $A_0,A_1$ 计算得到的多项式，$(a_1,a_2)$ 代表将 $a_1,a_2$ 拼接在一起。 快速沃尔什变换定义多项式之间的加减法为逐项相加减，数除为将每一项分别除以这个数。 Or DWT(A)=(DWT(A_0),DWT(A_0+A_1))\\ IDWT(A)=(IDWT(A_0),IDWT(A_0-A_1))And DWT(A)=(DWT(A_0+A_1),DWT(A_1))\\ IDWT(A)=(IDWT(A_0-A_1),IDWT(A_1))Xor DWT(A)=(DWT(A_0+A_1),DWT(A_0-A_1))\\ IDWT(A)=\left(IDWT\left(\frac{A_0+A_1}2\right)+IDWT\left(\frac{A_0-A_1}2\right)\right)代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 1&lt;&lt;17;constexpr auto MOD = 998244353LL;int totNums;long long numA[MAXN],numB[MAXN],origA[MAXN],origB[MAXN],pow2;void DWTor(long long* A,int totNums)&#123; if(totNums &lt;= 1) return; int len = totNums &gt;&gt; 1; for(int i=len;i&lt;totNums;i++) (A[i] += A[i-len]) %= MOD; DWTor(A,len); DWTor(A+len,len);&#125;void IDWTor(long long* A,int totNums)&#123; if(totNums &lt;= 1) return; int len = totNums &gt;&gt; 1; for(int i=len;i&lt;totNums;i++) (((A[i] -= A[i-len]) %= MOD) += MOD) %= MOD; IDWTor(A,len); IDWTor(A+len,len);&#125;void DWTand(long long* A,int totNums)&#123; if(totNums &lt;= 1) return; int len = totNums &gt;&gt; 1; for(int i=0;i&lt;len;i++) (A[i] += A[i+len]) %= MOD; DWTand(A,len); DWTand(A+len,len);&#125;void IDWTand(long long* A,int totNums)&#123; if(totNums &lt;= 1) return; int len = totNums &gt;&gt; 1; for(int i=0;i&lt;len;i++) (((A[i] -= A[i+len]) %= MOD) += MOD) %= MOD; IDWTand(A,len); IDWTand(A+len,len);&#125;void DWTxor(long long* A,int totNums)&#123; if(totNums &lt;= 1) return; int len = totNums &gt;&gt; 1; long long A0,A1; for(int i=0;i&lt;len;i++)&#123; A0 = A[i]; A1 = A[i+len]; A[i] = (A0 + A1) % MOD; A[i+len] = (((A0 - A1) % MOD) + MOD) % MOD; &#125; DWTxor(A,len); DWTxor(A+len,len);&#125;void IDWTxor(long long* A,int totNums)&#123; if(totNums &lt;= 1) return; int len = totNums &gt;&gt; 1; long long A0,A1; for(int i=0;i&lt;len;i++)&#123; A0 = A[i]; A1 = A[i+len]; A[i] = (A0 + A1)*pow2 % MOD; A[i+len] = (((A0 - A1)*pow2 % MOD) + MOD) % MOD; &#125; IDWTxor(A,len); IDWTxor(A+len,len);&#125;signed main(void)&#123; long long a = 2, pows = MOD-2; pow2 = 1; for(;pows;pows&gt;&gt;=1,(a*=a)%=MOD) if(pows &amp; 1) (pow2 *= a) %= MOD; //std::cout&lt;&lt;pow2&lt;&lt;std::endl; scanf("%d", &amp;totNums); totNums = 1&lt;&lt;totNums; for(int i=0;i&lt;totNums;i++) scanf("%lld", origA+i); for(int i=0;i&lt;totNums;i++) scanf("%lld", origB+i); for(int i=0;i&lt;totNums;i++)&#123; numA[i] = origA[i]; numB[i] = origB[i]; &#125; DWTor(numA,totNums); DWTor(numB,totNums); for(int i=0;i&lt;totNums;i++) (numA[i] *= numB[i]) %= MOD; IDWTor(numA,totNums); for(int i=0;i&lt;totNums;i++) printf("%lld ", numA[i]); putchar('\n'); for(int i=0;i&lt;totNums;i++)&#123; numA[i] = origA[i]; numB[i] = origB[i]; &#125; DWTand(numA,totNums); DWTand(numB,totNums); for(int i=0;i&lt;totNums;i++) (numA[i] *= numB[i]) %= MOD; IDWTand(numA,totNums); for(int i=0;i&lt;totNums;i++) printf("%lld ", numA[i]); putchar('\n'); for(int i=0;i&lt;totNums;i++)&#123; numA[i] = origA[i]; numB[i] = origB[i]; &#125; DWTxor(numA,totNums); DWTxor(numB,totNums); for(int i=0;i&lt;totNums;i++) (numA[i] *= numB[i]) %= MOD; IDWTxor(numA,totNums); for(int i=0;i&lt;totNums;i++) printf("%lld ", numA[i]); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速数论变换]]></title>
    <url>%2F2019%2F07%2F31%2FNTT%2F</url>
    <content type="text"><![CDATA[快速数论变换(Number-Theoretic Transform) 可以用来像 FFT 那样计算多项式卷积，与 FFT 不同的是，NTT 全部过程都在一个模 $p$ 的意义下进行，不涉及浮点数计算，可以解决只有整数参与时的精度误差问题。 FFT在 FFT 中，我们选择了一组向量 $(\omega_n^0,\ \omega_n^1,\ \omega_n^2,\cdots,\ \omega_n^{n-1})$ 带入，$O(N\log N)$ 求得点值表达式，然后 $O(N)$ 计算乘积，最终 $O(N\log N)$ 差值重新转换为多项式表示。能够完成这个过程是因为选择的 $\omega_n=e^{\frac{2\pi i}n}$ 具有一些性质。 性质一$\omega_n^k\;(0\leq k\leq n-1)$ 互不相同，点值表示能够保存所有信息。 性质二消去定理 $\omega_{2n}^{2k}=\omega_n^k$ 用于分治。 性质三折半定理 $\omega_n^{k+\frac n2}=-\omega_n^k$, 用于分治。 性质四当 $k\not=0$ 时，$\sum_{i=0}^{n-1}\left(\omega_n^k\right)^i=0$, 用于插值。 NTT在 NTT 中，我们需要找到另外一组向量用于替代原先的单位复根，也就是一个 原根 满足单位复根所有的性质，而且要在整数域上。 原根记原根为 $g$. 定义对于一个正整数 $p$, 模 $p$ 的原根 $g$ 定义为满足 $\gcd(p,g)=1$ 且 $\delta_p(g)=\varphi(p)$ 的数，其中 $\delta_p(g)$ 为使 $g^d\equiv 1(\mbox{mod }p)$ 的最小整数 $d$. 由欧拉定理，$\delta_p(g)\leq\varphi(p)$. 计算计算原根时，可以用到它的一些特性 对于一个数 $g$, 最小的满足 $g^k\equiv1\;(\mbox{mod }p)$ 的正整数 $k$ 一定是 $p-1$ 的约数。 假设最小的 $k$ 不是 $p-1$, 那么可以找到一个 $x$ 使得 $xk&gt;p-1&gt;(x-1)k$, 由费马小定理 g^{xk}\equiv g^{p-1}\equiv1\equiv g^{xk-(p-1)}\mod p那么就存在一个更小的 $k^\prime=xk-(p-1)$, 矛盾。 代码如下 1234567891011121314template&lt;typename T&gt;inline T Root(const T&amp; p)&#123; for(T i=2;i&lt;=p;i++)&#123; T phi = p-1; bool flag = true; for(T k=2;k*k&lt;p;++k) if(phi % k == 0)&#123; if(Pow(i,(p-1)/k,p) == 1)&#123; flag = false; break; &#125; while(phi % k == 0) phi /= k; &#125; if(flag &amp;&amp; (phi==1 || Pow(i,(p-1)/phi,p)!=1)) return i; &#125; throw;&#125; 性质为了确保计算的正确，我们验证原根的性质。 假定这个素数 $p=qn+1$, 其中 $n$ 为 2 的正整数次幂。需要取的一组新的向量中 $\omega_n=g^q$. $g$ 可以使得 $g^i(0\leq i\leq n-1)$ 互不相同。证明： 假定存在 $n&gt;p&gt;q$ 使得 g^p\equiv g^q\not\equiv1\mod p那么 $p|g^{p-q}$ g^{p-q-1}\equiv1\mod p而这里明显 $p-q-1\not=0$ 因为如果这样 $g=p$, 同时 $g$ 在定义时只满足 $g^{p-1}\equiv1\;(\mbox{mod }p)$, 矛盾。 性质一$\omega_n=g^q$. 显然。 性质二 \omega_{2n}^{2k}=\left(g^\frac q2\right)^{2k}=g^{qk}=\omega_n^k性质三 \omega_n^n\equiv g^{nq}\equiv 1\mod n因为 $\left(\omega_n^\frac n2\right)^2=\omega_n^n$ 所以 $\omega_n^\frac n2=\pm1\;(\mbox{mod }p)$. 而根据性质一，他们两两不等，所以 $\omega_n^\frac n2=-1$. \omega_n^{k+\frac n2}=\omega_n^k\cdot\omega_n^\frac n2=-\omega_n^k性质四 \begin{align} S(\omega_n^k)&=1+\omega_n^k+(\omega_n^k)^2+\cdots+(\omega_n^k)^{n-1}\\ \omega_n^kS(\omega_n^k)&=\omega_n^k+(\omega_n^k)^2+(\omega_n^k)^3+\cdots+(\omega_n^k)^p\\ (\omega_n^k-1)S(\omega_n^k)&=(\omega_n^k)^p-1\\ S(\omega_n^k)&=\frac{(\omega_n^k)^n-1}{\omega_n^k-1} \end{align}由于 $\omega_n^n\equiv1\;(\mbox{mod }p)$, 且 $k\not=p-1$. 所以 \begin{align} (\omega_n^k)^n-1\equiv0&\mod p\\ \omega_n^k\not\equiv1&\mod p \end{align} S(\omega_n^k)=0可见，有了这些性质，原根可以代替单位复根参与运算。 实践具体实现的过程中，需要将原先的除法改为乘上模 $p$ 意义下的逆元。 模板题目链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;constexpr auto MOD = 1004535809LL;constexpr auto MAXN = 1&lt;&lt;22;template&lt;typename ansType,typename powsType&gt;inline ansType Pow(ansType a,powsType b,const ansType&amp; MOD)&#123; ansType ans = 1; for(;b;b&gt;&gt;=1,(a*=a)%=MOD) if(b &amp; 1) (ans *= a) %= MOD; return ans;&#125; template&lt;typename T&gt;inline T Root(const T&amp; p)&#123; for(T i=2;i&lt;=p;i++)&#123; T phi = p-1; bool flag = true; for(T k=2;k*k&lt;p;++k) if(phi % k == 0)&#123; if(Pow(i,(p-1)/k,p) == 1)&#123; flag = false; break; &#125; while(phi % k == 0) phi /= k; &#125; if(flag &amp;&amp; (phi==1 || Pow(i,(p-1)/phi,p)!=1)) return i; &#125; throw;&#125;long long Omega[MAXN],OmegaInverse[MAXN],root;long long A[MAXN],B[MAXN];int r[MAXN];void NTT(long long* A,const int&amp; totLevel,long long* Omega)&#123; int totNums = 1&lt;&lt;totLevel; for(int i=0;i&lt;totNums;i++) if(i &lt; r[i]) std::swap(A[i],A[r[i]]); long long temp; for(int nowLevel=0;nowLevel&lt;totLevel;nowLevel++) for(int nowBlk=0;nowBlk&lt;totNums;nowBlk+=1&lt;&lt;nowLevel+1) for(int i=0;i&lt;(1&lt;&lt;nowLevel);i++)&#123; temp = A[nowBlk+i+(1&lt;&lt;nowLevel)] * Omega[i*(totNums/(1&lt;&lt;nowLevel+1))] % MOD; A[nowBlk+i+(1&lt;&lt;nowLevel)] = (A[nowBlk+i] - temp + MOD) % MOD; (A[nowBlk+i] += temp) %= MOD; &#125;&#125;signed main(void)&#123; int totA,totB,tot,totLevel; long long temp; scanf("%d%d", &amp;totA,&amp;totB); for(int i=0;i&lt;=totA;i++) scanf("%lld", A+i); for(int i=0;i&lt;=totB;i++) scanf("%lld", B+i); tot = 1; totLevel = 0; while(tot &lt;= (totA+totB))&#123; tot&lt;&lt;=1; ++totLevel; &#125; assert((1&lt;&lt;totLevel)==tot); for(int i=1;i&lt;tot;i++) r[i] = (r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;totLevel-1); *Omega = 1; root = Root(MOD); temp = Pow(root,(MOD-1)/tot,MOD); for(int i=1;i&lt;tot;i++) Omega[i] = Omega[i-1] * temp % MOD; for(int i=0;i&lt;tot;i++) OmegaInverse[i] = Pow(Omega[i],MOD-2,MOD); NTT(A,totLevel,Omega);NTT(B,totLevel,Omega); for(int i=0;i&lt;tot;i++) (A[i] *= B[i]) %= MOD; NTT(A,totLevel,OmegaInverse); temp = Pow((long long)tot,MOD-2,MOD); for(int i=0;i&lt;=totA+totB;i++) printf("%lld ",(A[i]*temp%MOD+MOD)%MOD); putchar('\n'); return 0;&#125; 封装模板NTT12345678910111213141516171819202122232425262728293031323334353637383940414243444546constexpr auto MOD = 998244353LL;constexpr auto g = 3LL;template&lt;typename ansType,typename powsType&gt;inline ansType Pow(ansType a,powsType b,const ansType&amp; MOD = MOD)&#123; ansType ans = 1; for(;b;b&gt;&gt;=1,(a*=a)%=MOD) if(b &amp; 1) (ans *= a) %= MOD; return ans;&#125;template&lt;typename T&gt;inline T Module(T a,const T&amp; b)&#123; a += b; if(a &gt;= MOD) a -= MOD; return a;&#125;int *r;//for(int i=1;i&lt;tot;i++) r[i] = (r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;totLevel-1);void NTT(long long* A,const int&amp; totLevel, const short &amp;type)&#123; int totNums = 1&lt;&lt;totLevel; for(int i=0;i&lt;totNums;i++) if(i &lt; r[i]) std::swap(A[i], A[r[i]]); long long temp,gn,omega; for(int nowLevel=0;nowLevel&lt;totLevel;nowLevel++)&#123; gn = Pow(g, (MOD-1)/(1&lt;&lt;nowLevel+1)); if(type == -1) gn = Pow(gn, MOD-2); for(int nowBlk=0;nowBlk&lt;totNums;nowBlk+=1&lt;&lt;nowLevel+1)&#123; omega = 1; for(int i=0;i&lt;(1&lt;&lt;nowLevel);i++)&#123; temp = omega*A[nowBlk+i+(1&lt;&lt;nowLevel)] % MOD; A[nowBlk+i+(1&lt;&lt;nowLevel)] = Module(A[nowBlk+i], MOD-temp); A[nowBlk+i] = Module(A[nowBlk+i], temp); (omega *= gn) %= MOD; &#125; &#125; &#125; if(type == -1)&#123; temp = Pow((long long)totNums,MOD-2); for(int i=0;i&lt;totNums;i++) (A[i] *= temp) %= MOD; &#125;&#125; 多项式柯西乘法12345678910void Mult(long long* X,long long* Y,const int&amp; totLevel)&#123; int totNums = 1&lt;&lt;totLevel; long long *cX = new long long[totNums], *cY = new long long[totNums]; memset(cX,0,sizeof(cX)); memset(cY,0,sizeof(cY)); for(int i=0;i&lt;=totNums;i++)&#123; cX[i] = X[i]; cY[i] = Y[i]; &#125; NTT(cX, totLevel, 1); NTT(cY, totLevel, 1); for(int i=0;i&lt;totNums;i++) (cX[i] *= cY[i]) %= MOD; NTT(cX, totLevel, -1); for(int i=0;i&lt;totNums;i++) X[i] = cX[i];&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2011 Problem b]]></title>
    <url>%2F2019%2F07%2F31%2FProblem_b%2F</url>
    <content type="text"><![CDATA[给定整数 $a,b,c,d,k$, 求 \sum_{x=a}^b\sum_{y=c}^d[\gcd(x,y)=k]多组询问。 定义函数 \mathrm{Calc(x,y)}=\sum_{i=1}^a\sum_{j=1}^b[\gcd(i,j)=k]那么答案就是 $\mathrm{Calc(b,d)-Calc(a-1,d)-Calc(b,c-1)+Calc(a-1,c-1)}$. 定义函数 f(k)=\sum_{i=1}^a\sum_{j=1}^b[\gcd(i,j)=k]\\ F(n)=\sum_{n|k}f(k)=\left\lfloor\frac ak\right\rfloor\times\left\lfloor\frac bk\right\rfloor莫比乌斯反演得到 \begin{align}f(k)=&\sum_{k|n}\mu\left(\frac nk\right)F(n)\\ =&\sum_{k|n}\mu\left(\frac nk\right)\left\lfloor\frac an\right\rfloor\left\lfloor\frac bn\right\rfloor \end{align}记 $t=\left\lfloor\frac nk\right\rfloor$. f(k)=\sum_{t=0}^{\min(a,b)}\mu(t)\left\lfloor\frac a{kt}\right\rfloor\left\lfloor\frac b{kt}\right\rfloor这里的 $f(k)$ 也就是我们要求的答案。 利用数论分块加上前面的容斥即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 50000+500;int prime[MAXN],totPrimes,min_Factor[MAXN];int mu[MAXN];void Prime(const int&amp; top)&#123; mu[1] = 1; for(int i=2;i&lt;top;i++)&#123; if(min_Factor[i] == 0)&#123; min_Factor[i] = i; prime[totPrimes++] = i; mu[i] = -1; &#125; for(int j=0;j&lt;totPrimes;j++)&#123; if(prime[j]*i&gt;=top || prime[j]&gt;min_Factor[i]) break; min_Factor[i*prime[j]] = prime[j]; if(i % prime[j] == 0) mu[i*prime[j]] = 0; else mu[i*prime[j]] = -mu[i]; &#125; &#125;&#125;long long Solve(const long long&amp; a,const long long&amp; b,const long long&amp; k)&#123; long long ans=0,l,r,advk=a/k,bdvk=b/k; long long maxLoop=std::min(advk,bdvk); for(l=1;l&lt;=maxLoop;l=r+1)&#123; r = std::min(advk/(advk/l), bdvk/(bdvk/l)); ans += (mu[r]-mu[l-1])*(advk/l)*(bdvk/l); &#125; return ans;&#125;signed main(void)&#123; Prime(MAXN); for(int i=1;i&lt;MAXN;i++) mu[i] += mu[i-1]; int totCases; long long a,b,c,d,k; scanf("%d", &amp;totCases); while(totCases--)&#123; scanf("%lld%lld%lld%lld%lld", &amp;a,&amp;b,&amp;c,&amp;d,&amp;k); printf("%lld\n", Solve(b,d,k)-Solve(a-1,d,k)-Solve(b,c-1,k)+Solve(a-1,c-1,k)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3160 万径人踪灭]]></title>
    <url>%2F2019%2F07%2F30%2FMary_Jane%2F</url>
    <content type="text"><![CDATA[给定一个长度为 $n$ 的 01 串 $s$，求它的非连续回文子串的数量。 题目链接 首先考虑如何求连续回文子串的数量。 一种可行的方法是使用 Manacher 算法，它设计的初衷是用于求最长回文子串，但在实现的过程中，它求出了一个数组 $R_i$ 代表将原串每两个相邻的字符中间插入分隔符 ‘#’ 之后，以位置 $i$ 为对称轴的最长对称长度，这就意味着以 $i$ 为对称轴有一共有 $\left\lfloor\frac {R_i}2 \right\rfloor$ 个回文串。这一步的时间复杂度为 $O(N)$. 接下来考虑如何求回文子串的数量。 假定有一个回文子串对称轴为 $i$, 那么这个子串上的任何两个对应的字符 $u,v$ 的下标 $u_p,v_p$ 一定满足 $u_p+v_p=2i$. 如果我们能够求得一个数组 $f$, 其中 $f_i$ 代表有多少对字符关于 $i$ 对称，那么 $i$ 这个对称轴对答案的贡献就是 $2^{f_i}-1$, 因为每对字符都有选和不选两种选择，最终减去空串。 我们在求多项式的卷积的时候，公式为 $C_i=\sum_{j+k=i}A_jB_k$, 与此处的情形非常相似，我们处理一个数组 $a$, 其中 $a_i=[s_i=a]$. 然后求 $a$ 和自己的卷积，然后再处理一个数组 $b$, 其中 $b_i=[s_i=b]$. 然后求 $b$ 和自己的卷积。将两个多项式相加，取系数作为 $c$ 数组，那么 $f_i=\left\lfloor\frac {c_i+1}2\right\rfloor$. 这是因为，$a$ 中的每一位 $i$ 都是当两个位置相加得 $i$, 而且当中的数乘积为 1 (都代表 a) 才会产生 1 的贡献，$b$ 同理。这一步的时间复杂度为 $O(N\log N)$. 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;struct Complex&#123; double r,i; Complex()&#123; r = i = 0; &#125; Complex(const double&amp; ir,const double&amp; ii) : r(ir),i(ii) &#123;&#125; Complex operator + (const Complex&amp; a) const &#123; return Complex(r+a.r,i+a.i); &#125; Complex operator - (const Complex&amp; a) const &#123; return Complex(r-a.r,i-a.i); &#125; Complex operator * (const Complex&amp; a) const &#123; return Complex(r*a.r-i*a.i, r*a.i+i*a.r); &#125; Complex&amp; operator += (const Complex&amp; a) &#123; return *this = *this+a; &#125; Complex&amp; operator -= (const Complex&amp; a) &#123; return *this = *this-a; &#125; Complex&amp; operator *= (const Complex&amp; a) &#123; return *this = *this*a; &#125;&#125;;const int MAXN = 600000;const long long MOD = 1000000007LL;const double Pi = acos(-1.0);long long Pow(long long a,long long b)&#123; long long ans = 1; for(;b;b&gt;&gt;=1,(a*=a)%=MOD) if(b&amp;1) (ans *= a) %= MOD; return ans;&#125;char s[MAXN];long long ans;int str[MAXN],R[MAXN];long long Manacher(int len)&#123; for(int i=0;i&lt;len;i++)&#123; str[(i&lt;&lt;1)|1] = s[i]; str[i&lt;&lt;1] = '#'; &#125; len &lt;&lt;= 1; str[len] = '#'; int maxPos = -1,pos; long long ret = 0; for(int i=0;i&lt;len;i++)&#123; if(i &lt; maxPos) R[i] = std::min(maxPos-i, R[(pos&lt;&lt;1)-i]); else R[i] = 1; while(i-R[i] &gt;= 0 &amp;&amp; i+R[i] &lt;= len &amp;&amp; str[i-R[i]]==str[i+R[i]]) ++R[i]; if(i+R[i] &gt; maxPos)&#123; pos = i; maxPos = i+R[i]; &#125; (ret += R[i]&gt;&gt;1) %= MOD; &#125; return ret;&#125;Complex arr[MAXN]; int r[MAXN];void FFT(const int&amp; totLevel,const double&amp; type)&#123; int totNums = 1&lt;&lt;totLevel; for(int i=0;i&lt;totNums;i++) if(i&lt;r[i]) std::swap(arr[i],arr[r[i]]); Complex temp; for(int nowLevel=0;nowLevel&lt;totLevel;++nowLevel)&#123; const Complex Omega_n = Complex(cos(Pi/(1&lt;&lt;nowLevel)),type*sin(Pi/(1&lt;&lt;nowLevel))); for(int nowPos=0;nowPos&lt;totNums;nowPos+=(1&lt;&lt;nowLevel+1))&#123; Complex Omega = Complex(1,0); for(int i=0;i&lt;(1&lt;&lt;nowLevel);i++)&#123; temp = arr[nowPos+i+(1&lt;&lt;nowLevel)]*Omega; arr[nowPos+i+(1&lt;&lt;nowLevel)] = arr[nowPos+i] - temp; arr[nowPos+i] += temp; Omega *= Omega_n; &#125; &#125; &#125;&#125;long long cnt[MAXN];signed main(void)&#123; int totLen,totLevel,totNums; scanf("%s", s); totLen = strlen(s); ans -= Manacher(totLen); //FFT totLevel = 0; totNums = 1; while(totNums &lt;= (totLen-1&lt;&lt;1))&#123; totNums &lt;&lt;= 1; ++totLevel; &#125; for(int i=0;i&lt;totNums;i++) r[i] = (r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;totLevel-1); for(int i=0;i&lt;totLen;i++) arr[i].r = s[i]=='a' ? 1 : 0; FFT(totLevel,1); for(int i=0;i&lt;totNums;i++) arr[i] *= arr[i]; FFT(totLevel,-1); for(int i=0;i&lt;totNums;i++) cnt[i] = (int)(arr[i].r/totNums+0.5)+1&gt;&gt;1; for(int i=0;i&lt;=totNums;i++) arr[i] = Complex(0,0); for(int i=0;i&lt;totLen;i++) arr[i].r = s[i]=='a' ? 0 : 1; FFT(totLevel,1); for(int i=0;i&lt;totNums;i++) arr[i] *= arr[i]; FFT(totLevel,-1); for(int i=0;i&lt;totNums;i++) cnt[i] += (int)(arr[i].r/totNums+0.5)+1&gt;&gt;1; //for(int i=0;i&lt;totNums;i++) cnt[i] = (cnt[i]+1)&gt;&gt;1; for(int i=0;i&lt;totNums;i++) (ans += Pow(2,cnt[i])-1) %= MOD; printf("%lld\n", (ans+MOD)%MOD); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数学</tag>
        <tag>FFT</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF888G Xor-MST]]></title>
    <url>%2F2019%2F07%2F29%2FXor-MST%2F</url>
    <content type="text"><![CDATA[给定 $n$ 个点组成的完全图，第 $i$ 个点点权为 $a_i$, 一条从 $a_i$ 到 $a_j$ 的路径权值为 $a_i\ \mathrm{xor}\ a_j$. 求这个图的 MST. 最小生成树的 Borůvka 算法：将一开始所有的点看做一个个独立的集合，对于一个集合 $S_i$ 不断循环找到最小的路径链接 $a_i\in S_i$ 和 $a_j\in S_j$, 每一次合并两个集合，注意连边之前看一下是否已经联通。 在这道题目中，我们将所有的点权插入到一棵 Trie 中，到这一步，其实已经自动合并了所有点权相同的点，对答案产生的贡献为 $0$. 接下来我们将整棵 Trie 搜一遍，遇到一个分叉的结点，那么它代表着两个未合并的联通块，在它左子树中枚举一个数，然后在右边找到异或最小的，加入贡献即可。 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 200000+5;struct Node&#123; int bits,siz; Node *ch[2]; Node(void)&#123; ch[0] = ch[1] = nullptr; siz = 0; &#125; Node(const int&amp; ibits) : bits(ibits) &#123; siz = 0; ch[0] = ch[1] = nullptr; &#125;&#125;*t0 = new Node(30);long long num[MAXN];void Insert(const long long&amp; ins)&#123; Node* nowAt = t0; long long pos; ++nowAt-&gt;siz; while(nowAt-&gt;bits&gt;=0)&#123; pos = (ins&gt;&gt;nowAt-&gt;bits)&amp;1LL; if(nowAt-&gt;ch[pos] == nullptr) nowAt-&gt;ch[pos] = new Node(nowAt-&gt;bits-1); nowAt = nowAt-&gt;ch[pos]; ++nowAt-&gt;siz; &#125;&#125;long long Query(const long long&amp; val,Node* nowAt)&#123; if(nowAt-&gt;bits&lt;0) return 0LL; long long pos = (val&gt;&gt;nowAt-&gt;bits)&amp;1LL; if(nowAt-&gt;ch[pos] != nullptr) return Query(val,nowAt-&gt;ch[pos]); else return (1LL&lt;&lt;nowAt-&gt;bits) + Query(val,nowAt-&gt;ch[pos^1]);&#125;long long Dfs(Node* nowAt,const int&amp; siz = 0)&#123; if(nowAt==nullptr || nowAt-&gt;bits&lt;0 || nowAt-&gt;siz&lt;=1) return 0LL; if(nowAt-&gt;ch[0]!=nullptr &amp;&amp; nowAt-&gt;ch[1]!=nullptr)&#123; long long min = INT64_MAX; for(int i=0;i&lt;nowAt-&gt;ch[0]-&gt;siz;++i) min = std::min(min, Query(num[i+siz], nowAt-&gt;ch[1])); return min + (1LL&lt;&lt;nowAt-&gt;bits) + Dfs(nowAt-&gt;ch[0],siz) + Dfs(nowAt-&gt;ch[1],siz+nowAt-&gt;ch[0]-&gt;siz); &#125; if(nowAt-&gt;ch[0] != nullptr) return Dfs(nowAt-&gt;ch[0],siz); if(nowAt-&gt;ch[1] != nullptr) return Dfs(nowAt-&gt;ch[1],siz); return 0LL;&#125;signed main(void)&#123; int totNums; std::cin&gt;&gt;totNums; for(int i=0;i&lt;totNums;i++) std::cin&gt;&gt;num[i]; std::sort(num,num+totNums); for(int i=0;i&lt;totNums;i++) Insert(num[i]); std::cout&lt;&lt;Dfs(t0)&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2013 快餐店]]></title>
    <url>%2F2019%2F07%2F27%2FFoodShop%2F</url>
    <content type="text"><![CDATA[给定一个没有重边没有自环的基环树，边有权值，问最长路径的一半长度。 题目链接 先用 Dfs 求出环，记长度为 $n$, 环上的结点依次为 $a_1,a_2,\cdots,a_n$, 两点 $a_i,a_j$ 之间距离为 $a_i\to a_j$. 然后，我们通过 $n$ 次树上 Dp, 求出以 $a_i$ 为根的树最大深度 $l_i$, 顺便统计不考虑环的答案，记为 $s_0$. 考虑最长路径经过环的情况。我们人为地断掉 $a_1\leftrightarrow a_n$ 这条边，得到一条链，定义 $f_i$ 为仅考虑 $a_i$ 和以前的结点，最大的 $l_j+\sum_{k=2}^ja_k\to a_{k-1}$, $p_i$ 为仅考虑 $a_i$ 和以前的结点，最大的 $l_u+l_v+\sum_{k=u+1}^va_u\to a_{u-1}$. 从左到右扫一遍处理出来。同时定义 $b_i$ 和 $n_i$ 与上面类似，但是仅考虑 $a_i$ 和以后的结点，从右到左扫一遍。 接下来我们枚举 $i$, 断掉 $a_{i-1}\leftrightarrow a_i$ 这条边，断完边之后环上最长路径可能是左边的 $p_{i-1}$ 或者右边的 $n_i$, 也有可能这条路径经过 $a_1\leftrightarrow a_n$ 这条边，长度为 $f_{i-1}+a_1\to a_n+b_i$. 在这三个值中取一个最大的，就是断掉这条边之后的最长路径。 由于我们实际上每条边都存在，而最长路径不可能经过整个环上所有的边，所以将断掉每一条边得到的最长路径数值取 $\min$, 然后与 $s_0$ 取 $\max$, 就是最终答案的两倍。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)1e5+500;struct Line&#123; int to; long long len; Line()&#123;&#125; Line(const int&amp; ito,const long long&amp; ilen) : to(ito),len(ilen) &#123;&#125;&#125;;std::vector&lt;Line&gt; G[MAXN];int node[MAXN],totrNode; bool ring[MAXN],vis[MAXN],inloop; long long prevLen[MAXN];bool Dfs(const int&amp; nowAt,const int&amp; fa = 0)&#123; vis[nowAt] = true; for(const auto &amp;it : G[nowAt]) if(it.to != fa)&#123; if(vis[it.to])&#123; ring[it.to] = ring[nowAt] = true; inloop = true; *prevLen = it.len; node[totrNode = 1] = nowAt; return true; &#125; if(Dfs(it.to,nowAt))&#123; if(inloop)&#123; prevLen[++totrNode] = it.len; node[totrNode] = nowAt; &#125; if(ring[nowAt]) inloop = false; else ring[nowAt] = true; return true; &#125; &#125; return false;&#125;long long ans,maxTreeLen[MAXN];void DpTree(const int&amp; nowAt,const int&amp; fa=0)&#123; maxTreeLen[nowAt] = 0; long long rk1=0,rk2=0; for(const auto &amp;it : G[nowAt]) if(it.to!=fa &amp;&amp; !ring[it.to])&#123; DpTree(it.to,nowAt); maxTreeLen[it.to] += it.len; maxTreeLen[nowAt] = std::max(maxTreeLen[nowAt],maxTreeLen[it.to]); if(maxTreeLen[it.to] &gt; rk1)&#123; rk2 = rk1; rk1 = maxTreeLen[it.to]; &#125; else rk2 = std::max(rk2,maxTreeLen[it.to]); maxTreeLen[it.to] -= it.len; &#125; ans = std::max(ans,rk1+rk2);&#125;long long prev[MAXN],nxt[MAXN],prevFin[MAXN],nxtFin[MAXN],prevMax[MAXN],nxtMax[MAXN];signed main(void)&#123; int totNodes,a,b; long long val; scanf("%d", &amp;totNodes); for(int i=0;i&lt;totNodes;i++)&#123; scanf("%d%d%lld", &amp;a,&amp;b,&amp;val); G[a].push_back(Line(b,val)); G[b].push_back(Line(a,val)); &#125; assert(Dfs(1)); for(int i=1;i&lt;=totrNode;i++) DpTree(node[i]); long long totLen = 0; for(int i=1;i&lt;=totrNode;i++)&#123; totLen += prevLen[i]; prev[i] = std::max(prev[i-1],maxTreeLen[node[i]]+totLen); prevMax[i] = std::max(prevMax[i-1]+prevLen[i],maxTreeLen[node[i]]); prevFin[i] = std::max(prevFin[i-1],prevMax[i-1]+prevLen[i]+maxTreeLen[node[i]]); &#125; totLen = 0; for(int i=totrNode;i&gt;0;i--)&#123; totLen += prevLen[i+1]; nxt[i] = std::max(nxt[i+1],maxTreeLen[node[i]]+totLen); nxtMax[i] = std::max(nxtMax[i+1]+prevLen[i+1],maxTreeLen[node[i]]); nxtFin[i] = std::max(nxtFin[i+1],nxtMax[i+1]+prevLen[i+1]+maxTreeLen[node[i]]); &#125; assert(nxtFin[1] == prevFin[totrNode]); long long minrg = nxtFin[1],max; for(int i=2;i&lt;=totrNode;i++)&#123; //i-1 ---/--- i max = std::max(std::max(prevFin[i-1],nxtFin[i]),prev[i-1]+nxt[i]+*prevLen); minrg = std::min(minrg, max); &#125; ans = std::max(ans,minrg); printf("%.1lf\n", (double)ans/2); //printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>基环树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1190C Tokitsukaze and Duel]]></title>
    <url>%2F2019%2F07%2F27%2FTokitsukaze_and_Duel%2F</url>
    <content type="text"><![CDATA[有 $n$ 张单面有色的卡，Tokitsukaze 和 Quailty 可以轮流操作，将连续 $k$ 段卡牌翻面使得他们朝向一样，如果一个人操作完之后所有卡牌朝向一样，那么他就赢了。Tokitsukaze 先手，求最终赢家或者平局。 可以发现，如果 Tokitsukaze 操作完之后没有获胜，那么 Quailty 不可能失败，因为他只需要重复一遍 Tokitsukaze 的操作，使得局面不发生任何变化，直到当前局面可以让自己一步获胜。同理，如果 Quilty 重复一个没有意义的操作，那么 Tokitsukaze 后面采取的行动很有可能将一个必胜的局面扔给 Quailty, 所以他也应该重复同样无意义的操作，让游戏平局。 可见，游戏的胜负在最开始的两步就可以得知。先快速检查一下 Tokitsukaze 能否一步获胜，如果不行，考虑应该怎么操作使得 Quailty 在接下来的局面中不能一步获胜，将游戏拖入循环。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt; bool ReadBool(void)&#123; char in; do in = getchar(); while(in!='0' &amp;&amp; in!='1'); return in=='1';&#125; constexpr auto MAXN = (int)1e5+50; long long totCard,totRange;long long min[2],max[2];bool color[MAXN],orig[MAXN]; signed main(void)&#123; scanf("%d%d", &amp;totCard,&amp;totRange); totRange = std::min(totRange,totCard); for(int i=0;i&lt;totCard;i++) orig[i] = color[i] = ReadBool(); min[0] = min[1] = INT_MAX; max[0] = max[1] = INT_MIN; for(long long i=0;i&lt;totCard;i++)&#123; min[color[i]] = std::min(min[color[i]],i); max[color[i]] = std::max(max[color[i]],i); &#125; bool flag; if(max[0]-min[0]&lt;totRange || max[1]-min[1]&lt;totRange)&#123; puts("tokitsukaze"); goto END; &#125; if(max[0]-min[0]&gt;totRange || max[1]-min[1]&gt;totRange)&#123; puts("once again"); goto END; &#125; for(int i=0;i+totRange-1&lt;totCard;)&#123; flag = true; for(int j=1;j&lt;totRange;j++) if(color[i+j] != color[i+j-1])&#123; flag = false; i+=j; break; &#125; if(flag)&#123; puts("once again"); goto END; &#125; &#125; puts("quailty"); END: return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI2014 Hotel]]></title>
    <url>%2F2019%2F07%2F26%2FHotel%2F</url>
    <content type="text"><![CDATA[给定一棵树有 $n(n\leq100000)$ 个结点的树，问能找到多少个三元无序点集使得他们之间路径长度两两相同。 考虑动态规划。我们定义 $f_{i,j}$ 代表当前在 $i$ 结点能找到多少个点深度比 $i$ 大 $j$. 定义 $g_{i,j}$ 代表当前在 $i$ 结点能找到多少无序点对 $(u,v)$ 满足他们到他们的 $lca$ 距离 $d$ 相等，同时 $lca\to i$ 距离恰好是 $d-j$. 可以看做他们到 $lca$ 的距离 $d$ 翻折上去还有 $j$. 我们发现，只要在转移过程中按照特定的顺序，转移的同时统计答案，可以很好的维护。具体来说如果正确地计算完了 $y$ 的信息，现在要将他们转移到 $x$ 上，首先统计答案 \Delta ans=\sum_if_{x,i-1}\times g_{y,i}+g_{x,i+1}\times f_{y,i}然后枚举 $i$, 交替地更新 \Delta g_{x,i+1}=f_{x,i+1}\times f_{y,i}\\ \Delta f_{x,i+1}=f_{y,i}\\ \Delta g_{x,i}=g_{y,i+1}考虑一个结点如果只有一个儿子，那么这个时候 $f$ 相当与全体左移了一格，而 $g$ 相当于右移，这样我们可以长链剖分，将 $f_x$ 和 $g_x$ 定义为指针，重儿子的指针正好在自己的上一个或者下一个，这样就可以避免掉大量信息的合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;const int MAXN = 100000+50;long long array[MAXN&lt;&lt;3];long long *f[MAXN],*g[MAXN]; int nowLen;int totNodes;int imp[MAXN],len[MAXN];std::vector&lt;int&gt; G[MAXN];void Dfs1(const int&amp; nowAt = 1,const int&amp; fa = -1)&#123; imp[nowAt] = len[nowAt] = 0; for(int i=0;i&lt;G[nowAt].size();i++)&#123; int to = G[nowAt][i]; if(to == fa) continue; Dfs1(to,nowAt); len[nowAt] = std::max(len[nowAt],len[to]+1); if(len[to]+1 &gt; len[imp[nowAt]]) imp[nowAt] = to; &#125;&#125;long long ans;void Dp(const int&amp; nowAt = 1,const int&amp; fa = -1)&#123; if(imp[nowAt] != 0)&#123; f[imp[nowAt]] = f[nowAt]+1; g[imp[nowAt]] = g[nowAt]-1; Dp(imp[nowAt],nowAt); &#125; f[nowAt][0] = 1; ans += g[nowAt][0]; for(int i=0;i&lt;G[nowAt].size();i++)&#123; const int&amp; to = G[nowAt][i]; if(to == fa || to == imp[nowAt]) continue; f[to] = array+nowLen; nowLen += (len[to]&lt;&lt;1)+5; g[to] = array+nowLen; nowLen += (len[to]&lt;&lt;1)+5; Dp(to,nowAt); for(int i=0;i&lt;=len[to];i++)&#123; if(i) ans += f[nowAt][i-1]*g[to][i]; ans += g[nowAt][i+1]*f[to][i]; &#125; for(int i=0;i&lt;=len[to];i++) &#123; g[nowAt][i+1] += f[nowAt][i+1]*f[to][i]; f[nowAt][i+1] += f[to][i]; if(i!=len[to]) g[nowAt][i] += g[to][i+1]; &#125; &#125;&#125;signed main(void)&#123; int fr,to; scanf("%d", &amp;totNodes); for(int i=1;i&lt;totNodes;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); G[fr].push_back(to); G[to].push_back(fr); &#125; Dfs1(); f[1] = array+nowLen; nowLen += (len[1]&lt;&lt;1)+5; g[1] = array+nowLen; nowLen += (len[1]&lt;&lt;1)+5; Dp(); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOI2014 魔法森林]]></title>
    <url>%2F2019%2F07%2F26%2FMF%2F</url>
    <content type="text"><![CDATA[给定一个 $n$ 个结点 $m$ 条无向边的无向图，结点从 $1$ 到 $n$ 编号。每条边 $i$ 有两个权值 $a_i,b_i$, 你需要找到一条路径 $T=(a_1=1,a_2,\cdots,a_t=n)$，使得 $\max_{1\leq i\leq t}\{a_i\}+\max_{1\leq i\leq t}\{b_i\}$ 最小。 我们将所有的边按照 $a$ 从小到大排序，一次加入一条边，同时看一下 $1\to n$ 路径中最大的 $b$ 是多少，更新答案即可。 为了维护这样一个图，我们需要用到 LCT 来支持我们合并联通块，并且在出现环时断掉一条边，由于边有边权，我们考虑将每一条边上额外插入一个点，将边权转换为点权，我们额外创立的这些点的点权等于它原先边的边权，本来存在于图中的点点权为 $0$. 这样我们每个点再记录一下当前 Splay 层级最大点权的点是什么，查询直接像 Split 那样将 $1$ 和 $n$ 拎出来，询问最大点权即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 50000+500;constexpr auto MAXM = 100000+500;struct Node&#123; int val; //valueB bool rev; Node *ch[2],*fa,*max; Node()&#123; ch[0]=ch[1]=fa=nullptr; max=this; &#125; Node(const int&amp; ival) : val(ival) &#123; ch[0]=ch[1]=fa=nullptr; max=this; &#125; Node&amp; Reverse(void)&#123; rev^=1; std::swap(ch[0],ch[1]); return *this; &#125; Node&amp; Push_Down(void)&#123; if(rev)&#123; if(ch[0] != nullptr) ch[0]-&gt;Reverse(); if(ch[1] != nullptr) ch[1]-&gt;Reverse(); rev = false; &#125; return *this; &#125; Node&amp; Update(void)&#123; max = this; for(int i=0;i&lt;2;i++) if(ch[i] != nullptr) if(ch[i]-&gt;max-&gt;val &gt; max-&gt;val) max = ch[i]-&gt;max; return *this; &#125; bool IsRoot(void) const &#123; return fa==nullptr || fa-&gt;ch[0]!=this&amp;&amp;fa-&gt;ch[1]!=this; &#125; short Comp(const Node* comp) const &#123; return (ch[0]!=comp&amp;&amp;ch[1]!=comp) ? -1 : (ch[0]==comp?0:1); &#125;&#125;point[MAXN],valPt[MAXM];void Rotate(Node* targ)&#123; assert(!targ-&gt;IsRoot()); Node* up = targ-&gt;fa; const bool pos = up-&gt;Comp(targ); up-&gt;ch[pos] = targ-&gt;ch[pos^1]; if(targ-&gt;ch[pos^1] != nullptr) targ-&gt;ch[pos^1]-&gt;fa = up; targ-&gt;ch[pos^1] = up; if(!up-&gt;IsRoot()) up-&gt;fa-&gt;ch[up-&gt;fa-&gt;Comp(up)] = targ; targ-&gt;fa = up-&gt;fa; up-&gt;fa = targ; up-&gt;Update(); targ-&gt;Update();&#125; std::stack&lt;Node*&gt; S;void Spaly(Node* nowAt)&#123; Node* targ = nowAt; S.push(targ); while(!targ-&gt;IsRoot()) S.push(targ = targ-&gt;fa); while(!S.empty())&#123; S.top()-&gt;Push_Down(); S.pop(); &#125; for(;!nowAt-&gt;IsRoot() &amp;&amp; !nowAt-&gt;fa-&gt;IsRoot(); Rotate(nowAt)) if(nowAt-&gt;fa-&gt;Comp(nowAt) == nowAt-&gt;fa-&gt;fa-&gt;Comp(nowAt-&gt;fa)) Rotate(nowAt-&gt;fa); else Rotate(nowAt); if(!nowAt-&gt;IsRoot()) Rotate(nowAt);&#125;void Access(Node* nowAt)&#123; for(Node* targ=nullptr;nowAt!=nullptr;nowAt=nowAt-&gt;fa)&#123; Spaly(nowAt); nowAt-&gt;ch[1] = targ; nowAt-&gt;Update(); targ = nowAt; &#125;&#125;void Make_Root(Node* nowAt)&#123; Access(nowAt); Spaly(nowAt); nowAt-&gt;Reverse();&#125;Node* Find_Root(Node* nowAt)&#123; Access(nowAt); Spaly(nowAt); for(nowAt-&gt;Push_Down();nowAt-&gt;ch[0]!=nullptr;nowAt-&gt;Push_Down()) nowAt = nowAt-&gt;ch[0]; return nowAt;&#125;void Split(Node* x,Node* y)&#123; Make_Root(x); Access(y); Spaly(x);&#125;void Cut(Node* x,Node* y)&#123; Make_Root(x); if(Find_Root(y)!=x || y-&gt;ch[0]!=x || x-&gt;ch[1]!=nullptr) return; else x-&gt;fa = y-&gt;ch[0] = nullptr;&#125;void Link(Node* x,Node* y)&#123;//Link x-&gt;y Make_Root(x); if(Find_Root(y) != x) x-&gt;fa = y;&#125;struct Edge&#123; int fr,to,vala,valb; Edge()&#123;&#125; Edge(const int&amp; ifr,const int&amp; ito,const int&amp; ivala,const int&amp; ivalb) : fr(ifr),to(ito),vala(ivala),valb(ivalb) &#123;&#125; bool operator () (const Edge&amp; a,const Edge&amp; comp) const &#123; return a.vala==comp.vala ? a.valb&lt;comp.valb : a.vala&lt;comp.vala; &#125;&#125;edge[MAXM];signed main(void)&#123; int totNodes,totEdges,fr,to,vala,valb,ans=INT_MAX; scanf("%d%d", &amp;totNodes,&amp;totEdges); for(int i=0;i&lt;totEdges;i++)&#123; scanf("%d%d%d%d",&amp;fr,&amp;to,&amp;vala,&amp;valb); edge[i] = Edge(fr,to,vala,valb); &#125; std::sort(edge,edge+totEdges,Edge()); int bkopt; bool ins; for(int i=0;i&lt;totEdges;i++)&#123; const Edge&amp; it = edge[i]; ins = true; Make_Root(point + it.fr); if(Find_Root(point+it.to) == point+it.fr)&#123; bkopt = point[it.to].max-valPt; if(point[it.to].max-&gt;val &gt; it.valb)&#123; Cut(point+edge[bkopt].fr,valPt+bkopt); Cut(valPt+bkopt,point+edge[bkopt].to); &#125; else ins = false; &#125; valPt[i].val = edge[i].valb; if(ins)&#123; Link(point+edge[i].fr,valPt+i); Link(valPt+i,point+edge[i].to); &#125; Make_Root(point + 1); if(Find_Root(point+totNodes) == point+1) ans = std::min(ans, edge[i].vala+point[totNodes].max-&gt;val); &#125; printf("%d\n", ans==INT_MAX ? -1 : ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WC2013 糖果公园]]></title>
    <url>%2F2019%2F07%2F25%2FCandyPark%2F</url>
    <content type="text"><![CDATA[给定一棵树，结点有颜色，需要支持两种操作： 改变一个结点的颜色 统计简单路径 $u\to v$ 上所有颜色的贡献之和。定义颜色 $i$ 在这条路径上第 $j$ 次出现产生的贡献是 $V_iW_j$. 这题可以用树上莫队解决。 首先将树深搜一遍，得到这棵树的括号序，搜到一个结点 $u$ 就将它加入末尾，离开这个结点时也将它加入一次，两次出现分别记为 $in_u$ 和 $out_u$. 可见序列是树结点个数的两倍，接下来将树上的两个端点 $u,v$ 组成的路径 $u\to v$ 映射到这个序列上。如果两个端点存在祖先-后代关系，那么在序列上的两个端点就是 $in_u$ 和 $in_v$. 否则则是 $out_u$ 和 $in_v$. 当然还需要判断一下这些值的大小关系，必要时互换 $u,v$. 这样我们就可以像区间上莫队那样解决树上问题了，加入一个结点时，判断一下它是否已经在当前区间中，如果在就减去它的贡献，删除也是一样。这样我们就可以去掉序列上一些不必要结点产生的贡献。需要特别注意的是，如果 $u,v$ 的最近公共祖先不是他们当中的任何一个结点，那么它在调整完了之后也是没有被计算的，需要临时加上它的贡献，保存答案，然后再移动到下一个区间的时候减去。 剩下的修改操作原理与带修莫队同理，由于多了时间维度，分块大小选为 $n^\frac23$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 100000+500;constexpr auto MAXM = 100000+500;constexpr auto MAXQ = 100000+500;std::vector&lt;int&gt; G[MAXN];int candy[MAXN],nowColor[MAXN],appear[MAXM]; long long w[MAXM],val[MAXM],ans;bool vis[MAXN];void Opt(const int&amp; pos)&#123; if(!vis[pos]) ans += val[nowColor[pos]]*w[++appear[nowColor[pos]]]; else ans -= val[nowColor[pos]]*w[appear[nowColor[pos]]--]; vis[pos] ^= 1;&#125;struct Query&#123; int fr,to,time,ID,blk,lca; long long ans; Query()&#123;&#125; Query(const int&amp; ifr,const int&amp; ito,const int&amp; itime, const int &amp;iID,const int&amp; iBlk,const int&amp; iLCA) : fr(ifr),to(ito),time(itime),ID(iID),blk(iBlk),lca(iLCA) &#123;&#125; bool operator () (const Query&amp; a,const Query&amp; comp) const &#123; return a.blk == comp.blk ? (a.to==comp.to ? a.time&lt;comp.time : a.to&lt;comp.to) : a.blk &lt; comp.blk; &#125; bool operator &lt; (const Query&amp; comp) const &#123; return ID &lt; comp.ID; &#125;&#125;que[MAXQ]; int pos[MAXQ],dec[MAXQ],inc[MAXQ];int totQuery,totTime;int totLen,s[MAXN&lt;&lt;1],in[MAXN],out[MAXN]; int up[MAXN][20],depth[MAXN];void Dfs(const int&amp; nowAt = 1,const int&amp; fa = 0)&#123; s[totLen] = nowAt; in[nowAt] = totLen++; up[nowAt][0] = fa; depth[nowAt] = depth[fa] + 1; for(int i=1;i&lt;20;i++) up[nowAt][i] = up[up[nowAt][i-1]][i-1]; for(const auto &amp;it : G[nowAt]) if(it!=fa) Dfs(it,nowAt); s[totLen] = nowAt; out[nowAt] = totLen++;&#125;int LCA(int a,int b)&#123; if(depth[a] &lt; depth[b]) std::swap(a,b); for(int i=19;i&gt;=0;i--) if(depth[up[a][i]] &gt;= depth[b]) a = up[a][i]; if(a == b) return a; for(int i=19;i&gt;=0;i--) if(up[a][i] != up[b][i])&#123; a = up[a][i]; b = up[b][i]; &#125; assert(up[a][0] == up[b][0]); return up[a][0];&#125;signed main(void)&#123; int totNodes,totCandy,totOptn,opt,fr,to,time; scanf("%d%d%d", &amp;totNodes,&amp;totCandy,&amp;totOptn); for(int i=1;i&lt;=totCandy;i++) scanf("%lld", val+i); for(int i=1;i&lt;=totNodes;i++) scanf("%lld", w+i); for(int i=1;i&lt;totNodes;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); G[fr].push_back(to); G[to].push_back(fr); &#125; for(int i=1;i&lt;=totNodes;i++)&#123; scanf("%d", candy+i); nowColor[i] = candy[i]; &#125; Dfs(); int lca,blkSiz = ceil(pow(totLen,2.0/3)); for(int i=0;i&lt;totOptn;i++)&#123; scanf("%d%d%d", &amp;opt,&amp;fr,&amp;to); switch(opt)&#123; case 0: dec[totTime] = candy[fr]; candy[fr] = inc[totTime] = to; pos[totTime++] = fr; break; case 1: lca = LCA(fr,to); if(lca == fr || lca == to) que[totQuery++] = Query(std::min(in[fr],in[to]),std::max(in[fr],in[to]),totTime,i,std::min(in[fr],in[to])/blkSiz,lca); else if(out[fr] &lt; in[to]) que[totQuery++] = Query(out[fr],in[to],totTime,i,out[fr]/blkSiz,lca); else que[totQuery++] = Query(out[to],in[fr],totTime,i,out[to]/blkSiz,lca); break; default: assert(false); break; &#125; &#125; std::sort(que,que+totQuery,Query()); fr = 0; to = -1; time = 0; for(int i=0;i&lt;totQuery;i++)&#123; Query&amp; it = que[i]; while(fr &lt; it.fr) Opt(s[fr++]); while(fr &gt; it.fr) Opt(s[--fr]); while(to &lt; it.to) Opt(s[++to]); while(to &gt; it.to) Opt(s[to--]); if(it.lca != s[fr] &amp;&amp; it.lca != s[to]) Opt(it.lca); while(time &lt; it.time)&#123; if(vis[pos[time]])&#123; Opt(pos[time]); nowColor[pos[time]] = inc[time]; Opt(pos[time]); &#125; else nowColor[pos[time]] = inc[time]; ++time; &#125; while(time &gt; it.time)&#123; if(vis[pos[--time]])&#123; Opt(pos[time]); nowColor[pos[time]] = dec[time]; Opt(pos[time]); &#125; else nowColor[pos[time]] = dec[time]; &#125; it.ans = ans; if(it.lca != s[fr] &amp;&amp; it.lca != s[to]) Opt(it.lca); &#125; std::sort(que,que+totQuery); for(int i=0;i&lt;totQuery;i++) printf("%lld\n", que[i].ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF708C Centroids]]></title>
    <url>%2F2019%2F07%2F23%2FCentroids%2F</url>
    <content type="text"><![CDATA[题目链接 一棵树的中心 $v$ 满足它所有儿子大小不超过总结点数的一半。 给定一颗 $n$ 个结点的树，你允许断开这棵树的一条边并加上一条新的边。现在对于每一个点询问它有没有可能在经过操作后成为这棵树的中心。 想要让 $v$ 成为中心，那么看上去最优的操作就是在 $v$ 最大的儿子中寻找一颗最大，但是又不超过 $\frac n2$ 个结点的子树，插到 $v$ 上作为一个直接儿子。 考虑动态规划。将给定的树中每一条边拆成两条有向边，那么任何一条边异或 1 就是它的反向边。将动态规划的状态定义在边层级上：对于连接 $i_u\to i_v$ 的边 $i$, $s_i$ 表示断开边 $i$, 以 $i_v$ 为根的子树的大小，可见 $s_{i\mbox{^}1}=n-s_i$. $c_i$ 表示断开边 $i$, 以 $i$ 为根的子树最大可以断开多大一颗子树。 一遍深搜就可以计算出 $s$ 和一部分的 $c$, 但是对于所有从儿子连向父亲的边还没有处理出来，这就需要第二次深搜，用父亲更新儿子。 需要特别注意的是，第二次深搜时父亲不能将剪掉一个儿子作为这个儿子的 $c$ 值，这就需要在之前同时保存最大和次大值在点层级上，然后同时参考这两个值来更新。 判断一个点 $u$ 是否满足条件时，只用枚举它的所有出边 $i$, 如果存在 $s_i-c_i\ge\frac n2$, 那么就不符合要求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt; constexpr auto MAXN = 800000+500;constexpr auto MAXT = MAXN&lt;&lt;1; struct Edge&#123; int fr,to; Edge()&#123;&#125; Edge(const int&amp; ifr,const int&amp; ito) : fr(ifr),to(ito) &#123;&#125;&#125;;std::vector&lt;Edge&gt; edge;std::vector&lt;int&gt; G[MAXN]; struct Set&#123; int rk1,rk2,ID; Set()&#123; rk2 = rk1 = 0; &#125; Set&amp; operator += (const int&amp; val)&#123; if(val &gt;= rk1)&#123; rk2 = rk1; rk1 = val; &#125; else rk2 = std::max(val,rk2); return *this; &#125; int Query(const int&amp; Expect) const &#123; return Expect == rk1 ? rk2 : rk1; &#125;&#125;min[MAXN];int totNodes,halfNodes;int siz[MAXT],cut[MAXT]; void Dfs1(const int&amp; nowAt,const int&amp; nowEdge = MAXT-3)&#123; siz[nowEdge] = 1; cut[nowEdge] = 0; for(const auto &amp;it : G[nowAt]) if(it != (nowEdge^1))&#123; Dfs1(edge[it].to,it); siz[nowEdge] += siz[it]; cut[nowEdge] = std::max(cut[nowEdge],cut[it]); min[nowAt] += cut[it]; &#125; siz[nowEdge^1] = totNodes-siz[nowEdge]; if(siz[nowEdge] &lt; halfNodes) cut[nowEdge] = siz[nowEdge];&#125;void Dfs2(const int&amp; nowAt,const int&amp; nowEdge = MAXT-3)&#123; min[nowAt] += cut[nowEdge^1]; for(const auto &amp;it : G[nowAt]) if(it != (nowEdge^1))&#123; if(siz[it^1] &lt; halfNodes) cut[it^1] = siz[it^1]; else cut[it^1] = min[nowAt].Query(cut[it]); Dfs2(edge[it].to, it); &#125;&#125; signed main(void)&#123; int fr,to; scanf("%d",&amp;totNodes); halfNodes = (totNodes&gt;&gt;1)+1; for(int i=1;i&lt;totNodes;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); G[fr].push_back(edge.size()); edge.push_back(Edge(fr,to)); G[to].push_back(edge.size()); edge.push_back(Edge(to,fr)); &#125; Dfs1(1);Dfs2(1); bool flag; for(int i=1;i&lt;=totNodes;i++)&#123; flag = true; for(const auto &amp;it : G[i]) if(siz[it] - cut[it] &gt;= halfNodes)&#123; flag = false; break; &#125; putchar(flag ? '1' : '0'); putchar(' '); &#125; putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1137F Matches Are Not a Child's Play]]></title>
    <url>%2F2019%2F07%2F23%2FMatches_Are_Not_a_Childs_Play%2F</url>
    <content type="text"><![CDATA[题目链接 题意简述我们定义一棵树的删除序列为：每一次将树中编号最小的叶子删掉，将该节点编号加入到当前序列的最末端，最后只剩下一个节点时将该节点的编号加入到结尾。 现在给出一棵 $n$ 个节点的树，有 $m$ 次操作： up v：将 $v$ 号节点的编号变为当前所有节点编号的 $\max + 1$. when v：查询 $v$ 在当前树的删除序列中是第几号元素 compare u v：查询 $u$ 和 $v$ 在当前树的删除序列中谁更靠前 简要做法在经过一次 up 操作后，可以发现从 $\max$ 到 $v$ 这条链上的结点会最后被删除，而且是从 $\max$ 依次删除到 $v$. 除此之外其他的结点顺序不变。给每一个结点赋予一个颜色，颜色有大小，定义后染色的颜色大，每一次 up 就是将 $\max$ 到 $v$ 染成一种新的颜色。而 when 的答案就是小于 $v$ 目前颜色的所有点加上 $v$ 的颜色序列起点到 $v$ 与 $v$ 颜色相同的点的数量。compare 操作可以拆成比较两个 when. 想要维护这些信息，颜色较小的那一部分结点可以用一个树状数组维护，剩下的部分信息的修改和查询可以通过多种不同的方法。 珂朵莉树+树链剖分先树链剖分之后建一颗珂朵莉树，由于每次 up 都是树上的一段、珂朵莉树中的很多段区间改成同一个值，所以可以维护。期望复杂度 $O(M\log^2 N)$. 需要注意的是查询不能调用 Split 方法，否则多次查询会将完整的一大段拆分成很多小段，导致时间复杂度变为 $O(NM\log N)$, 这样就需要我们额外特判一些情况，在原先的基础上直接查询统计。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;bits/stdc++.h&gt; #define abs(x) (((x)&gt;0) ? (x) : (-(x))) #define max(x,y) ((x)&gt;(y)?(x):(y))#define min(x,y) ((x)&lt;(y)?(x):(y)) constexpr auto MAXN = 300000+50;constexpr auto MAXM = 300000+50;constexpr auto MAXT = MAXN + MAXM; //BITnamespace BIT&#123; int bit_array[MAXT];#define Lowbit(x) ((x)&amp;(-(x))) void Add(int pos,const int&amp; val)&#123; if(pos&gt;0) for(;pos&lt;MAXT;pos+=Lowbit(pos)) bit_array[pos] += val; &#125; int Query(int pos)&#123; int ans = 0; for(;pos&gt;0;pos-=Lowbit(pos)) ans += bit_array[pos]; return ans; &#125;&#125;; int totNode; //Odtnamespace Odt&#123; struct Node&#123; int fr,to; mutable int val; Node()&#123;&#125; Node(const int&amp; ifr,const int&amp; ito=0,const int&amp; ival=0) : fr(ifr),to(ito),val(ival)&#123;&#125; bool operator &lt; (const Node&amp; Comp) const &#123; return fr &lt; Comp.fr; &#125; &#125;; std::set&lt;Node&gt; Odt; std::set&lt;Node&gt;::iterator Split(const int&amp; pos)&#123; //[l,pos) [pos,r] if(pos &gt; totNode) return Odt.end(); std::set&lt;Node&gt;::iterator it = --Odt.upper_bound(Node(pos)); if(it-&gt;fr == pos) return it; Odt.erase(it); int fr = it-&gt;fr,to = it-&gt;to,val = it-&gt;val; Odt.insert(Node(fr,pos-1,val)); return Odt.insert(Node(pos,to,val)).first; &#125; void Align(int fr,int to, const int&amp; val)&#123; if(fr &gt; to) std::swap(fr,to); std::set&lt;Node&gt;::iterator end = Split(to+1),beg = Split(fr); for(auto it=beg;it!=end;++it) BIT::Add(it-&gt;val,-(it-&gt;to-it-&gt;fr+1)); Odt.erase(beg,end); Odt.insert(Node(fr,to,val)); &#125; int Count(int fr,int to, const int&amp; val)&#123; int cnt = 0; if(fr &gt; to) std::swap(fr,to);/* std::set&lt;Node&gt;::iterator end = Split(to+1),beg = Split(fr); for(auto it=beg;it!=end;++it) if(it-&gt;val==val) cnt += it-&gt;to-it-&gt;fr+1; return cnt; */ assert(fr&gt;=0); std::set&lt;Node&gt;::iterator end=Odt.upper_bound(Node(to+1)),beg=--Odt.upper_bound(Node(fr)); for(auto it=beg;it!=end;++it) if(it-&gt;val==val) cnt += min(to,it-&gt;to)-max(fr,it-&gt;fr)+1; return cnt; &#125; int Query(const int&amp; targ)&#123; std::set&lt;Node&gt;::iterator it = --Odt.upper_bound(Node(targ)); return it-&gt;val; &#125;&#125;; //Node_Infoint dfn[MAXN]/*aka Index[]*/,top[MAXN],imp[MAXN],siz[MAXN],up[MAXN],depth[MAXN];std::vector&lt;int&gt; G[MAXN]; int dfs_Clock,nowColor;bool vis[MAXN]; void Dfs(const int&amp; nowAt = 1)&#123; siz[nowAt] = 1; vis[nowAt] = true; for(const auto &amp;it : G[nowAt]) if(!vis[it])&#123; up[it] = nowAt; depth[it] = depth[nowAt] + 1; Dfs(it); siz[nowAt] += siz[it]; if(siz[imp[nowAt]] &lt; siz[it]) imp[nowAt] = it; &#125;&#125;void Dfs2(const int&amp; nowAt = 1)&#123; if(top[nowAt] == 0) top[nowAt] = nowAt; vis[nowAt] = true; dfn[nowAt] = dfs_Clock++; if(!vis[imp[nowAt]])&#123; top[imp[nowAt]] = top[nowAt]; Dfs2(imp[nowAt]); &#125; for(const auto &amp;it : G[nowAt]) if(!vis[it])&#123; Dfs2(it); &#125;&#125; int Color_begin[MAXT]; int LCASet(int a,int b)&#123; int cnt = 0; while(top[a] != top[b])&#123; if(depth[top[a]] &lt; depth[top[b]]) std::swap(a,b); Odt::Align(dfn[a],dfn[top[a]],nowColor); cnt += abs(dfn[a]-dfn[top[a]])+1; a = up[top[a]]; &#125; Odt::Align(dfn[a],dfn[b],nowColor); cnt += abs(dfn[a]-dfn[b])+1; return cnt;&#125;int LCACount(int a,int b,const int&amp; val)&#123; int cnt = 0; while(top[a] != top[b])&#123; if(depth[top[a]] &lt; depth[top[b]]) std::swap(a,b); cnt += Odt::Count(dfn[a],dfn[top[a]],val); a = up[top[a]]; &#125; return cnt + Odt::Count(dfn[a],dfn[b],val);&#125; //Main Functionsvoid Up(const int&amp; targ,const int&amp; last)&#123; Color_begin[++nowColor] = last; BIT::Add(nowColor, LCASet(targ,last));&#125; int When(const int&amp; targ)&#123; int color = Odt::Query(dfn[targ]); return BIT::Query(color-1) + LCACount(targ,Color_begin[color],color);&#125; signed main(void)&#123; int totNode,totOptn,a,b,targ,last=1; char opt[15]; scanf("%d%d", &amp;totNode,&amp;totOptn); ::totNode = totNode; for(int i=1;i&lt;totNode;i++) &#123; scanf("%d%d", &amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); &#125; Dfs(); memset(vis,false,sizeof(vis)); *vis = true; Dfs2(); Odt::Odt.insert(Odt::Node(1,totNode,0)); for(int i=1;i&lt;=totNode;i++)&#123; Up(i,last); last = i; &#125; nowColor = totNode; while(totOptn--)&#123; scanf("%s", opt); switch(*opt)&#123; case 'u': scanf("%d", &amp;targ); ++nowColor; Up(targ,last); last = targ; break; case 'w': scanf("%d", &amp;targ); printf("%d\n", When(targ)); break; case 'c': scanf("%d%d", &amp;a,&amp;b); if(When(a) &lt; When(b)) printf("%d\n", a); else printf("%d\n", b); break; default: assert(false); break; &#125; &#125; return 0;&#125; L-CT另一种相对优美的方法是使用 Link-Cut Tree. 将所有相同颜色的存储在同一个 Splay 中，查询就是颜色小的加上深度更深的。up 操作时可以确定 $\max$ 就是整棵树的根，而每一次 up 操作就是一次 Make_Root 的过程。 这种方法可以保证 $O(N\log N)$ 的时间复杂度，实际上也进一步节省了大量的计算能力。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt; constexpr auto MAXN = 200000+50;constexpr auto MAXM = 200000+50;constexpr auto MAXT = MAXN+MAXM; //BITint bit_array[MAXT];#define Lowbit(x) ((x)&amp;(-(x)))void Add(int pos,const int&amp; delta)&#123; for(;pos&gt;0 &amp;&amp; pos&lt;MAXT;pos+=Lowbit(pos)) bit_array[pos] += delta;&#125;int Query(int pos)&#123; int ans = 0; for(;pos&gt;0;pos-=Lowbit(pos)) ans += bit_array[pos]; return ans;&#125; //L-CTstruct Node&#123; bool rev; int siz; int color; bool mark; int set; Node *ch[2],*up; Node()&#123; ch[0] = ch[1] = up = nullptr; mark = rev = false; siz = 1; color = 0; &#125; Node&amp; Reverse(void)&#123; rev ^= 1; std::swap(ch[0],ch[1]); return *this; &#125; Node&amp; Set(const int&amp; val)&#123; mark = true; set = color = val; return *this; &#125; Node&amp; Push_Down(void)&#123; if(rev)&#123; if(ch[0] != nullptr) ch[0]-&gt;Reverse(); if(ch[1] != nullptr) ch[1]-&gt;Reverse(); &#125; rev = false; if(mark)&#123; if(ch[0] != nullptr) ch[0]-&gt;Set(set); if(ch[1] != nullptr) ch[1]-&gt;Set(set); &#125; mark = false; return *this; &#125; bool IsRoot(void) const &#123; if(up == nullptr) return true; else return (up-&gt;ch[0] != this &amp;&amp; up-&gt;ch[1] != this); &#125; short GetPos(const Node* comp) const &#123; if(ch[1] != comp &amp;&amp; ch[0] != comp) return -1; return ch[1] == comp; &#125; Node&amp; Update(void)&#123; siz = 1; if(ch[0] != nullptr) siz += ch[0]-&gt;siz; if(ch[1] != nullptr) siz += ch[1]-&gt;siz; return *this; &#125;&#125;node[MAXN]; void Rotate(Node* targ)&#123; Node* fa = targ-&gt;up; const short pos = fa-&gt;GetPos(targ); fa-&gt;ch[pos] = targ-&gt;ch[pos^1]; if(fa-&gt;ch[pos] != nullptr) fa-&gt;ch[pos]-&gt;up = fa; if(!fa-&gt;IsRoot()) fa-&gt;up-&gt;ch[fa-&gt;up-&gt;GetPos(fa)] = targ; targ-&gt;ch[pos^1] = fa; targ-&gt;up = fa-&gt;up; fa-&gt;up = targ; fa-&gt;Update(); targ-&gt;Update();&#125;std::stack&lt;Node*&gt; S;void Spaly(Node* targ)&#123; Node* nowAt = targ; S.push(nowAt); while(!nowAt-&gt;IsRoot()) S.push(nowAt = nowAt-&gt;up); while(!S.empty())&#123; S.top()-&gt;Push_Down(); S.pop(); &#125; for(nowAt=targ; !nowAt-&gt;IsRoot() &amp;&amp; !nowAt-&gt;up-&gt;IsRoot(); Rotate(nowAt)) if(nowAt-&gt;up-&gt;GetPos(nowAt) == nowAt-&gt;up-&gt;up-&gt;GetPos(nowAt-&gt;up)) Rotate(nowAt-&gt;up); else Rotate(nowAt); if(!nowAt-&gt;IsRoot()) Rotate(nowAt);&#125; void Access(Node* nowAt)&#123; for(Node* last = nullptr; nowAt != nullptr; nowAt = nowAt-&gt;up)&#123; Spaly(nowAt); Add(nowAt-&gt;color, -(nowAt-&gt;siz - (nowAt-&gt;ch[1]==nullptr ? 0 : nowAt-&gt;ch[1]-&gt;siz))); nowAt-&gt;ch[1] = last; nowAt-&gt;Update(); last = nowAt; &#125;&#125;void Make_Root(Node* nowAt)&#123; Access(nowAt); Spaly(nowAt); nowAt-&gt;Reverse();&#125;//------------------------------------------------------------------------------------ //info Tstd::vector&lt;int&gt; G[MAXN]; bool vis[MAXN];int nowColor; Node* last = node+1; void Dfs(const int&amp; nowAt = 1)&#123; vis[nowAt] = true; for(const auto &amp;it : G[nowAt]) if(!vis[it])&#123; Dfs(it); node[it].up = node+nowAt; &#125;&#125; //Main Functionsvoid Up(Node* targ)&#123; Spaly(last); assert(last-&gt;up == nullptr); Make_Root(last = targ); targ-&gt;Set(++nowColor); Add(nowColor,targ-&gt;siz);&#125; int When(Node* targ)&#123; Spaly(targ); return Query(targ-&gt;color) - (targ-&gt;ch[0]==nullptr ? 0 : targ-&gt;ch[0]-&gt;siz);&#125; signed main(void)&#123; int totNode,totQuery,targ,a,b; char opt[15]; scanf("%d%d", &amp;totNode,&amp;totQuery); for(int i=1;i&lt;totNode;i++)&#123; scanf("%d%d", &amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); &#125; Dfs(); node[1].up = nullptr; for(int i=1;i&lt;=totNode;i++) Up(node+i); //std::cout&lt;&lt;std::endl; //for(int i=1;i&lt;=totNode;i++)&#123; Spaly(node+i); std::cout&lt;&lt;node[i].color&lt;&lt;" "&lt;&lt;Query(node[i].color)&lt;&lt;std::endl; &#125; while(totQuery--)&#123; scanf("%s", opt); switch(*opt)&#123; case 'w': //When scanf("%d", &amp;targ); printf("%d\n", When(node+targ)); break; case 'c': //Compare scanf("%d%d", &amp;a,&amp;b); printf("%d\n", When(node+a)&lt;When(node+b) ? a : b); break; case 'u': //Up scanf("%d", &amp;targ); Up(node+targ); break; default: assert(false); break; &#125; &#125; END: return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>珂朵莉树</tag>
        <tag>LCT</tag>
        <tag>树链剖分</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AT2165 Median Pyramid Hard]]></title>
    <url>%2F2019%2F07%2F23%2FMedian_Pyramid_Hard%2F</url>
    <content type="text"><![CDATA[给出一个 $N$ 层的方格金字塔,自顶向下依次标号为第 1 到第 $N$ 层。其中第 $i(1\leq i\leq N)$ 层有 $2i − 1$ 个方格。 第 $N$ 层有一个 $1$ 到 $2N-1$ 的排列,其他层的数字按以下规则生成：方格 $b$ 中填写的整数,是方格 $b$ 正下方,左下方和右下方方格所写整数的中位数。 现在给出第 $N$ 层的数字，请你求第一层的数字。 先二分一下答案 $a$. 然后将最后一行所有小于 $a$ 的数变为 0, 不小于 $a$ 的变为 1. 然后手推一些比较小的数据可以发现，最终如果底部出现了连续两个或者更多的 0 或者 1, 那么这一块会一直延续到顶端，而由于每次最左和最右的数会被抹去，所以判断一下最靠近中间的这样一个块是由什么组成的，就可以推断出正确答案和 $a$ 之间的关系。 特别地，如果最后一行是 01 交替出现的串，那么答案就是最后一行第一个数。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 400000+50;int totNums,totLine,num[MAXN]; bool val[MAXN];bool Check(const int&amp; targ)&#123; for(int i=0;i&lt;totNums;i++) val[i] = num[i]&gt;=targ; for(int i=totLine;i&lt;totNums;i++) if(val[i] == val[i-1]) return val[i]; else if(val[totNums-i] == val[totNums-i-1]) return val[totNums-i]; return *val;&#125;signed main(void)&#123; int fr = INT_MAX, to = INT_MIN,mid; scanf("%d", &amp;totLine); totNums = (totLine&lt;&lt;1)-1; for(int i=0;i&lt;totNums;i++)&#123; scanf("%d", num+i); fr = std::min(fr,num[i]); to = std::max(to,num[i]); &#125; while(fr&lt;to)&#123; mid = (1+fr+to)&gt;&gt;1; if(Check(mid)) fr = mid; else to = mid-1; &#125; printf("%d\n", fr); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO Lights]]></title>
    <url>%2F2019%2F07%2F22%2FLights%2F</url>
    <content type="text"><![CDATA[给定 $n$ 盏灯和 $m$ 条边，每一条边链接两盏灯，触发一盏灯的开关会改变这盏灯和所有与它有直接边相连的灯的状态。问最少触发多少个开关使得灯全亮。 直接用一个64位整数表示某一盏灯开关触发之后会改变的灯的集合，然后双向深搜，将前一半结果记在一个 map 里面，后面搜到一个状态直接取反，在 map 中查找。 最终时间复杂度为 $O(\frac N22^\frac N2)$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 40;int totLight,tot;std::map&lt;long long,int&gt; S; int min = INT_MAX;long long cg[MAXN];void Print(long long stat,int bits)&#123; for(int i=0;i&lt;bits;i++)&#123; putchar('0'+(stat&amp;1)); stat &gt;&gt;= 1; &#125; &#125;void Dfs1(const int&amp; nowAt, long long stat, int cnt)&#123; if(S.count(stat) &amp;&amp; S[stat]&lt;=cnt) return; if(nowAt &gt;= tot)&#123; S[stat] = cnt; //Print(stat,totLight); printf(" %d\n", cnt); return; &#125; Dfs1(nowAt+1,stat,cnt); stat ^= cg[nowAt]; Dfs1(nowAt+1,stat,cnt+1);&#125;void Dfs2(const int&amp; nowAt, long long stat, int cnt)&#123; if(cnt &gt; min) return; if(nowAt &gt;= totLight) &#123; long long req = ((1LL&lt;&lt;totLight)-1)^stat; //Print(req,totLight); printf(" %d\n", cnt); if(S.count(req)) min = std::min(min, cnt+S[req]); return; &#125; Dfs2(nowAt+1,stat,cnt); stat ^= cg[nowAt]; Dfs2(nowAt+1,stat,cnt+1);&#125;signed main(void)&#123; int totLine,a,b; scanf("%d%d", &amp;totLight,&amp;totLine); tot = totLight&gt;&gt;1; for(int i=0;i&lt;totLine;i++)&#123; scanf("%d%d", &amp;a,&amp;b); --a; --b; cg[a] |= 1LL&lt;&lt;b; cg[b] |= 1LL&lt;&lt;a; &#125; for(int i=0;i&lt;totLight;i++) cg[i] |= 1LL&lt;&lt;i; Dfs1(0,0,0); //puts("-----------------------------------"); Dfs2(tot,0,0); printf("%d\n", min); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1190A Tokitsukaze and Discard Items]]></title>
    <url>%2F2019%2F07%2F22%2FTokitsukaze_and_Discard_Items%2F</url>
    <content type="text"><![CDATA[题目链接 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt; constexpr auto MAXM = (int)1e5+500; long long totNums, totPos,siz;long long delta; long long focus = -1; long long nowBlk(const long long&amp; pos)&#123; return (pos-delta)/siz;&#125; signed main(void)&#123; int cnt = 0; long long ddelta=0,pos; std::cin&gt;&gt;totNums&gt;&gt;totPos&gt;&gt;siz; for(int i=0;i&lt;totPos;i++)&#123; std::cin&gt;&gt;pos; --pos; if(nowBlk(pos) != focus)&#123; ++cnt; delta += ddelta; ddelta = 0; focus = nowBlk(pos); &#125; ++ddelta; &#125; std::cout&lt;&lt;cnt&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1017G The Tree]]></title>
    <url>%2F2019%2F07%2F22%2FWBThe_Tree%2F</url>
    <content type="text"><![CDATA[给定一棵树，结点有颜色，要求支持三种操作： 这个操作应用于结点 $u$, 如果 $u$ 为白色，将其染黑，否则将此操作作用于 $u$ 的所有儿子上。 将 $u$ 为根的子树全部染为白色。 查询 $u$ 的颜色。 题目链接 给每一个结点 $u$ 额外记录一个值 $v_u$. 初始为 -1. 操作 1 时将对应结点的 $v_u$ 增大 1. 定义函数 Max(u) 代表从根到 $u$ 这条路径上所有的 $v_i$ 连起来形成的序列的最大后缀和。如果这个值不小于 0, 那么 $u$ 是一个黑色的结点。 这样操作 1 修改时不会对 $u$ 的祖先产生影响，同时作用于 $u$ 和 $u$ 的所有后代。 操作 2 时先将整颗子树全部赋值 -1, 然后单独修改一下 $v_u$ 使得最终 Max(u)=-1. 这样就可以消除掉 $u$ 祖先的状态对后面结点的影响。 为了维护这些赋值和查询，可以树链剖分然后线段树维护。 时间复杂度为 $O(N\log^2N)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt; constexpr auto MAXN = (int)5e5+50; std::pair&lt;int,int&gt; Merge(const std::pair&lt;int,int&gt; a,const std::pair&lt;int,int&gt; b) &#123; if(a.first == INT_MAX &amp;&amp; a.second == INT_MAX) return b; if(b.first == INT_MAX &amp;&amp; b.second == INT_MAX) return a; return std::make_pair(a.first+b.first,std::max(b.second,b.first+a.second));&#125; //SegTrnamespace SegTr&#123; struct Node&#123; int fr,to; int sum,maxSuf; bool mark; int set; Node *lft,*rgt; Node()&#123; lft = rgt = nullptr; mark = false; sum = maxSuf = -1; &#125; Node(const int&amp; ifr,const int&amp; ito) : fr(ifr),to(ito) &#123; mark = false; lft = rgt = nullptr; sum = -(to-fr+1); maxSuf = -1; &#125; Node&amp; Update(void)&#123; if(lft != nullptr)&#123; sum = lft-&gt;sum + rgt-&gt;sum; maxSuf = std::max(rgt-&gt;maxSuf,rgt-&gt;sum+lft-&gt;maxSuf); &#125; return *this; &#125; Node&amp; Set(const int&amp; val)&#123; mark = true; set = val; sum = (to-fr+1) * val; maxSuf = val&gt;=0 ? sum : val; return *this; &#125; Node&amp; Push_Down(void)&#123; if(mark &amp;&amp; lft != nullptr)&#123; lft-&gt;Set(set); rgt-&gt;Set(set); &#125; mark = false; return *this; &#125; &#125;*root; void Build(const int&amp; siz)&#123; Node *a,*b,*t; std::queue&lt;Node*&gt; que,add; for(int i=0;i&lt;siz;i++)&#123; t = new Node(i,i); que.push(t); &#125; for(;que.size()&gt;=2;std::swap(que,add))&#123; while(que.size()&gt;=2)&#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = new Node(a-&gt;fr,b-&gt;to); t-&gt;sum = a-&gt;sum + b-&gt;sum; t-&gt;maxSuf = std::max(b-&gt;maxSuf,b-&gt;sum+a-&gt;maxSuf); t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if(!que.empty())&#123; add.push(que.front()); que.pop(); &#125; &#125; root = que.front(); &#125; void Set(const int&amp; fr,const int&amp; to,const int&amp; val,Node* nowAt = root)&#123; if(nowAt == nullptr || to&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;fr) return; nowAt-&gt;Push_Down(); if(fr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=to)&#123; nowAt-&gt;Set(val); return; &#125; else &#123; Set(fr,to,val,nowAt-&gt;lft); Set(fr,to,val,nowAt-&gt;rgt); nowAt-&gt;Update(); &#125; &#125; void Add(const int&amp; targ,const int&amp; val,Node* nowAt = root)&#123; if(nowAt == nullptr || targ&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;targ) return; nowAt-&gt;Push_Down(); if(nowAt-&gt;fr == nowAt-&gt;to &amp;&amp; nowAt-&gt;fr == targ)&#123; nowAt-&gt;sum += val; nowAt-&gt;maxSuf += val; return; &#125; else &#123; Add(targ,val,nowAt-&gt;lft); Add(targ,val,nowAt-&gt;rgt); nowAt-&gt;Update(); &#125; &#125; std::pair&lt;int,int&gt; Query(int fr,int to, Node* nowAt = root)&#123; if(fr &gt; to) std::swap(fr,to); if(nowAt == nullptr || to&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;fr) return std::make_pair(INT_MAX,INT_MAX); nowAt-&gt;Push_Down(); if(fr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=to) return std::make_pair(nowAt-&gt;sum,nowAt-&gt;maxSuf); else return Merge(Query(fr,to,nowAt-&gt;lft),Query(fr,to,nowAt-&gt;rgt)); &#125;&#125;; //------------------------------------------------------------------------------------std::vector&lt;int&gt; G[MAXN]; int dfn[MAXN],top[MAXN],up[MAXN],depth[MAXN],imp[MAXN],siz[MAXN];int dfs_clock; bool vis[MAXN];void Dfs(const int&amp; nowAt = 1)&#123; siz[nowAt] = 1; vis[nowAt] = true; for(const auto &amp;it : G[nowAt]) if(!vis[it])&#123; up[it] = nowAt; depth[it] = depth[nowAt] + 1; Dfs(it); siz[nowAt] += siz[it]; if(siz[imp[nowAt]] &lt; siz[it]) imp[nowAt] = it; &#125;&#125;void Dfs2(const int&amp; nowAt = 1)&#123; dfn[nowAt] = dfs_clock++; vis[nowAt] = true; if(top[nowAt] == 0) top[nowAt] = nowAt; if(!vis[imp[nowAt]])&#123; top[imp[nowAt]] = top[nowAt]; Dfs2(imp[nowAt]); &#125; for(const auto &amp;it : G[nowAt]) if(!vis[it]) Dfs2(it);&#125;//------------------------------------------------------------------------------------ int Max(int nowAt)&#123; std::pair&lt;int,int&gt; ans; ans = std::make_pair(INT_MAX,INT_MAX); while(nowAt != 0)&#123; ans = Merge(SegTr::Query(dfn[nowAt],dfn[top[nowAt]]), ans); nowAt = up[top[nowAt]]; &#125; return ans.second;&#125; signed main(void)&#123; int totNode,totOptn,opt,targ,max; scanf("%d%d", &amp;totNode,&amp;totOptn); for(int i=2;i&lt;=totNode;i++)&#123; scanf("%d", &amp;targ); G[i].push_back(targ); G[targ].push_back(i); &#125; Dfs(); memset(vis,false,sizeof(vis)); *vis = true; Dfs2(); assert(dfs_clock == totNode); SegTr::Build(totNode); while(totOptn--)&#123; scanf("%d%d", &amp;opt,&amp;targ); switch(opt)&#123; case 1: SegTr::Add(dfn[targ],1); break; case 2: max = Max(targ); SegTr::Add(dfn[targ],-1-max); SegTr::Set(dfn[targ]+1,dfn[targ]+siz[targ]-1,-1); break; case 3: max = Max(targ); if(max &gt;= 0) puts("black"); else puts("white"); break; default: assert(false); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】ZOJ1450 Minimal Circle]]></title>
    <url>%2F2019%2F07%2F18%2FMinimal_Circle%2F</url>
    <content type="text"><![CDATA[包含给定点 $P_1,P_2,\cdots,P_n$ 的最小圆圆心坐标和半径。 首先我们假定已经处理了 $k$ 个点，得到包含 $P_1,P_2,\cdots,P_k$ 的最小圆，这时检查一下 $P_{k+1}$ 是否在圆内，如果不在则说明这个点一定在包含 $P_1,P_2,\cdots,P_{k+1}$ 的最小圆边上，枚举一下剩下两个点，然后重复到包含全部的点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define sqr(x) ((x)*(x))constexpr auto MAXN = 100000+50;constexpr double EPS = 1e-10;struct Vector2&#123; double y,x; Vector2()&#123;&#125; Vector2(const double&amp; iy,const double&amp; ix) : y(iy),x(ix) &#123;&#125;&#125;;typedef Vector2 Point;double Distance(const Point &amp;a,const Point &amp;b)&#123; return sqrt(sqr(a.y-b.y)+sqr(a.x-b.x));&#125;Point pt[MAXN];Point O; double r;void Mk_Cir(Point* p1,Point* p2,Point* p3)&#123; double a=2*(p2-&gt;x-p1-&gt;x), b=2*(p2-&gt;y-p1-&gt;y), c=sqr(p2-&gt;x)+sqr(p2-&gt;y)-sqr(p1-&gt;x)-sqr(p1-&gt;y), d=2*(p3-&gt;x-p1-&gt;x),e=2*(p3-&gt;y-p1-&gt;y), f=sqr(p3-&gt;x)+sqr(p3-&gt;y)-sqr(p1-&gt;x)-sqr(p1-&gt;y); O.x = (c*e-f*b)/(a*e-b*d); O.y = (c*d-a*f)/(b*d-a*e); r = Distance(O,*p1);&#125;signed main(void)&#123; int totPoint; while(scanf("%d",&amp;totPoint)!=EOF &amp;&amp; totPoint)&#123; for(int i=0;i&lt;totPoint;i++) scanf("%lf%lf", &amp;pt[i].x,&amp;pt[i].y); O = *pt; r = 0; for(int i=1;i&lt;totPoint;i++) if(Distance(pt[i],O) &gt; r+EPS)&#123; O = pt[i]; r = 0; for(int j=0;j&lt;i;j++) if(Distance(pt[j],O) &gt; r+EPS)&#123; O = Vector2((pt[i].y+pt[j].y)/2,(pt[i].x+pt[j].x)/2); r = Distance(pt[j],O); for(int k=0;k&lt;j;k++) if(Distance(pt[k],O) &gt; r+EPS) Mk_Cir(pt+i,pt+j,pt+k); &#125; &#125; printf("%.2lf %.2lf %.2lf\n",O.x,O.y,r); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】缩小社交圈]]></title>
    <url>%2F2019%2F07%2F18%2FSocial%2F</url>
    <content type="text"><![CDATA[给定 $n$ 个区间，第 $i$ 个为 $[l_i,r_i]$. 从中选出一些组成一个集合 $S$, 将 $S$ 中所有的线段当做点，然后在相交的两个线段代表的点之间连边，要求最终得到一颗树。问有多少种可供选择的方案。 链接 可以看出，最终一个合法的方案中选中了的所有区间并在一起是连续的一段，而且不存在任何一个点被三个区间同时覆盖。 将所有区间以右端点为第一关键字，左端点为第二关键字排序。 考虑动态规划。定义 $D_{i,j}$ 为最后一个区间为 $i$, 倒数第二个区间为 $j$ 所有合法方案总数。当 $l_i&gt;r_j$ 时，$D_{i,j}=0$. 否则需要根据 $i,j$ 左端点之间的大小关系进行转移。 D_{i,j}=\begin{cases} 0&\mbox{if}\;l_i>r_j\\ 1+\sum_{k}[r_k]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】JSOI2008 Blue Mary开公司]]></title>
    <url>%2F2019%2F07%2F17%2FBlue_Mary%2F</url>
    <content type="text"><![CDATA[这道题是李超线段树模板题。在线段树上每一个结点代表的区间维护一个最大值最长的直线，修改时下放不那么长的直线，查询将所有包含的线段代表的直线取最大值即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;constexpr auto MAXDAY = 50000+50;constexpr auto MAXN = 100000+5;struct Node&#123; int fr,to,ID; Node *lft,*rgt; Node()&#123; lft = rgt = nullptr; ID = -1; &#125; Node(const int&amp; ifr,const int &amp;ito) : fr(ifr),to(ito) &#123; lft = rgt = nullptr; ID = -1; &#125;&#125;*root;void Build(void)&#123; Node *a,*b,*t; std::queue&lt;Node*&gt; que,add; for(int i=1;i&lt;MAXDAY;i++)&#123; t = new Node(i,i); que.push(t); &#125; for(;que.size()&gt;=2;std::swap(que,add))&#123; while(que.size()&gt;=2)&#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = new Node(a-&gt;fr,b-&gt;to); t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if(!que.empty())&#123; add.push(que.front()); que.pop(); &#125; &#125; root = que.front();&#125;double k[MAXN],b[MAXN];inline double val(const int&amp; id,const int&amp; x)&#123; return k[id]*(x-1)+b[id];&#125;void Add(const int&amp; ID, Node* nowAt)&#123; if(nowAt == nullptr) return; if(nowAt-&gt;ID == -1 || val(ID,nowAt-&gt;fr)&gt;val(nowAt-&gt;ID,nowAt-&gt;fr) &amp;&amp; val(ID,nowAt-&gt;to)&gt;val(nowAt-&gt;ID,nowAt-&gt;to)) &#123; nowAt-&gt;ID = ID; return; &#125; if(val(ID,nowAt-&gt;fr)&lt;=val(nowAt-&gt;ID,nowAt-&gt;fr) &amp;&amp; val(ID,nowAt-&gt;to)&lt;=val(nowAt-&gt;ID,nowAt-&gt;to)) return; assert(nowAt-&gt;lft != nullptr &amp;&amp; nowAt-&gt;rgt != nullptr); int mid = nowAt-&gt;lft-&gt;to; if(k[ID] &gt; k[nowAt-&gt;ID]) if(val(ID,mid) &gt; val(nowAt-&gt;ID,mid))&#123; Add(nowAt-&gt;ID, nowAt-&gt;lft); nowAt-&gt;ID = ID; &#125; else Add(ID,nowAt-&gt;rgt); else if(val(ID,mid) &gt; val(nowAt-&gt;ID,mid))&#123; Add(nowAt-&gt;ID, nowAt-&gt;rgt); nowAt-&gt;ID = ID; &#125; else Add(ID,nowAt-&gt;lft);&#125;double max;void Query(const int&amp; targ, Node* nowAt)&#123; if(nowAt == nullptr || nowAt-&gt;ID == -1) return; if(targ&lt;nowAt-&gt;fr || targ&gt;nowAt-&gt;to)return; max = std::max(max,val(nowAt-&gt;ID,targ)); Query(targ,nowAt-&gt;lft); Query(targ,nowAt-&gt;rgt);&#125;signed main(void)&#123; int totOptn,targ,beg,add,cnt=0; char opt[15]; Build(); scanf("%d", &amp;totOptn); while(totOptn--)&#123; scanf("%s", opt); switch(*opt)&#123; case 'P': scanf("%lf%lf", b+cnt,k+cnt); Add(cnt,root); ++cnt; break; case 'Q': scanf("%d", &amp;targ); max = INT_MIN; Query(targ,root); if(max&lt;0) puts("0"); else printf("%d\n", (int)(max/100)); break; default: assert(false); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HAOI2016 字符合并]]></title>
    <url>%2F2019%2F07%2F15%2FCMerge%2F</url>
    <content type="text"><![CDATA[有一个长度为 $N$ 的 01 串，你可以每次将相邻的 $k$ 个字符合并，得到一个新的字符并获得一定分数。得到的新字符和分数由这 $k$ 个字符确定。你需要求出你能获得的最大分数。 定义 $D_{i,j,S}$ 其中 $i,j$ 代表一个区间 $[i,j]$, $S$ 描述一个状态。数值代表将 $s_{i,j}$ 经过若干次合并，最终得到 $S$ 的最大分数。 在转移的时候，枚举 $i,j,S$ 和一个整数 $t\in\left[0,\lfloor\frac{i-j}{k-1}\rfloor\right]$. 代表状态 $k$ 最右边的一位数是按照某种顺序合并 $s\left[j-t(k-1),j\right]$ 得到的。如果当前区间包含了超过 $k$ 个字符，那么将其中的 $k$ 个合并，将会继续得到分数，所以枚举 $S$ 时不应超过 $k$ 位。 最终的答案为 $\max_S\left\{D_{0,N-1,S}\right\}$. 总时间复杂度为 $O(N^22^K)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;bool ReadChar(void)&#123; char in; do in = getchar(); while(in!='0' &amp;&amp; in!='1'); return in=='1';&#125;constexpr auto MAXN = 300+5;constexpr auto MAXK = 1&lt;&lt;8;constexpr long long INT64MIN = -(1LL&lt;&lt;60);long long D[MAXN][MAXN][MAXK],pts[MAXK];int charAt[MAXN],rkChar[MAXK];signed main(void)&#123; int totLen, len,mgLen,totStat,str; long long res[2]; scanf("%d%d", &amp;totLen,&amp;mgLen); totStat = 1&lt;&lt;mgLen; for(int i=0;i&lt;totLen;i++) scanf("%d", charAt+i); for(int i=0;i&lt;totStat;i++) scanf("%d%lld", rkChar+i,pts+i); for(int i=0;i&lt;totLen;i++) for(int j=0;j&lt;totLen;j++) for(int k=0;k&lt;totStat;k++) D[i][j][k] = INT64MIN; for(int i=totLen-1;i&gt;=0;i--) for(int j=i;j&lt;totLen;j++)&#123; if(i == j) &#123; D[i][j][charAt[i]] = 0; continue; &#125; len = (j-i)%(mgLen-1); if(len == 0) len = mgLen-1; for(int ct=j;ct&gt;i;ct-=mgLen-1) for(int stat=0;stat&lt;1&lt;&lt;len;stat++) &#123; D[i][j][stat&lt;&lt;1] = std::max(D[i][j][stat&lt;&lt;1], D[i][ct-1][stat]+D[ct][j][0]); D[i][j][stat&lt;&lt;1|1] = std::max(D[i][j][stat&lt;&lt;1|1], D[i][ct-1][stat]+D[ct][j][1]); &#125; if(len == mgLen-1)&#123; *res = res[1] = INT64MIN; for(int stat=0;stat&lt;totStat;stat++) res[rkChar[stat]] = std::max(res[rkChar[stat]], D[i][j][stat]+pts[stat]); D[i][j][0] = *res; D[i][j][1] = res[1]; &#125; &#125; long long ans = INT64_MIN; for(int i=0;i&lt;totStat;i++) ans = std::max(ans,D[0][totLen-1][i]); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】Chin1]]></title>
    <url>%2F2019%2F07%2F10%2FChin1%2F</url>
    <content type="text"><![CDATA[考试开始了，可是蒟蒻 HansBug 脑中还是一片空白。哦不！准确的说是乱七八糟的。现在首要任务就是帮蒟蒻 HansBug 理理思维。假设 HansBug 的思维是一长串字符串（字符串中包含且仅包含26个字母），现在的你，有一张神奇的药方，上面依次包含了三种操作： 获取第 $x$ 到第 $y$ 个字符中字母 $k$ 出现了多少次 将第 $x$ 到第 $y$ 个字符全部赋值为字母 $k$ 将第 $x$ 到第 $y$ 个字符按照 $A-Z$ 的顺序排序 你欣喜若狂之时，可是他脑细胞和RP已经因为之前过度紧张消耗殆尽，眼看试卷最后还有一篇800字的作文呢，所以这个关键的任务就交给你啦！ 这道题目可以用珂朵莉树做。首先将所有涉及的字母全部转换为大写，然后 2 为常规操作，暴力计算 1，操作 3 先将这个区间对应的结点提取出来，所有信息存储在 26 个桶里面，然后删除原结点，统一插入即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 50000+50;constexpr auto MAXK = 26;char ReadChar(void);struct Node&#123; int l,r; mutable char val; Node(void)&#123;&#125; Node(const int &amp;il) : l(il) &#123;&#125; Node(const int &amp;il,const int&amp; ir, const char &amp;ival) : l(il),r(ir),val(ival) &#123;&#125; inline bool operator &lt; (const Node&amp; Comp) const &#123; return l &lt; Comp.l; &#125;&#125;;int totLen;std::set&lt;Node&gt; Odt;// fr&lt;=pos&lt;=to =&gt; [fr,pos) [pos,to]std::set&lt;Node&gt;::iterator Split(const int &amp;pos)&#123; if(pos &gt;= totLen) return (std::set&lt;Node&gt;::iterator)Odt.end(); std::set&lt;Node&gt;::iterator it = --Odt.upper_bound(Node(pos)); if(it-&gt;l == pos) return it; int l = it-&gt;l, r = it-&gt;r; char val = it-&gt;val; Odt.erase(it); Odt.insert(Node(l,pos-1,val)); return Odt.insert(Node(pos,r,val)).first;&#125;void Assign(const int&amp; fr, const int&amp; to, const char&amp; val)&#123; std::set&lt;Node&gt;::iterator end = Split(to+1), beg = Split(fr); Odt.erase(beg,end); Odt.insert(Node(fr,to,val));&#125;signed main(void)&#123; int totOptn,opt,fr,to,lastPos,ans,nowPos,cnt[MAXK]=&#123;&#125;; char val,last; scanf("%d%d", &amp;totLen,&amp;totOptn); last = ReadChar(); lastPos = 0; for(int i=1;i&lt;totLen;i++) if((val = ReadChar()) != last)&#123; Odt.insert(Node(lastPos,i-1,last)); lastPos = i; last = val; &#125; Odt.insert(Node(lastPos,totLen-1,val)); std::set&lt;Node&gt;::iterator beg,end; while(totOptn--)&#123; scanf("%d", &amp;opt); switch(opt)&#123; case 1: scanf("%d%d", &amp;fr,&amp;to); ans = 0; val = ReadChar(); end = Split(to); beg = Split(fr-1); for(auto it = beg;it!=end;it++) if(it-&gt;val == val) ans += it-&gt;r-it-&gt;l+1; printf("%d\n", ans); break; case 2: scanf("%d%d", &amp;fr,&amp;to); val = ReadChar(); --fr; --to; Assign(fr,to,val); break; case 3: scanf("%d%d", &amp;fr,&amp;to); memset(cnt,0,sizeof(cnt)); end = Split(to); beg = Split(--fr); nowPos = fr; for(auto it = beg;it!=end;it++) cnt[it-&gt;val-'A'] += it-&gt;r-it-&gt;l+1; Odt.erase(beg,end); for(int i=0;i&lt;MAXK;i++) if(cnt[i])&#123; Odt.insert(Node(nowPos,nowPos+cnt[i]-1,i+'A')); nowPos += cnt[i]; &#125; assert(nowPos == to); break; default: assert(false); break; &#125; &#125; return 0;&#125;char ReadChar(void)&#123; char in; do in = getchar(); while(!(('a'&lt;=in&amp;&amp;in&lt;='z') || ('A'&lt;=in&amp;&amp;in&lt;='Z'))); return (char)toupper(in);&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】花园]]></title>
    <url>%2F2019%2F07%2F10%2FGarden%2F</url>
    <content type="text"><![CDATA[小 $L$ 有一座环形花园，沿花园的顺时针方向，他把各个花圃编号为 $1-N(2\leq N\leq10^{15})$. 他的环形花园每天都会换一个新花样，但他的花园都不外乎一个规则，任意相邻 $M(2\leq M\leq 5,M\leq N)$ 个花圃中有不超过 $K(1\leq K&lt;M)$ 个 $C$ 形的花圃，其余花圃均为 $P$ 形的花圃。 考虑动态规划，我们将一个位置上 $C$ 型花圃用 1 表示，用 0 表示 $P$ 型花圃，规定状压 $M$ 位。假定最开始 $M$ 位的二进制串是 $Q$, 我们每转移一次，就是将当前状态左移一位，然后加上一个合适的花圃，使得符合条件，那么我们这个初始状态对答案的贡献就是转移 $N$ 次，最后得到 $Q$ 的方案数量。 如果我们将可能的转移之间用矩阵 $A$ 描述，然后矩阵快速幂加速动态规划，那么可以在 $O(M^3\log N)$ 时间复杂度内计算出 $T=A^N$. 然后枚举初始的 $Q$, 发现答案就是 $T$ 的主对角线所有数值之和。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;constexpr auto MAXT = 32;constexpr long long MOD = 1000000007LL;int Bitcount(int val)&#123; int cnt = 0; while(val)&#123; cnt += val&amp;1; val&gt;&gt;=1; &#125; return cnt;&#125;struct Matrix&#123; long long val[MAXT][MAXT]; Matrix(void)&#123; memset(val,0,sizeof(val)); &#125; Matrix operator * (const Matrix&amp; times) const &#123; Matrix ans; for(int i=0;i&lt;MAXT;i++) for(int j=0;j&lt;MAXT;j++) for(int k=0;k&lt;MAXT;k++) (ans.val[i][j] += val[i][k] * times.val[k][j]) %= MOD; return ans; &#125; Matrix&amp; operator *= (const Matrix&amp; times) &#123; *this = *this * times; return *this; &#125;&#125;A;Matrix Pow(Matrix a, long long pows)&#123; Matrix ans; for(int i=0;i&lt;MAXT;i++) ans.val[i][i] = 1; for(;pows;a*=a,pows&gt;&gt;=1) if(pows&amp;1) ans *= a; return ans;&#125;signed main(void)&#123; int m,k,nx1,nx0; long long ans = 0,n; scanf("%lld%d%d",&amp;n,&amp;m,&amp;k); for(int i=(1&lt;&lt;m)-1;i&gt;=0;i--)&#123; nx0 = ((i&lt;&lt;1)&amp;(1&lt;&lt;m)-1); nx1 = nx0 | 1; if(Bitcount(nx0)&lt;=k) A.val[nx0][i] = 1; if(Bitcount(nx1)&lt;=k) A.val[nx1][i] = 1; &#125; A = Pow(A,n); for(int i=(1&lt;&lt;m)-1;i&gt;=0;i--) if(Bitcount(i)&lt;=k) (ans += A.val[i][i]) %= MOD; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】康拓展开]]></title>
    <url>%2F2019%2F07%2F09%2FCantor%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 1000000+50;constexpr long long MOD = 998244353;int num[MAXN],sum[MAXN],totNums;#define Lowbit(x) ((x)&amp;(-(x)))void Add(int pos,int delta)&#123; for(;pos&lt;=totNums;pos+=Lowbit(pos)) sum[pos] += delta;&#125;long long Query(int pos)&#123; long long sum = 0; for(;pos;pos-=Lowbit(pos)) sum += ::sum[pos]; return sum;&#125;signed main(void)&#123; long long ans = 0; scanf("%d", &amp;totNums); for(int i=0;i&lt;totNums;i++)&#123; scanf("%d", num+i);Add(num[i],1); &#125; for(int i=0;i&lt;totNums-1;i++)&#123; ((ans += (Query(num[i])-1)) *= totNums-i-1) %= MOD; Add(num[i],-1); &#125; printf("%lld\n", ans+1); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【题解】打雪仗]]></title>
    <url>%2F2019%2F07%2F06%2FFSnow%2F</url>
    <content type="text"><![CDATA[这是一道通信题。 小 $A$ (Alice) 有一个长度为 $2n$ 的 $01$ 字符串 $S$ ，小 $B$ (Bob) 有 ${1,\cdots,2n}$ 这些下标中的 $n$ 个：$p_1,\cdots,p_n$. 小 $A$ 和 小 $B$ 可以相互之间可以发送字符（但只能发送 “$0$” 或者 “$1$” 两种）。请为小 $A$ 和小 $B$ 设计一种通信方式，使得小 $B$ 最终能知道这 $n$ 个下标所对应的字符 $S[p_1],S[p_2],\cdots,S[p_n]$. 两人中发送字符数较多的那一个不应发送超过 $m$ 个字符。 将字符串分成三段，长度分别为 $l_1=l_2=\frac23n$, $l_3=2n-l_1-l_2$. 读入完成之后 Bob 先将下标也分成这样三段，看一下哪一段下标最多，然后将段的编号转成两位二进制数发给 Alice. Alice 将这一整段直接全部发给 Bob. Bob 将剩下两段转换为一个 01 序列，0 代表这个位置不在下标集合中，1 代表 Bob 需要知道这个下标对应的字符。 Alice 只在收到 1 时发送相应位置的字符。 最终两人发送的字符数量都大约在 $\frac43n$ 左右。代码如下： Alice 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (1000&lt;&lt;1)+50;char s[3][MAXN],str[MAXN],rec[MAXN];signed main(void)&#123; FILE *in = fopen("alice.in", "r"); int totNums,totTimes,l1,l2,l3,totLen; fscanf(in,"%d%d", &amp;totNums,&amp;totTimes); totLen = totNums&lt;&lt;1; l1 = l2 = totLen/3; l3 = totLen-l1-l2; fscanf(in,"%s", str); for(int i=0;i&lt;l1;i++) s[0][i] = str[i]; for(int i=0;i&lt;l2;i++) s[1][i] = str[i+l1]; for(int i=0;i&lt;l3;i++) s[2][i] = str[i+l1+l2]; char bit1,bit2; int len=totLen,fr,to; scanf("%c%c", &amp;bit1,&amp;bit2); if(bit1=='0' &amp;&amp; bit2=='1')&#123; for(int i=0;i&lt;l1;i++)&#123; printf("%c", s[0][i]);fflush(stdout); &#125; len-=l1; fr=0;to=l1; &#125; else if(bit1=='1' &amp;&amp; bit2=='0') &#123; for(int i=0;i&lt;l2;i++)&#123; printf("%c", s[1][i]);fflush(stdout); &#125; len-=l2; fr=l1;to=l1+l2; &#125; else &#123; for(int i=0;i&lt;l3;i++)&#123; printf("%c", s[2][i]);fflush(stdout); &#125; len-=l3; fr=l1+l2;to=totLen; &#125; //fflush(stdout); for(int i=0;i&lt;totLen;i++)&#123; if(i == fr) i = to; if(getchar() == '1')&#123; putchar(str[i]); fflush(stdout); &#125; &#125; return 0;&#125; Bob 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (1000&lt;&lt;1)+50;int pos[MAXN];char ans[MAXN],rec[MAXN];signed main(void)&#123; FILE *in = fopen("bob.in","r"), *out = fopen("bob.out","w"); int totNums,totTimes,l1,l2,l3,cnt1=0,cnt2=0,cnt3=0,totLen; fscanf(in,"%d%d", &amp;totNums,&amp;totTimes); totLen = totNums&lt;&lt;1; l1 = l2 = totLen/3; l3 = totLen-l1-l2; for(int i=0;i&lt;totNums;i++)&#123; fscanf(in,"%d",pos+i); --pos[i]; if(pos[i]&lt;l1) cnt1++; else if(pos[i]&lt;l1+l2) cnt2++; else cnt3++; &#125; int fr,to,len=totLen; if(cnt1&gt;cnt2 &amp;&amp; cnt1&gt;cnt3)&#123; printf("01");fflush(stdout); for(int i=0;i&lt;l1;i++) ans[i] = getchar(); fr=0;to=l1; len-=l1; &#125; else if(cnt2&gt;cnt1 &amp;&amp; cnt2&gt;cnt3) &#123; printf("10");fflush(stdout); for(int i=l1;i&lt;l1+l2;i++) ans[i] = getchar(); fr=l1;to=l1+l2; len-=l2; &#125; else &#123; printf("11");fflush(stdout); for(int i=l1+l2;i&lt;totLen;i++) ans[i] = getchar(); fr=l1+l2;to=totLen; len-=l3; &#125; int nowAt=0; for(int i=0;i&lt;totLen;i++)&#123; if(i == fr) i = to; while(pos[nowAt] &lt; i &amp;&amp; nowAt&lt;totNums) ++nowAt; if(pos[nowAt] == i)&#123; putchar('1');fflush(stdout); ans[i] = getchar(); ++nowAt; &#125; else&#123; putchar('0');fflush(stdout); &#125; &#125; for(int i=0;i&lt;totNums;i++) fprintf(out,"%c",ans[pos[i]]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】JLOI2015 城池攻占]]></title>
    <url>%2F2019%2F07%2F05%2FCity%2F</url>
    <content type="text"><![CDATA[小铭铭最近获得了一副新的桌游，游戏中需要用 $m$ 个骑士攻占 $n$ 个城池。这 $n$ 个城池用 $1$ 到 $n$ 的整数表示。除 $1$ 号城池外，城池 $i$ 会受到另一座城池 $f_i$ 的管辖，其中 $f_i &lt;i$. 也就是说，所有城池构成了一棵有根树。这 $m$ 个骑士用 $1$ 到 $m$ 的整数表示，其中第 $i$ 个骑士的初始战斗力为 $s_i$，第一个攻击的城池为 $c_i$. 每个城池有一个防御值 $h_i$，如果一个骑士的战斗力大于等于城池的生命值，那么骑士就可以占领这座城池；否则占领失败，骑士将在这座城池牺牲。占领一个城池以后，骑士的战斗力将发生变化，然后继续攻击管辖这座城池的城池，直到占领 $1$ 号城池，或牺牲为止。 除 $1$ 号城池外，每个城池 $i$ 会给出一个战斗力变化参数 $a_i,v_i$。若 $a_i =0$，攻占城池 $i$ 以后骑士战斗力会增加 $v_i$；若 $a_i =1$，攻占城池 $i$ 以后，战斗力会乘以 $v_i$. 注意每个骑士是单独计算的。也就是说一个骑士攻击一座城池，不管结果如何，均不会影响其他骑士攻击这座城池的结果。 现在的问题是，对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。 首先对于每一个结点建立一颗左偏树，最开始包含第一个攻击这个城市的骑士。然后将整棵树搜一遍，将儿子节点的左偏树合并上来，然后不断检查顶部元素是否不小于当前城市的防御值，弹出在这里牺牲的骑士，并记录答案。 最终我们需要在左偏树上打上标记，记录战斗力乘和加的变化和攻占城池的数目变化，然后每一次到达这个结点都执行一下 Push_Down() 方法。 由于最多弹出 $M$ 个骑士，最多合并 $N$ 次，所以总时间复杂度为 $O(N\log N+M\log N)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 300000+50;struct Node&#123; long long val,times,add; int addcnt; int dist; int cnt,ID; Node *lft,*rgt; Node(void) &#123; rgt = lft = nullptr; times = 1; addcnt = cnt = add = 0; &#125; Node(const long long &amp;ival, const int&amp; iid) : val(ival),ID(iid) &#123; rgt = lft = nullptr; times = 1; addcnt = cnt = add = 0; &#125; Node&amp; Push_Down(void)&#123; if(times==1 &amp;&amp; add==0 &amp;&amp; addcnt==0) return *this; (val *= times) += add; cnt += addcnt; if(lft != nullptr) &#123; lft-&gt;times *= times; (lft-&gt;add *= times) += add; lft-&gt;addcnt += addcnt; &#125; if(rgt != nullptr) &#123; rgt-&gt;times *= times; (rgt-&gt;add *= times) += add; rgt-&gt;addcnt += addcnt; &#125; addcnt = add = 0; times = 1; return *this; &#125;&#125;*root[MAXN];Node* Merge(Node* a,Node* b)&#123; if(a==b || a==nullptr || b==nullptr) return a==nullptr ? b : a; a-&gt;Push_Down(); b-&gt;Push_Down(); if(a-&gt;val &gt; b-&gt;val) std::swap(a,b); a-&gt;rgt = Merge(a-&gt;rgt,b); if(a-&gt;lft == nullptr || a-&gt;lft-&gt;dist&lt;a-&gt;rgt-&gt;dist) std::swap(a-&gt;lft,a-&gt;rgt); a-&gt;dist = 1 + (a-&gt;rgt==nullptr ? -1 : a-&gt;rgt-&gt;dist); return a;&#125;long long Top(Node* targ)&#123; targ-&gt;Push_Down(); return targ-&gt;val; &#125;Node* Pop(Node*&amp; targ)&#123; targ-&gt;Push_Down(); return targ = Merge(targ-&gt;lft, targ-&gt;rgt); &#125;bool vis[MAXN]; long long delta[MAXN],def[MAXN]; int deltaType[MAXN];std::vector&lt;int&gt; G[MAXN];int dechere[MAXN],cntcity[MAXN];void Dfs(const int&amp;);signed main(void)&#123; int totNums,totCity,fa,targ; long long val; Node* t; scanf("%d%d", &amp;totCity, &amp;totNums); for(int i=0;i&lt;totCity;i++) scanf("%lld", def+i); for(int i=1;i&lt;totCity;i++)&#123; scanf("%d%d%lld", &amp;fa,deltaType+i,delta+i); G[fa-1].push_back(i); &#125; for(int i=0;i&lt;totNums;i++)&#123; scanf("%lld%d", &amp;val,&amp;targ); --targ; t = new Node(val,i); root[targ] = Merge(root[targ], t); &#125; memset(vis,false,sizeof(vis)); Dfs(0); while(*root != nullptr) &#123; (*root)-&gt;Push_Down(); cntcity[(*root)-&gt;ID] = (*root)-&gt;cnt; Pop(*root); &#125; for(int i=0;i&lt;totCity;i++) printf("%d\n", dechere[i]); for(int i=0;i&lt;totNums;i++) printf("%d\n", cntcity[i]); return 0;&#125;void Dfs(const int&amp; nowAt = 0)&#123; vis[nowAt] = true; for(const auto &amp;it : G[nowAt]) if(!vis[it])&#123; Dfs(it); root[nowAt] = Merge(root[nowAt], root[it]); &#125; while(root[nowAt]!=nullptr &amp;&amp; Top(root[nowAt]) &lt; def[nowAt])&#123; ++dechere[nowAt]; cntcity[root[nowAt]-&gt;ID] = root[nowAt]-&gt;cnt; Pop(root[nowAt]); &#125; if(root[nowAt] == nullptr) return; if(deltaType[nowAt] == 0) root[nowAt]-&gt;add += delta[nowAt]; else &#123; root[nowAt]-&gt;add *= delta[nowAt]; root[nowAt]-&gt;times *= delta[nowAt]; &#125; root[nowAt]-&gt;addcnt++;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】APIO2012 派遣]]></title>
    <url>%2F2019%2F07%2F05%2FDispatch%2F</url>
    <content type="text"><![CDATA[有 $n$ 个忍者形成一个树形结构，第 $i$ 个忍者有薪水 $c_i$ 和领导力 $l_i$. 现在需要用不超过 $M$ 的预算派遣若干个忍者给顾客，顾客的满意度定义为派遣的忍者数量乘上所有被派遣忍者 LCA 的领导力。需要让满意度最大。 考虑动态规划，记 $f_i$ 代表以 $i$ 为领导者时的最大满意度。我们将整棵树搜一遍，每一个点维护一个集合，一开始包含当前子树中所有的忍者，如果发现预算不够，就不断从中删除薪水最高的忍者。一个忍者如果在一个时刻被删除，那么就永远不会再加入到集合当中，因此这个集合可以从子树转移过来，同时考虑到取最大值和合并，可以用左偏树维护。 由于一个忍者最多被删除一次，集合最多合并 $N$ 次。因此总时间复杂度为 $O(N\log N)$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 100000+50;int cnt[MAXN];struct Node&#123; int val,dist; Node *lft,*rgt; Node(void)&#123; lft = rgt = nullptr; &#125; Node(const int&amp; ival) : val(ival) &#123; rgt = lft = nullptr; &#125;&#125;*root[MAXN];Node* Merge(Node* a,Node *b)&#123; if(a==b || a==nullptr || b==nullptr) return a==nullptr ? b : a; if(a-&gt;val &lt; b-&gt;val) std::swap(a,b); a-&gt;rgt = Merge(a-&gt;rgt,b); if(a-&gt;lft==nullptr || a-&gt;lft-&gt;dist&lt;a-&gt;rgt-&gt;dist) std::swap(a-&gt;lft,a-&gt;rgt); a-&gt;dist = 1 + (a-&gt;rgt==nullptr ? -1 : a-&gt;rgt-&gt;dist); return a;&#125;Node* Pop(Node*&amp; targ)&#123; Node* del = targ; targ = Merge(targ-&gt;lft,targ-&gt;rgt); delete del; return targ;&#125;long long totmon;long long max = INT64_MIN;long long val[MAXN],mon[MAXN];std::vector&lt;int&gt; G[MAXN];void Dfs(const int&amp;);signed main(void)&#123; int totRj,fa; scanf("%d%lld", &amp;totRj,&amp;totmon); for(int i=0;i&lt;totRj;i++)&#123; scanf("%d%lld%lld", &amp;fa,mon+i+1,val+i+1); G[fa].push_back(i+1); &#125; Dfs(1); printf("%lld\n", max); return 0;&#125;void Dfs(const int&amp; nowAt)&#123; root[nowAt] = new Node(mon[nowAt]); cnt[nowAt] = 1; for(const auto &amp;it : G[nowAt])&#123; Dfs(it); root[nowAt] = Merge(root[nowAt], root[it]); mon[nowAt] += mon[it]; cnt[nowAt] += cnt[it]; &#125; while(mon[nowAt] &gt; totmon)&#123; mon[nowAt] -= root[nowAt]-&gt;val; --cnt[nowAt]; Pop(root[nowAt]); &#125; max = std::max(max, cnt[nowAt]*val[nowAt]);&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SCOI2010 序列操作]]></title>
    <url>%2F2019%2F07%2F05%2FSeqOpt%2F</url>
    <content type="text"><![CDATA[lxhgww最近收到了一个01序列，序列里面包含了 $n$ 个数，这些数要么是 $0$，要么是 $1$，现在对于这个序列有五种变换操作和询问操作： $0\ a\ b$ 把 $[a, b]$ 区间内的所有数全变成 $0$. $1\ a\ b$ 把 $[a, b]$ 区间内的所有数全变成 $1$. $2\ a\ b$ 把 $[a,b]$ 区间内的所有数全部取反，也就是说把所有的 $0$ 变成 $1$，把所有的 $1$ 变成 $0$. $3\ a\ b$ 询问 $[a, b]$ 区间内总共有多少个 $1$. $4\ a\ b$ 询问 $[a, b]$ 区间内最多有多少个连续的 $1$. 对于每一种询问操作，lxhgww都需要给出回答，聪明的程序员们，你们能帮助他吗？ 这道题目可以用珂朵莉树水过去。操作 $0,1$ 是常规操作，其余的可以通过调用 Split 函数，得到符合条件的区间的区间 $[\mathrm{Split}(a),\,\mathrm{Split}(b+1))$. 然后直接遍历这个区间内的所有区间，统计答案或者修改信息即可，操作 $4$ 需要特别判断一下两个连续区间值相同的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;bool ReadBool(void)&#123; char in; do in = getchar(); while(in!='0' &amp;&amp; in!='1'); return in=='1';&#125;int totNums;struct Node&#123; int l,r; mutable bool val; Node()&#123;&#125; Node(const int&amp; il,const int&amp; ir = 0,const bool&amp; ival = false) : l(il),r(ir),val(ival) &#123;&#125; inline bool operator &lt; (const Node&amp; comp) const &#123; return l &lt; comp.l; &#125;&#125;;std::set&lt;Node&gt; Odt;//l&lt;=pos&lt;=r//[l,x) [x,r]std::set&lt;Node&gt;::iterator Split(int pos)&#123; if(pos &gt;= totNums) return Odt.end(); std::set&lt;Node&gt;::iterator it = --Odt.upper_bound(Node(pos)); if(it-&gt;l == pos) return it; int l = it-&gt;l,r = it-&gt;r, val = it-&gt;val; Odt.erase(it); Odt.insert(Node(l,pos-1,val)); return Odt.insert(Node(pos,r,val)).first;&#125;void Assign(int fr,int to, bool val)&#123; std::set&lt;Node&gt;::iterator l = Split(fr),r = Split(to+1); Odt.erase(l,r); Odt.insert(Node(fr,to,val));&#125;signed main(void)&#123; int totOptn; bool in,last; int lastPos; scanf("%d%d", &amp;totNums,&amp;totOptn); last = ReadBool(); lastPos = 0; for(int i=1;i&lt;totNums;i++) if((in = ReadBool()) != last)&#123; Odt.insert(Node(lastPos,i-1,last)); last = in; lastPos = i; &#125; Odt.insert(Node(lastPos,totNums-1,in)); int opt,a,b,cnt,max; std::set&lt;Node&gt;::iterator l,r; while(totOptn--)&#123; scanf("%d%d%d", &amp;opt,&amp;a,&amp;b); switch(opt)&#123; case 0: Assign(a,b,0); break; case 1: Assign(a,b,1); break; case 2: l = Split(a),r = Split(b+1); for(std::set&lt;Node&gt;::iterator it=l;it!=r;++it) it-&gt;val ^= 1; break; case 3: cnt = 0; l = Split(a),r = Split(b+1); for(std::set&lt;Node&gt;::iterator it=l;it!=r;++it) if(it-&gt;val) cnt += it-&gt;r-it-&gt;l+1; printf("%d\n",cnt); break; case 4: cnt = max = 0; l = Split(a),r = Split(b+1); for(std::set&lt;Node&gt;::iterator it=l;it!=r;++it) if(it-&gt;val) cnt += it-&gt;r-it-&gt;l+1; else &#123; max = std::max(max,cnt); cnt = 0; &#125; printf("%d\n", std::max(max,cnt)); break; default: assert(false); break; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】十二省联考2019 春节十二响]]></title>
    <url>%2F2019%2F07%2F02%2FSpring%2F</url>
    <content type="text"><![CDATA[先考虑一条链，根不是端点的情况。这时可以将两边排序，然后每次取最大加入到答案，最终答案就是之前累加的和加上根节点的权值。类似地可以推广到多个儿子的情况。另一种可行的做法是，对于每一个结点处理出来一个堆，在合并多个堆时不断执行合并操作，即将所有堆顶元素取出，取最大加入到一个新堆中。不断合并直到所有原先的堆全部清空，然后将根加入到这个新堆中，这个堆就是根代表的堆。这样我们可以递归地处理，最终得到整棵树根代表的堆，这个堆中所有的元素之和就是最终的答案。 在一开始可以将每一个点看做一个独立的元素，而每一轮合并至少消除了一个元素。总时间复杂度为 $O(N\log N)$. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)2e5+500;long long memo[MAXN];std::vector&lt;int&gt; G[MAXN];struct Mempl&#123; std::priority_queue&lt; int, std::vector&lt;int&gt;, std::less&lt;int&gt; &gt; prque; long long sum; Mempl *nxt; Mempl(void)&#123; nxt = nullptr; &#125;&#125;*t0 = nullptr;std::vector&lt;int&gt; que;Mempl* Solve(const int&amp; nowNode = 0)&#123; Mempl *ret=nullptr,*nowAt = ret; long long ssum; int max, elem; if(G[nowNode].empty())&#123; ret = new Mempl(); ret-&gt;prque.push(memo[nowNode]); ret-&gt;sum = memo[nowNode]; &#125; else &#123; for(const auto &amp;it : G[nowNode])&#123; if(ret == nullptr)&#123; ret = Solve(it); nowAt = ret; &#125; else &#123; nowAt-&gt;nxt = Solve(it); nowAt = nowAt-&gt;nxt; &#125; &#125; &#123; std::vector&lt;int&gt; T; std::swap(que,T); &#125; ssum = 0; while(ret != nullptr &amp;&amp; ret-&gt;nxt != nullptr)&#123; max = INT_MIN; nowAt = ret; for(Mempl* pre = nullptr; nowAt != nullptr;)&#123; elem = nowAt-&gt;prque.top(); nowAt-&gt;prque.pop(); nowAt-&gt;sum -= elem; max = std::max(max,elem); if(nowAt-&gt;prque.empty())&#123; if(pre == nullptr)&#123; assert(nowAt == ret); ret = ret-&gt;nxt; pre = nowAt; nowAt = nowAt-&gt;nxt; delete pre; pre = nullptr; &#125; else &#123; pre-&gt;nxt = nowAt-&gt;nxt; delete nowAt; nowAt = pre-&gt;nxt; &#125; &#125; else &#123; pre = nowAt; nowAt = nowAt-&gt;nxt; &#125; &#125; ssum += max; que.push_back(max); &#125; if(ret == nullptr) ret = new Mempl(); ret-&gt;sum += ssum + memo[nowNode]; for(const auto &amp;it:que) ret-&gt;prque.push(it); ret-&gt;prque.push(memo[nowNode]); &#125; return ret;&#125;signed main(void)&#123; int totPg,up; scanf("%d", &amp;totPg); for(int i=0;i&lt;totPg;i++) scanf("%lld", memo+i); for(int i=1;i&lt;totPg;i++)&#123; scanf("%d", &amp;up); G[up-1].push_back(i); &#125; auto ret = Solve(); printf("%lld\n", ret-&gt;sum); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】十二省联考2019 异或粽子]]></title>
    <url>%2F2019%2F07%2F01%2FZXor%2F</url>
    <content type="text"><![CDATA[先处理一下前缀异或和，然后用一个 Trie 维护一下当前位置异或前缀和，这样就可以快速求出第 $k$ 小。将所有的位置和当前最小值放到一个优先队列中维护，循环模拟即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)5e5+500;constexpr auto MAXK = (int)2e5+500;//Triestruct Node&#123; size_t cnt; Node *ch[2]; Node(void)&#123; cnt = 0; ch[0] = ch[1] = nullptr; &#125;&#125;*t0 = new Node();void Insert(const unsigned int &amp;val)&#123; Node* nowAt = t0; for(int i=31;i&gt;=0;i--)&#123; if(nowAt-&gt;ch[(val&amp;(1LL&lt;&lt;i))&gt;&gt;i] == nullptr) nowAt-&gt;ch[(val&amp;(1LL&lt;&lt;i))&gt;&gt;i] = new Node(); nowAt = nowAt-&gt;ch[(val&amp;(1LL&lt;&lt;i))&gt;&gt;i]; nowAt-&gt;cnt++; &#125;&#125;long long Query(const unsigned int &amp;val, int kth)&#123; Node* nowAt = t0; long long ans = 0; short nxt; for(int i=31;i&gt;=0;i--)&#123; assert(nowAt-&gt;ch[0] || nowAt-&gt;ch[1]); ans &lt;&lt;= 1; nxt = (val&gt;&gt;i)&amp;1; if(nowAt-&gt;ch[0] &amp;&amp; nowAt-&gt;ch[1])&#123; if(nowAt-&gt;ch[nxt^1]-&gt;cnt &gt;= kth)&#123; nowAt = nowAt-&gt;ch[nxt^1]; ans|=1; &#125; else &#123; kth -= nowAt-&gt;ch[nxt^1]-&gt;cnt; nowAt = nowAt-&gt;ch[nxt]; &#125; &#125; else if(nowAt-&gt;ch[nxt]==nullptr) &#123; nowAt = nowAt-&gt;ch[nxt^1]; ans|=1; &#125; else nowAt = nowAt-&gt;ch[nxt]; &#125; assert(!(nowAt-&gt;ch[0] || nowAt-&gt;ch[1])); return ans;&#125;int totNums;unsigned int num[MAXN];struct Inf&#123; long long val; int pos,kth; Inf(void)&#123;&#125; Inf(const long long&amp; ival, const int &amp;ipos, const int &amp;ikth) : val(ival), pos(ipos), kth(ikth) &#123;&#125; bool operator &lt; (const Inf&amp; comp) const &#123; return val &lt; comp.val; &#125;&#125;;std::priority_queue&lt;Inf&gt; que;signed main(void)&#123; int totReq; std::cin&gt;&gt;totNums&gt;&gt;totReq; totReq&lt;&lt;=1; for(int i=1;i&lt;=totNums;i++)&#123; std::cin&gt;&gt;num[i]; Insert(num[i]^=num[i-1]); &#125; Insert(0); for(int i=0;i&lt;=totNums;i++) que.push(Inf(Query(num[i],1),i,1)); long long ans = 0; while(totReq--)&#123; auto it = que.top(); que.pop(); //std::cout&lt;&lt;it.val&lt;&lt;" "&lt;&lt;it.pos&lt;&lt;" "&lt;&lt;it.kth&lt;&lt;std::endl; ans += it.val; que.push(Inf(Query(num[it.pos], it.kth+1), it.pos, it.kth+1)); &#125; std::cout&lt;&lt;(ans&gt;&gt;1)&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】谈笑风生]]></title>
    <url>%2F2019%2F06%2F08%2FJiang_Zemin_with_Wallace%2F</url>
    <content type="text"><![CDATA[设 $T$ 为一棵有根树，我们做如下的定义： 设 $a$ 和 $b$ 为 $T$ 中的两个不同节点。如果 $a$ 是 $b$ 的祖先，那么称“$a$ 比 $b$ 不知道高明到哪里去了”。 设 $a$ 和 $b$ 为 $T$ 中的两个不同节点。如果 $a$ 与 $b$ 在树上的距离不超过某个给定常数 $x$，那么称“$a$ 与 $b$ 谈笑风生”。 给定一棵 $n$ 个节点的有根树 $T$，节点的编号为 $1 ∼ n$，根节点为 1 号节点。你需要回答 $q$ 个询问，询问给定两个整数 $p$ 和 $k$，问有多少个有序三元组 $(a,\ b,\ c)$ 满足： $a$、 $b$ 和 $c$ 为 $T$ 中三个不同的点，且 $a$ 为 $p$ 号节点； $a$ 和 $b$ 都比 $c$ 不知道高明到哪里去了； $a$ 和 $b$ 谈笑风生。这里谈笑风生中的常数为给定的 $k$. 比较容易想到的做法是对于树上每一个点 $u$ 建立权值线段树，结点代表深度，数值等于深度比 $u$ 大一定值的所有点子树大小总和。对于每一个询问，不难发现最终满足条件的 $a$, $b$ 和 $c$ 都一定在从根出发的一条简单路径上。如果 $b$ 是 $a$ 的祖先，那么满足条件的 $c$ 就是以 $a$ 为根子树中的任何一个结点，利用乘法原理可以求出三元组的数量。如果 $a$ 是 $b$ 的祖先，那么满足条件的三元组数量等于 $a$ 上线段树区间 $(0,k]$ 的数值之和。这样做明显是对的。 你们 OIer 千万要注意啊，不要“见得风，是得雨”。看到这种题目你们 OIer 本身也要判断。明白这意思吧？假使这种完全超时超空间的做法你再帮他写一遍你等于 $\cdots$ 这个东西 $\cdots$ 你 $\cdots$ 你也有责任的。刚才你问我怎么优化，我可以回答你我无可奉告，但你们又不高兴，那怎么办？我讲的意思，不是我这么写就可以过，你问我原理是不是这样，我说是的，我就明确地告诉你。你们啊，我感觉你们 OI 界还要学习一个，你们非常熟悉可持久化线段树这一套 Value，你们毕竟 Too young. 明白我的意思吗？我告诉你我是身经百战了，见得多了。主流的哪一种线段树我没写过？数据结构他们 $\cdots$ 你们要知道，动态开点的可持久化线段树，比你们权值线段树不知道高到哪里去了，我跟它谈笑风生。其实 OIer 呀它需要提高自己的知识水平。識得唔識得啊？唉，我也给你们着急啊，真的。你们今天 $\cdots\cdots$ 我以为 $\cdots\cdots$ 遍地 $\cdots\cdots$ 你们有一个好，全 OJ 写什么题目，你们比其他的 OIer 啊，写得还快。但是呢，写来写去的问题啊，都 Too simple，啊，Sometimes naïve! 懂了没啊？我刚才呢 $\cdots\cdots$ 我刚才我很想啊，就是我每一次碰到你们我就讲，中国有一句话叫”闷声大发财”。我就什么话也不用说。这是最好的！但是我想我见到你们这样热情啊，一句话不说也不好。所以你刚才你一定要——在优化上将来如果你们实现上有偏差你们要负责的。我没有说要写权值线段树，没任何这个意思。但是你问 $\cdots\cdots$ 你一定要不得要问我 $\cdots$ 对对对 $\cdots$ 对线段树支持不支持。我们不支持他？他现在是正解，我们怎么能不支持正解？你们啊，不要想 $\cdots\cdots$ 喜欢 $\cdots\cdots$ 这 $\cdots$ 欸弄个大新闻，说现在已经超时了，再把我的算法批判一番。你们啊，Naïve! 修改后的代码可以通过本题。至于原因，无可奉告。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 300000+500;constexpr auto MAXQ = 300000+500;int range; //depth \in [0,range)struct Node&#123; long long val; int version; Node *lft,*rgt; Node()&#123; lft=rgt=nullptr; &#125; Node(const long long &amp;ival,const int &amp;iver) : val(ival),version(iver) &#123; lft=rgt=nullptr; &#125; Node(const Node* iNode, const int&amp; iver) : val(iNode-&gt;val),version(iver),lft(iNode-&gt;lft),rgt(iNode-&gt;rgt) &#123;&#125; Node&amp; Update(void)&#123; if(lft!=nullptr || rgt!=nullptr) val = 0; if(lft!=nullptr) val += lft-&gt;val; if(rgt!=nullptr) val += rgt-&gt;val; return *this; &#125;&#125;*root[MAXN];void Merge(Node*&amp; nowAt,Node* targ, const int&amp; nowVer)&#123; if(targ == nullptr) return; if(nowAt == nullptr) nowAt = new Node(0LL, nowVer); else if(nowAt-&gt;version != nowVer) nowAt = new Node(nowAt,nowVer); nowAt-&gt;val += targ-&gt;val; Merge(nowAt-&gt;lft, targ-&gt;lft, nowVer); Merge(nowAt-&gt;rgt, targ-&gt;rgt, nowVer);&#125;void Add(const int&amp; targ, const long long&amp; val,Node*&amp; nowAt, const int&amp; nowVer, const int&amp; fr = 0, const int&amp; to = range-1)&#123; if(targ&lt;fr || to&lt;targ) return; if(nowAt == nullptr) nowAt = new Node(0LL, nowVer); else if(nowAt-&gt;version != nowVer) nowAt = new Node(nowAt,nowVer); nowAt-&gt;val += val; if(fr&lt;to)&#123; Add(targ,val,nowAt-&gt;lft,nowVer,fr,fr+to&gt;&gt;1); Add(targ,val,nowAt-&gt;rgt,nowVer,1+(fr+to&gt;&gt;1),to); &#125;&#125;long long Query(const int&amp; qfr, const int&amp; qto, Node* nowAt, const int&amp; fr = 0, const int&amp; to = range-1)&#123; if(qto&lt;fr || to&lt;qfr || nowAt==nullptr) return 0; if(qfr&lt;=fr &amp;&amp; to&lt;=qto) return nowAt-&gt;val; else return Query(qfr,qto,nowAt-&gt;lft,fr,fr+to&gt;&gt;1) + Query(qfr,qto,nowAt-&gt;rgt,1+(fr+to&gt;&gt;1),to);&#125;std::vector&lt;int&gt; G[MAXN];int depth[MAXN],Index[MAXN],dfn,hvy[MAXN]; long long siz[MAXN];bool vis[MAXN];void Dfs(const int&amp; nowAt = 1)&#123; siz[nowAt] = 1; vis[nowAt] = true; Index[nowAt] = dfn++; int maxCh = 0; for(const auto &amp;it : G[nowAt]) if(!vis[it])&#123; depth[it] = depth[nowAt]+1; Dfs(it); siz[nowAt] += siz[it]; if(siz[it]&gt;maxCh)&#123; maxCh = siz[it]; hvy[nowAt] = it; &#125; &#125;&#125;void Confession(const int&amp; nowAt = 1)&#123; vis[nowAt] = true; if(hvy[nowAt]&gt;0)&#123; Confession(hvy[nowAt]); root[nowAt] = root[hvy[nowAt]]; for(const auto &amp;it : G[nowAt]) if(!vis[it])&#123; Confession(it); Merge(root[nowAt], root[it], nowAt); &#125; &#125; Add(depth[nowAt],siz[nowAt]-1,root[nowAt],nowAt);&#125;signed main(void)&#123; memset(hvy,-1,sizeof(hvy)); int totNode,totQuery; int fr,to; scanf("%d%d", &amp;totNode,&amp;totQuery); range = totNode; for(int i=1;i&lt;totNode;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); G[fr].push_back(to); G[to].push_back(fr); &#125; memset(vis,false,sizeof(vis)); Dfs(); memset(vis,false,sizeof(vis)); Confession(); //Process int p,k; long long ans; while(totQuery--)&#123; scanf("%d%d", &amp;p,&amp;k); ans = (long long)std::min(depth[p],k) * (siz[p]-1); ans += Query(depth[p]+1,depth[p]+k,root[p]); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】NOIp2017 宝藏]]></title>
    <url>%2F2019%2F06%2F07%2FTreasure%2F</url>
    <content type="text"><![CDATA[大致题意是，有一张图，边有边权，求出在它所有的生成树中边权总和的最小值，生成树中的边权等于原图中的边权乘上到根的距离。 可以发现，要求的并不是最小生成树，如果直接使用 Prim 算法，那么结果很可能是错误的，因为有可能每次选边权小的，选着选着离树根越来越远，不如一次选择一个相对较大的，然后后面的边就可以乘一个不那么大的距离。 由于这题数据范围比较小，所以还是可以用 Prim, 类似模拟退火那样，贪心时有可能会随机选择当前状态下不那么优的决策，多运行几次即可。 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 20;constexpr auto MAXM = 2000;constexpr auto INF = 5000000;int depth[MAXN],len[MAXN][MAXN]; int totNode,totEdge;struct Edge&#123; int fr,to; Edge()&#123;&#125; Edge(const int &amp;ifr,const int &amp;ito) : fr(ifr),to(ito) &#123;&#125;&#125;;bool operator &lt; (const Edge&amp; a,const Edge&amp; Comp)&#123; return len[a.fr][a.to]*a.fr[depth] &gt; len[Comp.fr][Comp.to]*Comp.fr[depth];&#125;int Solve(const int&amp; source)&#123; int ans = 0; bool vis[MAXN]; memset(vis,false,sizeof(vis)); std::stack&lt;Edge&gt; Last; std::priority_queue&lt;Edge&gt; hep; vis[source] = true; depth[source] = 1; for(int i=1;i&lt;=totNode;i++) if(len[source][i] &lt; INF) hep.push(Edge(source,i)); Edge nowAt; for(int cls=1;cls&lt;totNode;cls++)&#123; nowAt = hep.top(); hep.pop(); while(!hep.empty() &amp;&amp; (vis[nowAt.to]||(rand()%totNode&lt;1)))&#123; if(!vis[nowAt.to]) Last.push(nowAt); nowAt = hep.top(); hep.pop(); &#125; vis[nowAt.to] = true; depth[nowAt.to] = depth[nowAt.fr]+1; while(!Last.empty())&#123; hep.push(Last.top()); Last.pop(); &#125; for(int i=1;i&lt;=totNode;i++) if(!vis[i] &amp;&amp; len[nowAt.to][i]&lt;INF) hep.push(Edge(nowAt.to,i)); ans += len[nowAt.fr][nowAt.to]*depth[nowAt.fr]; &#125; return ans;&#125;signed main(void)&#123; srand(19896430); for(int i=0;i&lt;MAXN;i++)for(int j=0;j&lt;MAXN;j++) len[i][j] = INF; int fr,to,len; scanf("%d%d", &amp;totNode,&amp;totEdge); for(int i=0;i&lt;totEdge;i++)&#123; scanf("%d%d%d", &amp;fr,&amp;to,&amp;len); ::len[fr][to] = ::len[to][fr] = std::min(::len[fr][to],len); &#125; int min = INT_MAX; for(int i=0;i&lt;1064;i++) for(int source=1;source&lt;=totNode;++source) min = std::min(min, Solve(source)); printf("%d\n", min); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自适应辛普森积分算法]]></title>
    <url>%2F2019%2F06%2F05%2FNSimpson%2F</url>
    <content type="text"><![CDATA[自适应辛普森法（英文：Adaptive Simpson’s Rule）可以用来求一个函数在区间上的定积分。如果这个函数是一个初等函数，那么它的定积分可以在求出函数的不定积分之后使用牛顿-布莱尼茨公式。如果不是，那么辛普森公式和自适应辛普森可以很好解决这个问题。 辛普森法的基本思想就是用一个看上去差不多的函数来拟合原函数，求得近似值。形如 f(x)=a_1x^2+a_2x+a_3的二次函数图像是一个曲线，于是我们就用这个东西去拟合原函数 $g(x)$. 假定我们现在要求函数在区间 $[l,r]$ 上的定积分，那么假定这个函数就是一个二次函数，记 $y_i=g(i)$, $m=\frac{l+r}2$. 那么取三个点：$(l,y_l)$, $(m,y_m)$, $(r,y_r)$. 根据这三个点确定二次函数，然后求定积分。可以发现结果是 \frac{l+r}6\left(y_l+4y_m+y_r\right)因为 \begin{align} \frac{l+r}6\left(y_l+4y_m+y_r\right)&=\frac{r-l}6\left(a_1l^2+a_2l+a_3+4a_1m^2+4a_2m^2+4a_3+a_1r^2+a_2r+a_3\right)\\ &=\frac{r-l}6\left(a_1\left(l^2+r^2+4m^2\right)+a_2(l+4m+r)+6a_3\right)\\ &=\frac{a_1}3\left(r^3-l^3\right)+\frac{a^2}2\left(r^2-l^2\right)+a_3(r-l) \end{align}而 \begin{align}\int_l^rf(x)\mathrm{d}x&=\frac{a_1}3r^3+\frac{a_2}2r^2+a_3r-\frac{a_1}3l^3-\frac{a_2}2l^2+a_3a\\ &=\frac{a_1}3\left(r^3-l^3\right)+\frac{a^2}2\left(r^2-l^2\right)+a_3(r-l) \end{align}可见这样计算是正确的。 如果将整个函数看成一个二次函数，那么结果很有可能不准确，这个时候就要将原函数在区间 $[l,r]$ 上分成等长 $n$ 段，记 $\Delta x=\frac{r-l}{n-1}$. 那么根据辛普森公式 \int_a^bf(x)dx \approx{\Delta x\over3}(y_0+4y_1+y_2)+{\Delta x\over3}(y_2+4y_3+y_4)+...+{\Delta x\over3}(y_{n-2}+4y_{n-1}+y_n)这样如果取一个很大的 $n$, 那么结果会很准确，但是同时也要消耗大量的计算能力。改进的方法是，定义一个精度 $eps$. 对于某一段 $[l_0,r_0]$, 如果令 $n=3$ 和令 $n=5$ 时计算差别在精度允许范围内，那么直接返回，否则两边递归继续运算。这样的好处就是程序会自适应地在原函数长得像二次函数的地方少取几个点，而在不像的地方多取。 计算 \int_L^R\frac{cx+d}{ax+b}\mathrm{d}x 的代码如下： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;constexpr auto EPS = 1e-6;double a,b,c,d;double F(const double&amp; x)&#123; return (c*x+d)/(a*x+b);&#125;double Simpson(const double&amp; fr,const double&amp; to)&#123; const double mid = (fr+to)/2; return (to-fr)/6*(F(fr)+4*F(mid)+F(to));&#125;double Asr(const double&amp; fr,const double&amp; to, double A)&#123; double mid = (fr+to)/2; double L = Simpson(fr,mid), R = Simpson(mid,to); if(fabs(L+R-A) &lt;= 15*EPS) return L+R+(L+R-A)/15; else return Asr(fr,mid,L) + Asr(mid,to,R);&#125;double Asr(const double&amp; fr,const double&amp; to) &#123; return Asr(fr,to,Simpson(fr,to)); &#125;signed main(void)&#123; double fr,to; scanf("%lf%lf%lf%lf%lf%lf", &amp;a,&amp;b,&amp;c,&amp;d,&amp;fr,&amp;to); printf("%.6lf\n", Asr(fr,to)); return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】Dynamic Rankings]]></title>
    <url>%2F2019%2F05%2F29%2FDynamic-Rankings%2F</url>
    <content type="text"><![CDATA[题目链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;char ReadChar(void)&#123; char in; do in = getchar(); while(in!='Q' &amp;&amp; in!='C'); return in;&#125;constexpr auto MAXN = 100000+500;constexpr auto MAXM = MAXN+(100000+500&lt;&lt;1);//BITint bit_array[MAXN];#define lowbit(x) ((x)&amp;(-(x)))void Add(int pos, const int&amp; delta)&#123; for(;pos&lt;MAXN;pos+=lowbit(pos)) bit_array[pos] += delta;&#125;int Sum(int pos)&#123; int ans = 0; for(;pos&gt;0;pos-=lowbit(pos)) ans += bit_array[pos]; return ans;&#125;int Sum(const int&amp; beg, const int &amp;end)&#123; return Sum(end)-Sum(beg-1);&#125;struct Opt&#123; //type = 1 : beg,end,kth,ans_ID //type = 2 : pos,delta,num int type,i,j,k,ID; Opt()&#123;&#125; Opt(const int &amp;itype, const int &amp;ii,const int &amp;ij,const int &amp;ik,const int &amp;iID = -1) : type(itype),i(ii),j(ij),k(ik),ID(iID) &#123;&#125;&#125;opt[MAXM],q1[MAXM],q2[MAXM]; int totOptn;int ans[MAXM],totAns;void Solve(const int &amp;ans_fr, const int &amp;ans_to, const int &amp;opt_fr, const int &amp;opt_to)&#123; if(opt_fr &gt; opt_to || ans_fr &gt; ans_to) return; if(ans_fr == ans_to)&#123; for(int i=opt_fr;i&lt;=opt_to;i++) if(opt[i].ID != -1) ans[opt[i].ID] = ans_fr; return; &#125; int ans_mid = (ans_fr+ans_to)&gt;&gt;1,res; auto *s1=q1,*s2=q2; bool lft = false, rgt = false; for(int nowOpt = opt_fr; nowOpt &lt;= opt_to; ++nowOpt)&#123; auto&amp; nowAt = opt[nowOpt]; switch(nowAt.type)&#123; case 1: res = Sum(nowAt.i,nowAt.j); if(res &gt;= nowAt.k)&#123; lft = true; *s1++ = nowAt; &#125; else &#123; rgt = true; nowAt.k -= res; *s2++ = nowAt; &#125; break; case 2: if(nowAt.k &lt;= ans_mid)&#123; Add(nowAt.i, nowAt.j); *s1++ = nowAt; &#125; else *s2++ = nowAt; break; default: puts("UTY"); assert(false); break; &#125; &#125; //Empty for(int i=opt_fr;i&lt;=opt_to;i++) if(opt[i].type==2 &amp;&amp; opt[i].k&lt;=ans_mid) Add(opt[i].i, -opt[i].j); //Copy for(auto *i=q1;i&lt;s1;i++) opt[opt_fr+i-q1] = *i; for(auto *i=q2;i&lt;s2;i++) opt[opt_fr+s1-q1+i-q2] = *i; if(lft) Solve(ans_fr,ans_mid,opt_fr,opt_fr+s1-q1-1); if(rgt) Solve(ans_mid+1,ans_to,opt_fr+s1-q1,opt_to);&#125;int num[MAXN];signed main(void)&#123; int totNums,totOrd; int i,j,k,min=INT_MAX,max=INT_MIN; scanf("%d%d", &amp;totNums,&amp;totOrd); for(int ii=0;ii&lt;totNums;ii++)&#123; scanf("%d", &amp;k); num[ii+1] = k; opt[totOptn++] = Opt(2,ii+1,1,k); min = std::min(min,k); max = std::max(max,k); &#125; for(int ii=0;ii&lt;totOrd;ii++) switch(ReadChar())&#123; case 'Q': scanf("%d%d%d", &amp;i,&amp;j,&amp;k); opt[totOptn++] = Opt(1,i,j,k,totAns++); break; case 'C': scanf("%d%d", &amp;i,&amp;k); opt[totOptn++] = Opt(2,i,-1,num[i]); opt[totOptn++] = Opt(2,i,1,num[i]=k); min = std::min(min,k); max = std::max(max,k); break; default: puts("UOPT"); assert(false); break; &#125; Solve(min,max,0,totOptn-1); for(int ii=0;ii&lt;totAns;ii++) printf("%d\n", ans[ii]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】AHOI2016-找相同字符]]></title>
    <url>%2F2019%2F05%2F28%2FHAOI2016-Search%2F</url>
    <content type="text"><![CDATA[题目链接 给定两个字符串 $s_1$ 和 $s_2$, 长度分别为 $n_1$, $n_2$. 求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。 先确定大致的思路，我们像做字符串匹配那样在 $s_1$ 中寻找 $s_2$. 现在假定 $s_2$ 的一个子串 $s_2[l,r]$ 是 $s_1$ 的一个子串，记答案为 $ans$, 并保证在任意时刻，$s_2$ 以 $1\leq l_0\leq l$ 开头，$l_0\leq r_0\leq r$ 结尾的子串的贡献都被计算到了答案中。接下来将 $r$ 扩展一位变成 $r_1=r+1$，如果这个时候发现 $s_2[l,r_1]$ 不再是 $s_1$ 的一个子串，那么我们要将 $l$ 收缩一位变成 $l_1=l+1$, 同时更新一下 $s_2$ 以 $l_1$ 开头，$l_1\leq r$ 结尾的子串对答案的贡献。不断这样调整，直到调整到第一个合适的 $l_3$ 使得 $s_2[l_3,r_1]$ 是 $s_1$ 的一个子串。一次扩展完成。 按照上述过程一次次扩展，最终到达一个子串类似 $s_2[l_4,n_2]$ 这样的状态，全部收缩，同时不要忘记计算。由于每一次扩展都更新了以当前子串开头字母开始的所有子串的贡献，而每一次收缩都计算了以新的开头字母开始的所有子串的贡献，因此这样算出来的答案是正确的。 要想实现这样的计算过程，需要对 $s_1$ 建立后缀树，然后对于后缀树上的每一个结点 $v$，预处理一下从初始状态 $t_0$ 到 $v$ 的路径长度 $v_{totLen}$, 以 $v$ 为根的子树的叶节点个数 $v_{appear}$ 以及一个比较重要的 $v_D$, 记 $v$ 的父亲为 $u$, $v$ 中压缩的结点个数为 $v_{len}$. 那么 v_D=u_D+v_{len}\times v_{appear}这个 $v_D$ 主要是在收缩时使用，要想实现一次收缩，其本质上就是跳到了去掉当前后缀第一个字母的后缀，在后缀树上相当于沿着后缀链接走一次。跳到相应结点后，还需要一次性更新 $l_1$ 开头的所有字符串对答案的贡献，也就是当前结点 $v$ 的 $v_D$. 需要注意的是，如果当前没有正好结束在一个结点上，那就还需要再额外算一下多出来的一小部分。 s --- 实践过程中需要注意的细节非常多。 最终时间复杂度 $O(N_1+N_2)$, 空间复杂度 $O(N)$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 200000+50;constexpr auto MAXK = 29;constexpr auto $ = MAXK-2;int totLen,s[MAXN],remain;struct Node&#123; int len,start; long long appear,totLen,Dsum; Node *ch[MAXK], *link; Node() &#123;&#125; Node(const int &amp;istart, const long long &amp;ilen) : totLen(0),appear(0),Dsum(0),start(istart),len(ilen) &#123;&#125;&#125;*t0,*nowAt,*virt;void Build(void)&#123; remain = totLen = 0; t0 = new Node(0,0); nowAt = t0; virt = new Node();&#125;void Attend(const int&amp; add)&#123; s[totLen++] = add; ++remain; for(Node *last = virt,*t; remain;)&#123; while(nowAt-&gt;ch[s[totLen-remain]]!=nullptr &amp;&amp; remain&gt;nowAt-&gt;ch[s[totLen-remain]]-&gt;len)&#123; t = nowAt-&gt;ch[s[totLen-remain]]; remain -= t-&gt;len; nowAt = t; &#125; Node*&amp; v = nowAt-&gt;ch[s[totLen-remain]]; int endChar = v==nullptr ? -1 : s[v-&gt;start+remain-1]; if(v==nullptr || endChar==add)&#123; last-&gt;link = nowAt; last = nowAt; if(v == nullptr) v = new Node(totLen-remain,INT_MAX); else break; &#125; else &#123; Node* split = new Node(v-&gt;start, remain-1); split-&gt;ch[endChar] = v; split-&gt;ch[add] = new Node(totLen-1,INT_MAX); v-&gt;len -= remain-1; v-&gt;start += remain-1; last-&gt;link = v = split; last = split; &#125; if(nowAt == t0) --remain; else nowAt = nowAt-&gt;link; &#125;&#125;void Dfs(Node* nowAt = t0)&#123; if(nowAt == nullptr) return; int ch = 0; for(int i=0;i&lt;MAXK;++i) if(nowAt-&gt;ch[i] != nullptr)&#123; Dfs(nowAt-&gt;ch[i]); ++ch; nowAt-&gt;appear += nowAt-&gt;ch[i]-&gt;appear; &#125; if(ch == 0)&#123; nowAt-&gt;appear = 1; nowAt-&gt;len = totLen-nowAt-&gt;start; &#125;&#125;void Dfs2(Node* nowAt = t0)&#123; if(nowAt == nullptr) return; for(int i=0;i&lt;MAXK;++i) if(nowAt-&gt;ch[i] != nullptr)&#123; nowAt-&gt;ch[i]-&gt;totLen = nowAt-&gt;totLen+nowAt-&gt;ch[i]-&gt;len; nowAt-&gt;ch[i]-&gt;Dsum = nowAt-&gt;Dsum+nowAt-&gt;ch[i]-&gt;len*nowAt-&gt;ch[i]-&gt;appear; Dfs2(nowAt-&gt;ch[i]); &#125;&#125;int ss[MAXN], nowPos; Node* targ = nullptr;long long ans = 0;void Solve(const int&amp; add)&#123; ss[totLen++] = add; while(nowPos+1&lt;totLen &amp;&amp; ((totLen-nowPos-1==nowAt-&gt;totLen&amp;&amp;nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]==nullptr) || (totLen-nowPos-1!=nowAt-&gt;totLen&amp;&amp;s[nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]-&gt;start+totLen-nowPos-nowAt-&gt;totLen-1]!=ss[totLen-1])))&#123; ++nowPos; nowAt = nowAt-&gt;link; //nowAt = nowAt-&gt;link; while(nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]!=nullptr &amp;&amp; totLen-1-nowPos-nowAt-&gt;totLen&gt;=nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]-&gt;len) nowAt = nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]; ans += nowAt-&gt;Dsum; if(totLen-nowPos-1 != nowAt-&gt;totLen) ans += (totLen-nowPos-1-nowAt-&gt;totLen) * nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]-&gt;appear; &#125; if(nowPos+1==totLen &amp;&amp; nowAt-&gt;ch[ss[nowPos]]==nullptr)&#123; assert(nowAt==t0); ++nowPos; return; &#125; if(totLen-nowPos == nowAt-&gt;totLen) ans += nowAt-&gt;appear; else ans += nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]-&gt;appear; if(totLen-nowPos!=nowAt-&gt;totLen &amp;&amp; totLen-nowPos &gt;= nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]-&gt;totLen) nowAt = nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]];&#125;void Callout()&#123; while(nowPos&lt;totLen)&#123; ++nowPos; nowAt = nowAt-&gt;link; while(nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]!=nullptr &amp;&amp; totLen-nowPos-nowAt-&gt;totLen&gt;=nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]-&gt;len) nowAt = nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]; ans += nowAt-&gt;Dsum; if(totLen-nowPos != nowAt-&gt;totLen) ans += (totLen-nowPos-nowAt-&gt;totLen) * nowAt-&gt;ch[ss[nowPos+nowAt-&gt;totLen]]-&gt;appear; &#125;&#125;char s1[MAXN],s2[MAXN]; int lenA,lenB;signed main(void)&#123; scanf("%s%s", s1,s2); lenA = strlen(s1); lenB = strlen(s2); if(lenA &lt; lenB) std::swap(s1,s2); Build(); for(int i=0;s1[i]!='\0';++i) Attend(s1[i]-'a'); Attend($); Dfs(); Dfs2(); nowAt = t0; nowPos = 0; totLen = 0; t0-&gt;link = t0; for(int i=0;s2[i]!='\0';++i) Solve(s2[i]-'a'); Callout(); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1166D Cute Sequences]]></title>
    <url>%2F2019%2F05%2F26%2FCF1166D-Cute-Sequences%2F</url>
    <content type="text"><![CDATA[题目链接 有一个长度为 $n\;(n\leq50)$ 的序列 $x_1,x_2,\cdots,x_n$. $\forall 2\leq i\leq n$, $x_i=r_i\sum_{j=1}^{i-1}x_i$, 且 $1\leq r_i\leq m$. 给定 $x_1,x_n,m$, 还原这个序列或者输出 -1 代表无解. 可以发现，这个序列第二项开始，每一项的值所在的区间都是固定了的，设 $x_i\in[l_i,r_i]$, 那么 l_i=2^{i-2}x_1+2^{i-2}\\ r_i=2^{i-2}x_1+2^{i-2}m枚举一下序列的长度 $n$, 即可判定是否有解，同时确定序列长度。 然后贪心一下，补齐剩下的 $x_n-l_n$, 如果当前位置为 $i$, 那么在这个位置上额外加一最终对答案的贡献就是 $2^{n-i-1}$. 一开始贪心，尽可能早地将这些位置加上，顺带模拟即可。 最终时间复杂度为 $O(TK+TN)$, 代码如下： 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;signed main(void)&#123; int totCases; long long beg,end,k,m,fr,to,delta,now,totNums,sum,sumDelta; std::cin&gt;&gt;totCases; while(totCases--)&#123; std::cin&gt;&gt;beg&gt;&gt;end&gt;&gt;m; if(beg == end)&#123; std::cout&lt;&lt;"1 "&lt;&lt;beg&lt;&lt;std::endl; continue; &#125; fr = to = beg; k = 1; totNums = 0; while(to &lt; end)&#123; fr = beg*k + k; to = beg*k + k*m; k &lt;&lt;= 1; ++totNums; &#125;k &gt;&gt;= 2; if(fr&lt;=end &amp;&amp; end&lt;=to)&#123; std::cout&lt;&lt;totNums+1&lt;&lt;" "&lt;&lt;beg&lt;&lt;" "; sum = now = beg; sumDelta = end - fr; for(int i=1;i&lt;totNums;i++)&#123; delta = std::min(m-1, sumDelta/k); std::cout&lt;&lt;(now = sum + delta + 1)&lt;&lt;" "; sum += now; sumDelta -= delta*k; if(k &gt; 1) k&gt;&gt;=1; &#125; std::cout&lt;&lt;end&lt;&lt;std::endl; &#125; else puts("-1"); &#125; EXIT_PROGRAM: return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>暴力/枚举</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1166E The LCMs Must be Large]]></title>
    <url>%2F2019%2F05%2F26%2FCF1166E-The-LCMs-Must-be-Large%2F</url>
    <content type="text"><![CDATA[题目链接 有一个长度为 $n$, 内容未知的数列。给定 $m$ 个位置集合，第 $i$ 个为 $S_i$，对于每一个集合，集合中所有位置上的数的 $lcm$ 都严格大于它补集的 $lcm$. 判断满足条件的数列是否存在。 如果每两个 $S$ 交集都不为空集，那么满足条件的数列一定存在。 如果不是这样，很明显存在矛盾。 否则，令所有位置上的数都是 $1$. 然后将第 $i$ 个集合 $S_i$ 中所有位置上的数都乘上一个素数 $p_i$. 确保所有的 $p$ 互不相等。这样没一个集合中所有位置上的数的 $lcm$ 就是 $\prod p$, 而集合以外的位置不可能含有乘在这个集合上的素数。 这样，开一堆 bitset 代表每一个集合，暴力判断一下即可。 时间复杂度为 $O(M^2N)$. 代码如下： 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;constexpr auto MAXM = 50+5;constexpr auto MAXN = (int)1e4+50;std::bitset&lt;MAXN&gt; lp[MAXM];signed main(void)&#123; int totSet,totNums,siz,num; std::cin&gt;&gt;totSet&gt;&gt;totNums; for(int i=0;i&lt;totSet;i++)&#123; std::cin&gt;&gt;siz; for(int j=0;j&lt;siz;j++)&#123; std::cin&gt;&gt;num; lp[i][num] = 1; &#125; &#125; for(int i=0;i&lt;totSet;i++) for(int j=0;j&lt;totSet;j++) if((lp[i]&amp;lp[j]).count() == 0)&#123; std::cout&lt;&lt;"impossible"&lt;&lt;std::endl; goto END; &#125; std::cout&lt;&lt;"possible"&lt;&lt;std::endl; END: return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】TJOI2017-城市]]></title>
    <url>%2F2019%2F05%2F26%2FTJOI2017-City%2F</url>
    <content type="text"><![CDATA[题目链接 枚举一下需要删除的边，假定这条边是 $r=(u,v,d)$. 然后得到两颗树。 考虑改造之后，最长的路有可能产生于得到的这两颗树内部，也有可能从其中一棵树出发，经由添加的一条长度为 $d$ 的边，到达另一颗树。对于树内部的情况，一定是树的直径。否则，假定我们新建一条边 $b=(f,t,d)$, 那么最长的路径长度上等于从 $f$ 出发的最长路和从 $t$ 出发的最长路长度和加上 $d$. 对于一个点 $u$ 假定它的父亲是 $v$. 此时我们已经计算了 $u$ 子树中的最长路径 $D_{1,u}$ 和次长路 $D_{2,u}$, 那么从 $u$ 出发的最长路 $D_{3,u}$ 有可能是 $D_{1,u}$, 也可能是往上走经过父亲 $v$ 到达父亲的父亲或者经由父亲到达一个兄弟。对于后一种情况，需要判断一下这个兄弟不是自己。将 $D_{3,v}$ 与 $D_{1,v}$ 或者 $D_{2,v}$ 取最大加上 $|v\to u|$，然后再与 $D_{1,u}$ 比较即可。 总时间复杂度为 $O(N^2)$, 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 5000+50;struct LINE&#123; int to,dis; LINE()&#123;&#125; LINE(const int &amp;ito, const int &amp;idis) : to(ito),dis(idis) &#123;&#125;&#125;line[MAXN&lt;&lt;1];std::vector&lt;LINE*&gt; G[MAXN];bool exist[MAXN&lt;&lt;1];struct DfsData&#123; int pos,distot; &#125;;bool vis[MAXN];int d1,d2,r1,r2,con;int D1[MAXN],D2[MAXN],fr[MAXN],up[MAXN],maxDist;void Dp1(const int &amp;nowAt)&#123; vis[nowAt] = true; D1[nowAt] = D2[nowAt] = up[nowAt] = 0; fr[nowAt] = -1; for(const auto&amp; it : G[nowAt]) if(exist[it-line] &amp;&amp; !vis[it-&gt;to])&#123; Dp1(it-&gt;to); if(D1[it-&gt;to] + it-&gt;dis &gt; D1[nowAt])&#123; D2[nowAt] = D1[nowAt]; D1[nowAt] = D1[it-&gt;to] + it-&gt;dis; fr[nowAt] = it-&gt;to; &#125; else D2[nowAt] = std::max(D2[nowAt], D1[it-&gt;to] + it-&gt;dis); &#125; maxDist = std::max(maxDist, D1[nowAt]+D2[nowAt]);&#125;void Dp2(const int &amp;nowAt, const int &amp;fa = -1, const int &amp;dis = 0)&#123; vis[nowAt] = true; if(fa != -1)&#123; up[nowAt] = dis; if(fr[fa] != nowAt) up[nowAt] += std::max(up[fa], D1[fa]); else up[nowAt] += std::max(up[fa], D2[fa]); maxDist = std::min(maxDist, std::max(up[nowAt],D1[nowAt])); &#125; else maxDist = std::min(maxDist, D1[nowAt]); for(const auto&amp; it : G[nowAt]) if(exist[it-line] &amp;&amp; !vis[it-&gt;to]) Dp2(it-&gt;to, nowAt, it-&gt;dis);&#125;void Solve(void)&#123; memset(vis,false,sizeof(vis)); maxDist = 0; Dp1(1); d1 = maxDist; memset(vis,false,sizeof(vis)); maxDist = INT_MAX; Dp2(1); r1 = maxDist; for(int i=2;;i++) if(!vis[i])&#123; memset(vis,false,sizeof(vis)); maxDist = 0; Dp1(i); d2 = maxDist; memset(vis,false,sizeof(vis)); maxDist = INT_MAX; Dp2(i); r2 = maxDist; break; &#125;&#125;signed main(void)&#123; int totLine,ans = INT_MAX; int fr,to,dis; scanf("%d", &amp;totLine); if(totLine-- == 1) &#123; puts("0"); goto END; &#125; for(int i=0;i&lt;totLine;i++)&#123; scanf("%d%d%d", &amp;fr,&amp;to,&amp;dis); line[i] = LINE(to,dis); line[i+totLine] = LINE(fr,dis); G[fr].push_back(line+i); G[to].push_back(line+i+totLine); &#125; memset(exist,true,sizeof(exist)); for(int i=0;i&lt;totLine;i++)&#123; exist[i] = exist[i+totLine] = false; con = line[i].dis; Solve(); ans = std::min(ans,std::max(r1+r2+con,std::max(d1,d2))); exist[i] = exist[i+totLine] = true; &#125; printf("%d\n", ans); END: return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>暴力/枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】数颜色/维护队列]]></title>
    <url>%2F2019%2F05%2F25%2FColorCounter%2F</url>
    <content type="text"><![CDATA[题目链接 大致意思是有一个长度为 $n$ 的数列，有 $m$ 种操作。每一个操作是回答区间 $[l,r]$ 中有多少不同的数或者修改一个位置上的数。输出所有询问操作的答案。 如果没有修改可以使用一个普通的莫队。将每一次修改看作是生成了一个新的版本，第 $i$ 个询问记作一个三元组 $(l_i,r_i,t_i)$. 其中 $t_i$ 代表这次询问的版本号，然后在莫队算法修改区间之前，切换到对应的版本，如果修改的数在当前区间内，还要修改一下记录的出现次数信息。 如果分块大小为 $\sqrt[3]{nt}$, 其中 $t$ 为版本数，那么有最小理论时间复杂度为 $O(\sqrt[3]{n^4t})$, 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;char ReadChar(void)&#123; char in; do in = getchar(); while(in!='Q' &amp;&amp; in!='R'); return in;&#125;constexpr auto MAXN = 50000+500;constexpr auto MAXM = 50000+500;constexpr auto MAXP = (int)1e6+500;struct Cg&#123; int pos,orig,targ; Cg()&#123;&#125; Cg(const int &amp;ipos,const int &amp;iorig, const int &amp;itarg) : pos(ipos),orig(iorig),targ(itarg) &#123;&#125;&#125;cg[MAXM];struct Query&#123; int fr,to,ver,ID,ans,first,second; Query()&#123;&#125; Query(const int &amp;ifr,const int &amp;ito,const int &amp;iver,const int &amp;iID) : fr(ifr),to(ito),ver(iver),ID(iID) &#123;&#125; bool operator &lt; (const Query&amp; Comp) const &#123; if(first != Comp.first) return first &lt; Comp.first; if(second != Comp.second) return second &lt; Comp.second; return ver &lt; Comp.ver; &#125;&#125;que[MAXM];bool Cmp(const Query&amp; a,const Query&amp; Comp)&#123; return a.ID &lt; Comp.ID; &#125;int num[MAXN],appear[MAXP],orig[MAXN];signed main(void)&#123; int totNums,totEven,totOptn=0,totVersion=0; int fr,to,ans,ver; char opt; scanf("%d%d", &amp;totNums,&amp;totEven); for(int i=1;i&lt;=totNums;i++)&#123; scanf("%d", num+i);orig[i] = num[i]; &#125; for(int i=0;i&lt;totEven;i++)&#123; opt = ReadChar(); scanf("%d%d", &amp;fr,&amp;to); switch(opt)&#123; case 'Q': que[totOptn++] = Query(fr,to,totVersion,i); break; case 'R': cg[totVersion++] = Cg(fr,orig[fr],to); orig[fr] = to; break; default: puts("RE"); assert(false); break; &#125; &#125; int BlkSize = pow(totVersion*totNums,1/3); for(int i=0;i&lt;totOptn;i++)&#123; que[i].first = que[i].fr / BlkSize; que[i].second = que[i].to / BlkSize; &#125; std::sort(que,que+totOptn); fr = 1;to = 0; ans = 0;ver = 0; for(int now = 0; now &lt; totOptn; now++)&#123; Query&amp; nowAt = que[now]; while(ver &gt; nowAt.ver)&#123; --ver; num[cg[ver].pos] = cg[ver].orig; if(fr&lt;=cg[ver].pos &amp;&amp; cg[ver].pos&lt;=to)&#123; if(--appear[cg[ver].targ] == 0) --ans; if(appear[cg[ver].orig]++ == 0) ++ans; &#125; &#125; while(ver &lt; nowAt.ver)&#123; num[cg[ver].pos] = cg[ver].targ; if(fr&lt;=cg[ver].pos &amp;&amp; cg[ver].pos&lt;=to)&#123; if(--appear[cg[ver].orig] == 0) --ans; if(appear[cg[ver].targ]++ == 0) ++ans; &#125; ++ver; &#125; while(fr &lt; nowAt.fr) if(--appear[num[fr++]] == 0) --ans; while(fr &gt; nowAt.fr) if(appear[num[--fr]]++ == 0) ++ans; while(to &gt; nowAt.to) if(--appear[num[to--]] == 0) --ans; while(to &lt; nowAt.to) if(appear[num[++to]]++ == 0) ++ans; nowAt.ans = ans; &#125; std::sort(que,que+totOptn,Cmp); for(int i=0;i&lt;totOptn;i++) printf("%d\n", que[i].ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】Miller-Rabin]]></title>
    <url>%2F2019%2F05%2F25%2FMiller_Rabin%2F</url>
    <content type="text"><![CDATA[使用 Miller-Rabin 可以快速测定一个整数是否是一个素数，随着测定次数的增加，测试的准确率也会上升。 原理费马小定理如果 $p$ 是一个素数，那么 a^p\equiv a\mod p二次勘测定理如果 $p$ 是一个素数 \forall x^2\equiv1\mod p,\quad\exists x\equiv1\mod p\;\mbox{ OR }\;x\equiv p-1\mod p 1234567891011121314151617181920212223242526272829303132333435363738template&lt;typename T&gt;T Mult(T a,T b, const T&amp; mod)&#123; T ans = 0; for(a%=mod;b;b&gt;&gt;=1,(a&lt;&lt;=1)%=mod) if(b&amp;1) (ans+=a)%=mod; return ans;&#125;template&lt;typename T&gt;T Pow(T a,T b, const T&amp; mod)&#123; T ans = 1; for(;b;a=Mult(a,a,mod),b&gt;&gt;=1) if(b&amp;1) ans = Mult(ans,a,mod); return ans;&#125;constexpr auto TIMES = 4;template&lt;typename type&gt;bool Miller_Rabin(type p)&#123; if(p&lt;=2 || (p&amp;1)==0) return p == 2; if(p==3||p==5||p==7||p==11||p==13) return true; if(p%3==0||p%5==0||p%7==0||p%11==0||p%13==0) return false; type m = p-1,k=0,a,x,y; //p=2^k*m+1 while((m&amp;1)==0)&#123; ++k; m&gt;&gt;=1; &#125; for(int i=0;i&lt;TIMES;i++)&#123; a = rand() % (p-1) + 1; x = Pow(a,m,p); for(int j=0;j&lt;k;j++)&#123; y = Mult(x,x,p); if(y == 1 &amp;&amp; x != 1 &amp;&amp; x != p-1) return false; x = y; &#125; if(y != 1) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CQOI2015-任务查询系统]]></title>
    <url>%2F2019%2F05%2F22%2FCQOI2015-System%2F</url>
    <content type="text"><![CDATA[题目链接 大致意思是有 $n$ 个任务，第 $i$ 个用三元组 $(s_i,e_i,p_i)$ 表示，代表时间从 $s_i$ 开始到 $e_i$ 结束，优先级为 $p_i$. 有 $n$ 组询问，在第 $x_i$ 秒时优先级最小的 $k_i$ 个任务优先级总和。强制在线。 首先考虑只有一个时间节点的情况，我们对优先级的建立值域线段树，如果这一时间有某个优先级为 $x$ 的任务正在执行，那么在代表 $[x,x]$ 这个区间的叶结点 $cnt$ 变量加一，同时对于一个代表 $[a,b]$ 区间的结点，记录两个变量 $cnt_{[a,b]}=\sum_{i\in[a,b]}cnt_{[i,i]}\quad sum_{[a,b]}=\sum_{i\in[a,b]}i\times cnt_{[i,i]}$. 这两个变量都满足区间加法。这样，利用线段树上二分处理询问。 对所有的时间都建立这样一个线段树，然后对于一个任务 $(s_i,e_i,p_i)$. 在第 $s_i$ 秒的线段树上让 $cnt_{p_i,p_i}+=1$, 在第 $e_i+1$ 秒的线段树上让 $cnt_{p_i,p_i}-=1$. 这么做保证了处理询问 $O(N\log P)$ 的时间复杂度，但是要耗费大量时间建立多颗线段树，以及 $O(NP)$ 的巨大空间复杂度。 由于每两个相邻时间的线段树在很大程度上都是相似的，所以使用可持久化线段树节省空间，只开一颗线段树保存所有版本作为时间结点对应的线段树。而值域 $P$ 也相对较大，可以动态开点省去一些不必要的结点。优化之后每次修改时空复杂度都最多 $O(\log P)$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 100000+50;constexpr auto MAXP = 10000000+50;//constexpr auto MAXP = 11;struct Rew_Info&#123; int time,pos; bool positive; Rew_Info()&#123;&#125; Rew_Info(const int &amp;itime, const int &amp;ipos, const bool &amp;iposit) : time(itime),pos(ipos),positive(iposit) &#123;&#125; bool operator &lt; (const Rew_Info&amp; comp) const &#123; return time &gt; comp.time; &#125;&#125;optnArray[MAXN&lt;&lt;1]; int optnTail;//SegTrstruct Node&#123; int cnt; long long sum; Node *lft,*rgt; Node() : cnt(0),sum(0) &#123; lft=rgt=nullptr; &#125; Node(const Node* inow) : cnt(inow-&gt;cnt),sum(inow-&gt;sum),lft(inow-&gt;lft),rgt(inow-&gt;rgt) &#123;&#125; Node&amp; Update(void)&#123; cnt = sum = 0; if(lft != nullptr)&#123; cnt += lft-&gt;cnt; sum += lft-&gt;sum; &#125; if(rgt != nullptr) &#123; cnt += rgt-&gt;cnt; sum += rgt-&gt;sum; &#125; return *this; &#125;&#125;*root = nullptr;std::vector&lt;Node*&gt; version;void Set(const int &amp;pos, const bool &amp;posit, Node*&amp; nowAt = root, const int nfr = 1, const int nto = MAXP)&#123; if(pos&lt;nfr || nto&lt;pos) return; if(nowAt == nullptr) nowAt = new Node(); else nowAt = new Node(nowAt); if(nfr == nto &amp;&amp; nfr == pos)&#123; nowAt-&gt;cnt += posit ? 1 : -1; nowAt-&gt;sum += posit ? nfr : -nfr; &#125; else &#123; Set(pos,posit,nowAt-&gt;lft,nfr,nfr+nto&gt;&gt;1); Set(pos,posit,nowAt-&gt;rgt,(nfr+nto&gt;&gt;1)+1,nto); nowAt-&gt;Update(); &#125;&#125;long long Query(int kth, Node* nowAt, const int nfr = 1, const int nto = MAXP)&#123; if(nowAt == nullptr) return 0; if(nowAt-&gt;cnt &lt;= kth) return nowAt-&gt;sum; if(nfr == nto)&#123; assert(nfr*nowAt-&gt;cnt == nowAt-&gt;sum); return kth*nfr; &#125; long long ans = Query(kth, nowAt-&gt;lft, nfr, nfr+nto&gt;&gt;1); kth -= nowAt-&gt;lft==nullptr ? 0 : nowAt-&gt;lft-&gt;cnt; if(kth &gt; 0) ans += Query(kth, nowAt-&gt;rgt, (nfr+nto&gt;&gt;1)+1, nto); return ans;&#125;std::queue&lt;Node*&gt; que,add;signed main(void)&#123; int totMission,timeRange; int beg,end,pri; scanf("%d%d", &amp;totMission,&amp;timeRange); for(int i=0;i&lt;totMission;i++)&#123; scanf("%d%d%d", &amp;beg,&amp;end,&amp;pri); optnArray[optnTail++] = Rew_Info(beg,pri,true); optnArray[optnTail++] = Rew_Info(end+1,pri,false); &#125; std::sort(optnArray, optnArray+optnTail); version.push_back(root); //Set_Table --optnTail; for(int i=1;i&lt;=timeRange;i++)&#123; for(;optnTail&gt;=0 &amp;&amp; optnArray[optnTail].time==i; --optnTail) Set(optnArray[optnTail].pos,optnArray[optnTail].positive); version.push_back(root); //New Version &#125; int time,kth,aa,bb,cc; long long pre = 1; while(timeRange--)&#123; scanf("%d%d%d%d", &amp;time,&amp;aa,&amp;bb,&amp;cc); kth = 1+((long long)aa*pre+bb)%cc; //scanf("%d%d", &amp;time,&amp;kth); printf("%lld\n", pre=Query(kth,version[time])); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】AHOI2013-差异]]></title>
    <url>%2F2019%2F05%2F21%2FAHOI2013-Difference%2F</url>
    <content type="text"><![CDATA[题目链接 大致意思是给定一个字符串 $s$, 定义 $T_i\;(\,i\in [0,|s|)\,)$ 为 $s$ 以第 $i$ 个字母开头的后缀，$\mbox{lcp}(a,b)$ 代表字符串 $a$ 和字符串 $b$ 的最长公共前缀。需要求出 \sum_{0\leq i]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀树</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】TJOI2015-弦论]]></title>
    <url>%2F2019%2F05%2F20%2FTJOI2015-StringTheory%2F</url>
    <content type="text"><![CDATA[题目链接 建立后缀树。由于后缀树每一条从 $t_0$ 出发到叶节点的链都代表了原串的一个后缀，那么从 $t_0$ 出发的链就是原串的一个后缀的一个前缀，也就是一个子串。 考虑 $t=1$ 的情况。如果一个结点 $v$ 长度为 $v_{len}$, 那么它可以代表 $len$ 个本质上不同的子串，这些子串在原串中出现的次数 $v_{times}$ 就是以 $v$ 为根的子树叶节点的个数。它对答案的贡献就是 $v_{len}\times v_{times}$. 要找到第 $k$ 个子串，只用预处理一下，从 $t_0$ 开始向下找，确定一下终止位置即可。 对于 $t=0$, 直接钦定所有的 $a_{times}=1$ . 时间复杂度为 $O(N)$, 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)5e5+50;constexpr auto MAXK = 28;int s[MAXN], totLen, remain;struct Node&#123; int start,len,appear; long long size; Node *ch[MAXK],*link; Node()&#123;&#125; Node(const int &amp;istart, const int &amp;ilen) : start(istart),len(ilen) &#123; for(int i=0;i&lt;MAXK;++i) ch[i] = nullptr; link = nullptr; &#125;&#125;*t0,*now,*virt;void Build(void)&#123; totLen = remain = 0; t0 = new Node(0,0); now = t0; virt = new Node();&#125;void Attend(const int&amp; add)&#123; s[totLen++] = add; ++remain; for(Node* last = virt, *t; remain;)&#123; while(now-&gt;ch[s[totLen-remain]]!=nullptr &amp;&amp; remain &gt; now-&gt;ch[s[totLen-remain]]-&gt;len)&#123; t = now-&gt;ch[s[totLen-remain]]; remain -= t-&gt;len; now = t; &#125; Node*&amp; v = now-&gt;ch[s[totLen-remain]]; int endChar_v = v==nullptr ? -1 : s[v-&gt;start+remain-1]; if(v==nullptr || endChar_v==add)&#123; last-&gt;link = now; last = now; if(v==nullptr) v = new Node(totLen-remain, INT_MAX); else break; &#125; else &#123; Node* split = new Node(v-&gt;start, remain-1); split-&gt;ch[endChar_v] = v; split-&gt;ch[add] = new Node(totLen-1, INT_MAX); v-&gt;start += remain-1; v-&gt;len -= remain-1; last-&gt;link = v = split; last = split; &#125; if(now == t0) --remain; else now = now-&gt;link; &#125;&#125;char strin[MAXN];int opt; long long kth;void DFS(Node* nowAt = t0)&#123; int ch = 0; nowAt-&gt;size = nowAt-&gt;appear = 0; if(nowAt-&gt;len &gt; totLen) nowAt-&gt;len = totLen-nowAt-&gt;start-1; for(int i=0;i&lt;MAXK;++i) if(nowAt-&gt;ch[i] != nullptr)&#123; DFS(nowAt-&gt;ch[i]); nowAt-&gt;size += nowAt-&gt;ch[i]-&gt;size; nowAt-&gt;appear += nowAt-&gt;ch[i]-&gt;appear; ++ch; &#125; if(ch == 0 || opt == 0) nowAt-&gt;appear = 1; nowAt-&gt;size += nowAt-&gt;appear*nowAt-&gt;len;&#125;void Dfs(Node* nowAt = t0)&#123; if((kth-=nowAt-&gt;appear*nowAt-&gt;len) &lt;= 0)&#123; int endPos = nowAt-&gt;start + nowAt-&gt;len + kth/nowAt-&gt;appear - 1; for(int i=nowAt-&gt;start;i&lt;=endPos;i++) putchar(s[i]+'a'); return; &#125; for(int i=0;i&lt;nowAt-&gt;len;i++) putchar(s[i+nowAt-&gt;start]+'a'); for(int i=0;i&lt;MAXK;i++) if(nowAt-&gt;ch[i] != nullptr) if(kth &gt; nowAt-&gt;ch[i]-&gt;size)&#123; kth -= nowAt-&gt;ch[i]-&gt;size; continue; &#125; else&#123; Dfs(nowAt-&gt;ch[i]); break; &#125; &#125;signed main(void)&#123; Build(); scanf("%s%d%lld", strin, &amp;opt,&amp;kth); for(int i=0;strin[i]!='\0';++i) Attend(strin[i]-'a'); Attend(MAXK-1); DFS(); if(t0-&gt;size &lt; kth) puts("-1"); else&#123; Dfs(); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀树</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】后缀树]]></title>
    <url>%2F2019%2F05%2F19%2FSuffixTree%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)1e6+50;constexpr auto MAXK = 28;//Suffix Treeint s[MAXN],remain,totLen;struct Node&#123; int start,len; Node *link, *ch[MAXK]; Node() &#123;&#125; Node(const int &amp;istart, const int &amp;ilen) : start(istart),len(ilen) &#123; memset(ch,NULL,sizeof(ch)); link = nullptr; &#125;&#125;*t0,*now,*vit;void Build(void)&#123; totLen = remain = 0; t0 = new Node(); now = t0; vit = new Node();&#125;void Attend(const int&amp; add)&#123; s[totLen++] = add; ++remain; for(Node* last = vit, *t; remain; )&#123; while(now-&gt;ch[s[totLen-remain]]!=nullptr &amp;&amp; now-&gt;ch[s[totLen-remain]]-&gt;len &lt; remain)&#123; t = now-&gt;ch[s[totLen-remain]]; remain -= t-&gt;len; now = t; &#125; Node*&amp; v = now-&gt;ch[s[totLen-remain]]; int endChar_v = v==nullptr ? MAXK-2 : s[v-&gt;start+remain-1]; if(v==nullptr || endChar_v==add) &#123; last-&gt;link = now; last = now; if(v == nullptr) v = new Node(totLen-remain, INT_MAX); else break; &#125; else &#123; Node* split = new Node(v-&gt;start, remain-1); split-&gt;ch[endChar_v] = v; split-&gt;ch[add] = new Node(totLen-1, INT_MAX); v-&gt;start += remain-1; v-&gt;len -= remain-1; last-&gt;link = v = split; last = split; &#125; if(now == t0) --remain; else now = now-&gt;link; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀树</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】后缀自动机]]></title>
    <url>%2F2019%2F05%2F17%2FSAM%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)1e6+5;char s[MAXN];struct Node&#123; int len,appear,ch[26],link; Node() &#123;&#125;&#125;pt[MAXN&lt;&lt;1];int t0=1,last=1,tail=2;int Attend(const char c)&#123; int p=last,cur=tail++; pt[cur].len=pt[last].len+1; pt[cur].appear=1; while(p!=0 &amp;&amp; pt[p].ch[c-'a']==0)&#123; pt[p].ch[c-'a']=cur; p=pt[p].link; &#125; if(p==0)pt[cur].link=t0; else&#123; int q=pt[p].ch[c-'a']; if(pt[p].len+1==pt[q].len) pt[cur].link=q; else&#123; int clone=tail++; pt[clone].link=pt[q].link; pt[clone].len=pt[p].len+1; for(int i=0;i&lt;26;++i) pt[clone].ch[i]=pt[q].ch[i]; while(p!=0 &amp;&amp; pt[p].ch[c-'a']==q)&#123; pt[p].ch[c-'a']=clone; p=pt[p].link; &#125; pt[cur].link=pt[q].link=clone; &#125; &#125; return last=cur;&#125;long long max,ttt; bool vis[MAXN&lt;&lt;1];std::vector&lt;int&gt; downLink[MAXN&lt;&lt;1];void DFS(int nowAt)&#123; vis[nowAt]=true; //printf("%d ",nowAt); for(int i=0; i&lt;26; ++i) if(pt[nowAt].ch[i]!=0 &amp;&amp; !vis[pt[nowAt].ch[i]]) DFS(pt[nowAt].ch[i]); //printf("OK "); if(pt[nowAt].link &gt;= 1) downLink[pt[nowAt].link].push_back(nowAt);&#125;void Dfs(const int &amp;nowAt)&#123; for(const auto &amp;it:downLink[nowAt])&#123; Dfs(it); pt[nowAt].appear += pt[it].appear; &#125; if(pt[nowAt].appear&gt;1 &amp;&amp; max&lt;(ttt=(long long)pt[nowAt].appear*pt[nowAt].len)) max=ttt;&#125;signed main(void)&#123; int len; scanf("%s", s); //printf("%d\n", len); for(int i=0;s[i]!='\0';++i) Attend(s[i]); // puts("0");printf("%d\n", tail); DFS(t0); /*puts("1");*/ Dfs(t0); printf("%lld\n", max); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1158C-Permutation recovery]]></title>
    <url>%2F2019%2F05%2F14%2FCF1158C-Permutation%20recovery%2F</url>
    <content type="text"><![CDATA[题目链接 题意大概是要你还原一个长度为 $n$ 的数列，它是一个从 1 到 $n$ 的排列。现在已知对于位置 $i$, 在他后面第一个比他大的数位置是 $d_i$. 输出任意满足条件的数列，或者无解输出 -1. 将每一个点看做一个结点，那么第 $i$ 个点比第 $d_i$ 个点小，区间 $(i,d_i)$ 内所有的点都比 $i$ 小。在他们之间连边，拓扑排序即可求出结果。 时间复杂度为 $O(N\log N)$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 500000+50;constexpr auto MAXT = 100000+50;struct Node&#123; int fr,to,inc; Node *lft,*rgt; std::vector&lt;Node*&gt; links; Node()&#123;&#125; Node(const int &amp;ifr,const int &amp;ito) : fr(ifr),to(ito),inc(1),lft(nullptr),rgt(nullptr) &#123;&#125; ~Node()&#123;&#125;&#125;*root = nullptr;Node *num[MAXN]; int orig[MAXN];std::queue&lt;Node*&gt; que,add;void Free(Node* targ)&#123; if(targ==nullptr) return; if(targ-&gt;lft!=nullptr) Free(targ-&gt;lft); if(targ-&gt;rgt!=nullptr) Free(targ-&gt;rgt); delete targ;&#125;void LINE(Node *&amp;beg, const int &amp;fr,const int &amp;to, Node* nowAt)&#123; assert(nowAt!=nullptr); if(fr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=to)&#123; beg-&gt;links.push_back(nowAt); nowAt-&gt;inc++; return; &#125; if(nowAt-&gt;fr &gt; to || nowAt-&gt;to &lt; fr) return; else&#123; LINE(beg,fr,to,nowAt-&gt;lft); LINE(beg,fr,to,nowAt-&gt;rgt); &#125;&#125;signed main(void)&#123; int totCases,totNums,d; Node *a,*b,*t; scanf("%d", &amp;totCases); while(totCases--)&#123; scanf("%d", &amp;totNums); //Build for(int i=1;i&lt;=totNums;i++)&#123; num[i]=new Node(i,i); orig[i]=-1; que.push(num[i]); &#125; for(;que.size()&gt;=2;std::swap(que,add))&#123; while(que.size()&gt;=2)&#123; a=que.front(); que.pop(); b=que.front(); que.pop(); t=new Node(a-&gt;fr,b-&gt;to); t-&gt;links.push_back(a); t-&gt;links.push_back(b); t-&gt;lft=a; t-&gt;rgt=b; add.push(t); &#125; if(!que.empty())&#123; add.push(que.front()); que.pop(); &#125; &#125;root = que.front(); que.pop(); root-&gt;inc=0; for(int i=1;i&lt;=totNums;i++)&#123; std::scanf("%d", &amp;d); if(d!=-1)&#123; if(d&lt;=totNums)&#123; num[d]-&gt;links.push_back(num[i]);num[i]-&gt;inc++; &#125; if(d&gt;i+1) LINE(num[i], i+1,d-1, root); &#125; &#125; d=totNums; que.push(root); while(!que.empty())&#123; t = que.front(); que.pop(); if(t-&gt;fr==t-&gt;to) orig[t-&gt;fr] = totNums--; for(auto &amp;it:t-&gt;links) if(--it-&gt;inc == 0) que.push(it); &#125; if(totNums&gt;0)&#123; puts("-1"); goto FIN; &#125; for(int i=1;i&lt;=d;i++) printf("%d ", orig[i]); putchar('\n'); FIN: Free(root); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线段树</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1158A-The Party and Sweets]]></title>
    <url>%2F2019%2F05%2F13%2FCF1158A%2F</url>
    <content type="text"><![CDATA[题目链接 题意大致是一次派对有 $n$ 个男生和 $m$ 个女生出席。男生们在派对上给了女生们一些糖。第 $i$ 个男生给糖时最少的一次给了 $a_i$ 颗糖；第 $i$ 个女生在接收糖时最多一次收了 $b_i$ 颗。现在需要求出男生们最少一共给了多少颗糖。 首先我们将所有的 $a$ 和 $b$ 升序排序，并按照排序的结果对所有人重新编号。假定第 $n$ 个男生给了第一个女生 $a_n$ 颗糖，给了第 $i(i&gt;1)$ 个女生 $b_i$ 颗糖。如果 $a_n&lt;b_1$, 那么第 $n-1$ 个男生给了第一个女生 $b_1$ 颗糖，否则他遵从后面所有男生的规则。剩下第 $i$ 个男生给了所有女生每人 $a_i$ 颗糖。这样构造是满足题意的。而且总数最少。 如果 $a_n&lt;b_1$, 无解。 为什么这么做是对的？由于男生给的最少的一次也给了 $a_i$ 颗，所以先让他给所有女生 $a_i$ 颗。然后考虑 $b$, 由于 $b$ 可能远大于 $a$, 所以这收的最多的很可能只收了一次，这一次就让第 $n$ 个男生给。而由于第 $n$ 个男生至少有一次只给了 $a_n$ 颗，所以当 $b_1&gt;a_n$ 时，让下一个男生填上。 代码如下: 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 100000+500;long long boy[MAXN],girl[MAXN];signed main(void)&#123; int n,m; long long tot=0; scanf("%d%d", &amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%I64d", boy+i); for(int i=1;i&lt;=m;i++) scanf("%I64d", girl+i); std::sort(boy+1,boy+1+n); std::sort(girl+1,girl+1+m); if(boy[n]&gt;girl[1])&#123; puts("-1"); goto END; &#125; for(int i=1;i&lt;=n;i++) tot+=boy[i]*m; for(int i=2;i&lt;=m;i++) tot+=girl[i]-boy[n]; if(girl[1]&gt;boy[n]) tot+=girl[1]-boy[n-1]; printf("%I64d\n", tot); END: return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】阿狸和桃子的游戏]]></title>
    <url>%2F2019%2F05%2F12%2F%E9%98%BF%E7%8B%B8%E5%92%8C%E6%A1%83%E5%AD%90%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目链接 我们从点权入手，最终选择的是点，而边权可以通过转化变成点权。 对于任意一条边 $E=(a,b,c)$, 我们将 $a$ 和 $b$ 的点权都加上 $\frac c2$. 这样在选择时如果我们同时选择了这两个点，那么得到点权和所有的边权。如果我们只选择其中一个，那么分数差不会有变化。如果两个都没选，那么对手获得边权。 这样处理之后排序，即可在 $O(N\log N)$ 时间复杂度内解决这道题。 代码如下: 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;signed main(void)&#123; constexpr auto MAXN = 10000+50; int totNums,totEdge,fr,to; long long a[MAXN]=&#123;&#125;,val,tot=0; scanf("%d%d", &amp;totNums,&amp;totEdge); for(int i=0;i&lt;totNums;i++)&#123; scanf("%lld", a+i);a[i]&lt;&lt;=1; &#125; while(totEdge--)&#123; scanf("%d%d%lld", &amp;fr,&amp;to,&amp;val); a[fr-1] += val; a[to-1] += val; &#125; std::sort(a,a+totNums,[](const long long&amp; aa,const long long&amp; comp)&#123; return aa&gt;comp; &#125;); for(int i=0;i&lt;totNums;i++) tot+=(i&amp;1)?-a[i]:a[i]; printf("%lld\n", tot&gt;&gt;1); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【API】Treap]]></title>
    <url>%2F2019%2F05%2F11%2FAPI-Treap%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150template&lt;typename type&gt;class Treap&#123;private: struct Node&#123; size_t size,cnt; int pri; type val; Node *lft,*rgt; Node()&#123;&#125; Node(const type&amp; ival) : pri(rand()),val(ival),lft(nullptr),rgt(nullptr),size(1),cnt(1) &#123;&#125; Node&amp; Refresh(void)&#123; size=cnt; if(lft!=nullptr) size+=lft-&gt;size; if(rgt!=nullptr) size+=rgt-&gt;size; return *this; &#125; &#125;*root = nullptr; void Free(Node *&amp;targ)&#123; if(targ==nullptr) return; if(targ-&gt;lft!=nullptr) Free(targ-&gt;lft); if(targ-&gt;rgt!=nullptr) Free(targ-&gt;rgt); delete targ; &#125; void Left_Rotate(Node *&amp;targ)&#123; Node *temp=targ-&gt;rgt; targ-&gt;rgt = temp-&gt;lft; temp-&gt;lft = targ; targ-&gt;Refresh(); temp-&gt;Refresh(); targ=temp; &#125; void Right_Rotate(Node *&amp;targ)&#123; Node *temp=targ-&gt;lft; targ-&gt;lft = temp-&gt;rgt; temp-&gt;rgt = targ; targ-&gt;Refresh(); temp-&gt;Refresh(); targ=temp; &#125; void Insert(const type&amp; val, Node *&amp;nowAt)&#123; if(nowAt==nullptr)&#123; nowAt = new Node(val); return; &#125; if(nowAt-&gt;val==val)&#123; nowAt-&gt;cnt++; nowAt-&gt;Refresh(); return; &#125; else if(val&lt;nowAt-&gt;val)&#123; //lft Insert(val,nowAt-&gt;lft); if(nowAt-&gt;lft-&gt;pri &lt; nowAt-&gt;pri) Right_Rotate(nowAt); &#125; else if(val&gt;nowAt-&gt;val)&#123;//rgt Insert(val,nowAt-&gt;rgt); if(nowAt-&gt;rgt-&gt;pri &lt; nowAt-&gt;pri) Left_Rotate(nowAt); &#125; nowAt-&gt;Refresh(); &#125; void Remove(const type&amp; val, const size_t&amp; cnt, Node *&amp;nowAt)&#123; if(nowAt==nullptr) return; else if(val&lt;nowAt-&gt;val) Remove(val,cnt,nowAt-&gt;lft); else if(val&gt;nowAt-&gt;val) Remove(val,cnt,nowAt-&gt;rgt); else&#123; assert(val==nowAt-&gt;val); if(nowAt-&gt;cnt &lt;= cnt)&#123; nowAt-&gt;cnt = 0; nowAt-&gt;Refresh(); if(nowAt-&gt;lft!=nullptr &amp;&amp; nowAt-&gt;rgt!=nullptr)&#123; if(nowAt-&gt;lft-&gt;pri &lt; nowAt-&gt;rgt-&gt;pri)&#123; Right_Rotate(nowAt); Remove(val,0,nowAt-&gt;rgt); &#125; else &#123; Left_Rotate(nowAt); Remove(val,0,nowAt-&gt;lft); &#125; &#125; else&#123; Node *temp = nowAt; if(nowAt-&gt;lft!=nullptr || nowAt-&gt;rgt!=nullptr) if(nowAt-&gt;lft!=nullptr) nowAt=nowAt-&gt;lft; else nowAt=nowAt-&gt;rgt; else nowAt=nullptr; delete temp; return; &#125; &#125; else nowAt-&gt;cnt-=cnt; &#125; nowAt-&gt;Refresh(); &#125; void ToVector(std::vector&lt;type&gt;&amp; arr, Node *&amp;nowAt)&#123; if(nowAt==nullptr) return; ToVector(arr,nowAt-&gt;lft); for(int i=0;i&lt;nowAt-&gt;cnt;i++) arr.push_back(nowAt-&gt;val); ToVector(arr,nowAt-&gt;rgt); &#125;public: Treap()&#123; srand((signed)time(NULL)); &#125; ~Treap()&#123; Free(root); &#125; size_t Size(void) const &#123; return root==nullptr?0:root-&gt;size; &#125; bool IsEmpty(void) const &#123; return Size()==0; &#125; Treap&lt;type&gt;&amp; Clear(void)&#123; Free(root); root = nullptr; return *this; &#125; Treap&lt;type&gt;&amp; Insert(const type&amp; val)&#123; Insert(val,root); return *this; &#125; Treap&lt;type&gt;&amp; Remove(const type&amp; val,const size_t&amp; cnt=1)&#123; Remove(val,cnt,root); if(IsEmpty())&#123; delete root;root=nullptr; &#125; return *this; &#125; type Kth_Element(size_t kth) const &#123; Node* nowAt = root; while(nowAt!=nullptr)&#123; if(nowAt-&gt;lft!=nullptr)&#123; if(nowAt-&gt;lft-&gt;size &gt;= kth)&#123; nowAt=nowAt-&gt;lft; continue; &#125; kth -= nowAt-&gt;lft-&gt;size; &#125; if(nowAt-&gt;cnt &gt;= kth) return nowAt-&gt;val; kth -= nowAt-&gt;cnt; nowAt=nowAt-&gt;rgt; &#125; throw 1; &#125; size_t Get_Position(const type&amp; val) const &#123; Node* nowAt = root; size_t pos=0; while(nowAt!=nullptr)&#123; if(nowAt-&gt;val &gt; val)&#123; nowAt = nowAt-&gt;lft;continue; &#125; if(nowAt-&gt;lft != nullptr) pos+=nowAt-&gt;lft-&gt;size; if(nowAt-&gt;val == val) break; pos+=nowAt-&gt;cnt; nowAt=nowAt-&gt;rgt; &#125; return pos+1; &#125; size_t Count(const type&amp; val) const &#123; Node* nowAt = root; while(nowAt!=nullptr)&#123; if(nowAt-&gt;val==val) return nowAt-&gt;cnt; else if(val&lt;nowAt-&gt;val) nowAt=nowAt-&gt;lft; else nowAt=nowAt-&gt;rgt; &#125; return 0; &#125; type Upper(const type&amp; val) const &#123; bool found=false; type match; Node* nowAt=root; while(nowAt!=nullptr)&#123; if(nowAt-&gt;val &gt; val)&#123; found=true; match=nowAt-&gt;val; nowAt=nowAt-&gt;lft; &#125; else nowAt = nowAt-&gt;rgt; &#125; if(found) return match; else throw 1; &#125; type Lower(const type&amp; val) const &#123; bool found=false; type match; Node* nowAt=root; while(nowAt!=nullptr)&#123; if(nowAt-&gt;val &lt; val)&#123; found=true; match=nowAt-&gt;val; nowAt=nowAt-&gt;rgt; &#125; else nowAt = nowAt-&gt;lft; &#125; if(found) return match; else throw 1; &#125; std::vector&lt;type&gt; ToVector(void)&#123; std::vector&lt;type&gt; arr; ToVector(arr,root); return arr; &#125;&#125;;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】APIO2014序列分割]]></title>
    <url>%2F2019%2F05%2F10%2FAPIO2014-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[题目链接 首先证明，分割顺序与结果无关。假定一个序列 $Q=\overline{ABC}$, 使用不同的分割方法分两次得到的分数分别为 s_1=a(b+c)+bc=ab+ac+bc\\ s_2=c(a+b)+ab=ab+ac+bc首先预处理一下前缀和 $s_i=\sum_{j=1}^i a_j$. 记 $f_{k,i}$ 代表考虑前 $i$ 个元素，已经分割了 $k$ 次的最大得分。那么转移方程为 f_{k,i}=\max_{j]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率优化动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SHOI2013 扇形面积并]]></title>
    <url>%2F2019%2F05%2F10%2FSHOI2013-%E6%89%87%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[题目链接 首先，我们将区间编号 $(-m,m]$ 映射到 $(0,2m]$. 对于每一个圆心角从 $\frac {\pi a_i}m$ 到 $\frac{\pi a_2}m$ 的扇形，如果 $a_1&lt;a_2$ 那么将其转换为一条线段 $[a_1,a_2]$, 否则转换为 $[a_1,2m]$ 和 $(0,a_2]$ 两条。然后使用扫描线算法，对于每一块区间如果有不少于 $k$ 条半径覆盖，那么找到倒数第 $k$ 大的半径，记区间长度为 $m_0$, 它对答案的贡献就是 $m_0r^2$. 在具体实现中，利用平衡树维护半径的集合，总时间复杂度为 $O(N\log N)$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include&lt;bits/stdc++.h&gt;template&lt;typename type&gt;class Splay_Tree&#123;protected:#define ROTATE_LEFT 0#define ROTATE_RIGHT 1private: struct Node &#123; type val; size_t cnt, size; Node *up, *ch[2]; int Comp(const type &amp;CompVal)const &#123; if (CompVal == val)return -1; else return CompVal &lt; val ? 0 : 1; &#125; Node&amp; Refresh(void) &#123; size = cnt; if (ch[0] != nullptr)size += ch[0]-&gt;size; if (ch[1] != nullptr)size += ch[1]-&gt;size; return *this; &#125; bool Exist(void) const &#123; return cnt &gt; 0; &#125; &#125;*root = nullptr; Node* NewNode() &#123; Node* ret = (Node*)malloc(sizeof(Node)); ret-&gt;up = ret-&gt;ch[0] = ret-&gt;ch[1] = nullptr; return ret; &#125; void Rotate(Node *&amp;targ) &#123; Node* fa = targ-&gt;up; const int position = fa-&gt;Comp(targ-&gt;val) ^ 1; fa-&gt;ch[position ^ 1] = targ-&gt;ch[position]; if (targ-&gt;ch[position] != nullptr) targ-&gt;ch[position]-&gt;up = fa; targ-&gt;ch[position] = fa; targ-&gt;up = fa-&gt;up; fa-&gt;up = targ; fa-&gt;Refresh(); targ-&gt;Refresh(); &#125; void Splay(Node *nowAt) &#123; for (; nowAt-&gt;up != nullptr &amp;&amp; nowAt-&gt;up != root; Rotate(nowAt)) if (nowAt-&gt;up-&gt;Comp(nowAt-&gt;val) == nowAt-&gt;up-&gt;up-&gt;Comp(nowAt-&gt;up-&gt;val)) Rotate(nowAt-&gt;up); else Rotate(nowAt); if (nowAt-&gt;up == root)Rotate(nowAt); root = nowAt; &#125; void Insert(Node* ins) &#123; Node* nowAt = root; int nxt; while (true) &#123; nxt = nowAt-&gt;Comp(ins-&gt;val); nowAt-&gt;size += ins-&gt;size; if (nowAt-&gt;ch[nxt] == nullptr) &#123; nowAt-&gt;ch[nxt] = ins; ins-&gt;up = nowAt; Splay(nowAt-&gt;ch[nxt]); return; &#125; else nowAt = nowAt-&gt;ch[nxt]; &#125; &#125; void AccessRoot(void) &#123; if (root-&gt;Exist())return; Node* del = root; if (root-&gt;ch[0] == nullptr&amp;&amp;root-&gt;ch[1] == nullptr) &#123; free(del); root = nullptr; return; &#125; else if (root-&gt;ch[0] == nullptr) &#123; root = root-&gt;ch[1]; root-&gt;up = nullptr; &#125; else if (root-&gt;ch[1] == nullptr) &#123; root = root-&gt;ch[0]; root-&gt;up = nullptr; &#125; else &#123; Node *a = root-&gt;ch[0]; root = root-&gt;ch[1]; root-&gt;up = nullptr; Insert(a); &#125;free(del); &#125;public: size_t Size(void) const &#123; return root==nullptr?0:root-&gt;size; &#125; Splay_Tree&amp; Insert(const type&amp; ins) &#123; if (root == nullptr) &#123; root = NewNode(); root-&gt;cnt = root-&gt;size = 1; root-&gt;val = ins; return *this; &#125; Node* nowAt = root; int nxt; while(true) &#123; nxt = nowAt-&gt;Comp(ins); nowAt-&gt;size++; if (nxt == -1) &#123; nowAt-&gt;cnt++; Splay(nowAt); return *this; &#125; if (nowAt-&gt;ch[nxt] == nullptr) &#123; nowAt-&gt;ch[nxt] = NewNode(); nowAt-&gt;ch[nxt]-&gt;up = nowAt; nowAt-&gt;ch[nxt]-&gt;val = ins; nowAt-&gt;ch[nxt]-&gt;cnt = nowAt-&gt;ch[nxt]-&gt;size = 1; Splay(nowAt-&gt;ch[nxt]); return *this; &#125; else nowAt = nowAt-&gt;ch[nxt]; &#125; &#125; type KthElement(const size_t &amp;kth) &#123; Node* nowAt = root; size_t cnt = 0; while (nowAt != nullptr) &#123; if (nowAt-&gt;ch[0] != nullptr) &#123; if ((cnt + nowAt-&gt;ch[0]-&gt;size) &lt; kth) cnt += nowAt-&gt;ch[0]-&gt;size; else &#123; nowAt = nowAt-&gt;ch[0]; continue; &#125; &#125; if (cnt &lt; kth &amp;&amp; kth &lt;= cnt + nowAt-&gt;cnt) &#123; Splay(nowAt); return root-&gt;val; &#125; cnt += nowAt-&gt;cnt; nowAt = nowAt-&gt;ch[1]; &#125; throw 1; &#125; size_t GetPosition(const type&amp; query) &#123; size_t cnt = 0; Node* nowAt = root; while (nowAt != nullptr) &#123; if (nowAt-&gt;val &gt; query) &#123; nowAt = nowAt-&gt;ch[0]; continue; &#125; if (nowAt-&gt;ch[0] != nullptr)cnt += nowAt-&gt;ch[0]-&gt;size; if (nowAt-&gt;val == query) &#123; Splay(nowAt); return cnt + 1; &#125; cnt += nowAt-&gt;cnt; nowAt = nowAt-&gt;ch[1]; &#125;throw - 1; &#125; type Upper(const type &amp;lower) &#123; bool found = false; type match; Node* nowAt = root, *targ; while (nowAt != nullptr) &#123; if (nowAt-&gt;val &gt; lower) &#123; found = true; match = nowAt-&gt;val; targ = nowAt; nowAt = nowAt-&gt;ch[0]; &#125; else nowAt = nowAt-&gt;ch[1]; &#125; if (found) &#123; Splay(targ); return match; &#125; else throw 1; &#125; type Lower(const type &amp;Upper) &#123; bool found = false; type match; Node* nowAt = root, *targ; while (nowAt != nullptr) &#123; if (nowAt-&gt;val &lt; Upper) &#123; found = true; match = nowAt-&gt;val; targ = nowAt; nowAt = nowAt-&gt;ch[1]; &#125; else nowAt = nowAt-&gt;ch[0]; &#125; if (found) &#123; Splay(targ); return match; &#125; else throw 1; &#125; Splay_Tree&amp; Delete(const type &amp;val) &#123; Node* nowAt = root; int nxt; while (nowAt != nullptr) &#123; --nowAt-&gt;size; if (nowAt-&gt;val == val) &#123; --nowAt-&gt;cnt; Splay(nowAt); AccessRoot(); return *this; &#125; nowAt = nowAt-&gt;ch[nowAt-&gt;Comp(val)]; &#125;throw 1; &#125;&#125;;Splay_Tree&lt;int&gt; tr;constexpr auto MAXN = (int)1e5+50;constexpr auto MAXM = (int)1e6+500;struct LINE&#123; int pos,r; bool start; LINE() &#123;&#125; LINE (const int &amp;ipos,const int &amp;ir,const bool &amp;ist) : pos(ipos),r(ir),start(ist) &#123;&#125; bool operator &lt; (const LINE&amp; comp) const&#123; return pos&lt;comp.pos||pos==comp.pos&amp;&amp;start&amp;&amp;!comp.start; &#125;&#125;;std::vector&lt;LINE&gt; lin;void Attend(const int &amp;r,const int &amp;begin,const int &amp;end)&#123; lin.push_back(LINE(begin,r,true)); lin.push_back(LINE(end,r,false));&#125;signed main(void)&#123; int n,m,k; int r,beg,end; scanf("%d%d%d", &amp;n,&amp;m,&amp;k); while(n--)&#123; scanf("%d%d%d", &amp;r,&amp;beg,&amp;end); beg+=m; end+=m; if(beg&lt;=end) Attend(r,beg,end); else&#123; Attend(r,0,end); Attend(r,beg,m&lt;&lt;1); &#125; &#125; std::sort(lin.begin(),lin.end()); // lin.push_back(LINE(INT_MAX,0,true)); long long tot=0;int lastPos=0; for(int i=0;i&lt;lin.size();i++)&#123; const LINE&amp; nowAt=lin[i]; //Cult if(i!=0&amp;&amp;nowAt.pos!=lin[i-1].pos)&#123; if(tr.Size()&gt;=k)&#123; r=tr.KthElement(tr.Size()-k+1); tot+=r*r*(nowAt.pos-lastPos); &#125; lastPos=nowAt.pos; &#125; //apply if(nowAt.start) tr.Insert(nowAt.r); else tr.Delete(nowAt.r); &#125; printf("%lld\n", tot); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演描述了两个函数之间的一些关系，在很多情况下可以简化计算。 假定 $F(n)$ 和 $f(n)$ 是定义在非负整数集合上的两个函数，满足 F(n)=\sum_{d\mid n}f(d)那么 f(n)=\sum_{d\mid n}\mu\left(\frac dn\right)F(d)这里的 $\mu$ 是莫比乌斯函数 \mu(n)=\begin{cases} 1&n=1\\ (-1)^k&n=\prod_{i=1}^kp_i\mbox{,}\quad p_i\mbox{均为互异素数}\\ 0&\mbox{Otherwise} \end{cases}证明： \begin{align} \sum_{d\mid n}\mu(d)F\left(\frac nd\right)&=\sum_{d\mid n}\mu(d)\sum_{d^\prime\mid \frac nd}f(d^\prime)\\ &=\sum_{d\mid n}\sum_{d^\prime\mid\frac nd}\mu(d)f(d^\prime)\\ &=\sum_{d^\prime\mid n}f(d^\prime)\sum_{d\mid\frac nd}\mu(d)=f(n) \end{align}以上是莫比乌斯反演的一般描述，它还有另外一种描述，同样是定义在非负整数集合上的两个函数 $F(n)$ 和 $f(n)​$ F(n)=\sum_{n\mid d}f(d)\Rightarrow f(n)=\sum_{n\mid d}\mu\left(\frac dn\right)F(d) 莫比乌斯函数 $\mu$ 的计算可以随着筛素数同时进行，代码如下： 12345678910111213primes=0; mu[1]=1;memset(isPrime,true,sizeof(isPrime));memset(rend_mu,false,sizeof(rend_mu));for(long long i=2;i&lt;MAXN;i++)&#123; if(isPrime[i])&#123; prime[primes++]=i; mu[i] = -1; &#125; for(int j=0;j&lt;primes&amp;&amp;prime[j]*i&lt;MAXN;j++)&#123; isPrime[i*prime[j]] = false; if(i%prime[j]==0)&#123; mu[prime[j]*i] = 0;break; &#125; mu[prime[j]*i] = -mu[i]; &#125;&#125; 莫比乌斯函数是一个积性函数，满足如下性质： \sum_{d\mid n}\mu(d)=\begin{cases} 1&\mbox{if }n=1\\0&\mbox{Otherwise} \end{cases}]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SHOI2016 黑暗前的幻想乡]]></title>
    <url>%2F2019%2F03%2F17%2FSHOI2016-%E9%BB%91%E6%9A%97%E5%89%8D%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[这道题目大致意思是有 $n$ 个地点，$n-1$ 个公司在这些地点之间修路，其中第 $i$ 个公司可以修理的道路集合为 $A_i$. 现在我们需要选择 $n-1$ 条路使得这些地点相互联通，并且保证每个公司修理其中的一条路，现在需要知道可行的方案数。 首先去掉每个公司修一条路这个条件不看，方案数就是所有边加进来之后的不同生成树的个数，这些方案当中可能包含了一个或者多个公司没有修路的情况，于是我们减掉不考虑其中一个公司的方案数，加上不考虑其中两个公司的方案数，如此容斥最终就是满足题意的答案。 具体实现可以使用深度优先搜索，每一次确定一个选择的公司集合，然后利用矩阵-树定理求解生成树，判断一下去掉了多少个公司。 最终的时间复杂度为 $O(2^{n-1}n^3)$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;constexpr long long MOD = (1e9)+7;constexpr auto MAXN = 17+5;int totCity, totComp;long long C[MAXN][MAXN];struct Road&#123; int fr,to; Road(const int &amp;ifr,const int &amp;ito) : fr(ifr),to(ito)&#123;&#125;&#125;;std::vector&lt;Road&gt; fixList[MAXN];int use[MAXN];void Render(const int &amp;used)&#123; memset(C,0,sizeof(C)); for(int i=0;i&lt;used;i++)&#123; for(const auto &amp;it:fixList[use[i]])&#123; C[it.fr][it.fr]++; C[it.to][it.to]++; C[it.fr][it.to]--; C[it.to][it.fr]--; &#125; &#125; for(int i=0;i&lt;totCity;i++) for(int j=0;j&lt;totCity;j++) ((C[i][j]%=MOD)+=MOD)%=MOD;&#125;long long Solve(void)&#123; long long ans=1,t; for(int j=1;j&lt;totCity;j++)&#123; for(int i=j+1;i&lt;totCity;i++)&#123; while(C[i][j])&#123; t=C[j][j]/C[i][j]; for(int k=j;k&lt;totCity;k++)&#123; (((C[j][k]-=t*C[i][k])%=MOD)+=MOD)%=MOD; std::swap(C[j][k], C[i][k]); &#125; ans*=-1; &#125; &#125; (((ans*=C[j][j])%=MOD)+=MOD)%=MOD; &#125; return ans;&#125;long long ans=0;void Dfs(const int nowAt,const int cntCse)&#123; if(nowAt&gt;=totComp)&#123; Render(cntCse); (((ans += (totComp-cntCse&amp;1?-1:1) * Solve())%=MOD)+=MOD)%=MOD; return; &#125; use[cntCse]=nowAt; Dfs(nowAt+1,cntCse+1); //use[cntCse]=0; Dfs(nowAt+1,cntCse);&#125;signed main(void)&#123; int roadCnt; int fr,to; scanf("%d", &amp;totCity); totComp = totCity-1; for(int i=0;i&lt;totComp;i++)&#123; scanf("%d", &amp;roadCnt); while(roadCnt--)&#123; scanf("%d%d", &amp;fr,&amp;to); fixList[i].push_back(Road(fr-1,to-1)); &#125; &#125; Dfs(0,0); printf("%lld\n", ((ans%=MOD)+=MOD)%=MOD); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>矩阵</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵-树定理]]></title>
    <url>%2F2019%2F03%2F14%2F%E7%9F%A9%E9%98%B5-%E6%A0%91%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[矩阵-树定理在图和矩阵之间建立联系，其中矩阵代表一个无向图的 Kirchhoff矩阵，树则是生成树。矩阵-树定理可以用来求解一个无向图 $G=\{V,E\}$ 的不同生成树的个数。 概念首先，我们将图 $G$ 转换成为几个矩阵：$D_G$ 是 $G$ 的度数矩阵，其中 $D_{ii}$ 代表一个结点 $i\in V$ 的度数，$\forall i\not=j,\ D_{ij}=0$. $A_G$ 是 $G$ 的邻接矩阵，$A_{ij}$ 代表 $G$ 中两个结点 $i,\ j$ 之间有多少条无向边相连。 然后定义 $G$ 的Kirchhoff矩阵 $C_G=D_G-A_G$. 它的一个 $n-1$ 阶主子式就是对于 $1\leq r\leq n$, 将 $C_G$ 的第 $r$ 行和第 $r$ 列同时去掉之后得到的矩阵，记为 $C_{_rG}$. 矩阵-树定理可以描述为 $G$ 的Kirchhoff矩阵的任何一个 $n-1$ 阶主子式 $C_{_rG}$ 的绝对值等于其不同生成树的个数。 接下来我们可以看看这个 Kirchhoff矩阵都有些什么性质，并尝试从这些性质出发找到矩阵-树定理成立的原因。 $\forall G$, 它的Kirchhoff矩阵的行列式总是 0. 可以发现，任意一个图的Kirchhoff矩阵每行所有元素的总和总是 0，因此它的行列式 $\det(C)=0$. 如果 $G$ 不联通，那么 $\det(C)=0$. 假定 $G$ 有 $k$ 个连通分量，分别为 $G_1,G_2,\cdots,G_k$, 那么我们通过交换行列式中的行和列，使得每一个连通分量中的元素都在矩阵中紧密相连： \begin{bmatrix} G_1&0&\cdots&0\\ 0&G_2&\cdots&0\\ \vdots&\vdots&\ddots&\vdots\\ 0&0&\cdots&G_k \end{bmatrix}这里的 $G_i$ 就是第 $i$ 个连通分量构成的Kirchhoff矩阵，而不同的联通块中的节点之间没有连边，所以矩阵中其他位置的所有元素都是 0. \det(G)=\prod_{i=0}^k\det(G_i)=0 如果 $G$ 是一颗树，那么 $C$ 的任意一个 $n-1$ 阶主子式都是 0. 像之前一样，为了求出 $\det(C_r)$, 我们通过不停地变换矩阵，使其成为一个上三角矩阵。首先任意钦定一个根结点 $r$，然后将根结点在矩阵中对应的行列变换到矩阵的第一行第一列，随后对于其他节点，按照与根结点的距离，变换到后面的行列，这样一来，靠上的行可靠前的列对应的节点在树中的深度也就越浅。由于归位一个结点需要进行两次对换，因此最终的对换中次数是 2 的倍数，行列式不变号。接下来，按照得到的深度顺序逆序处理，对于当前的一个结点 $i$, 如果它的父亲不是根结点，那么将 $i$ 所在的列加到它父亲所在的列上。 这么做最终得到的行列式就是一个主对角线元素全部是 1 的上三角矩阵。可以用数学归纳法证明。首先最后一列肯定符合要求，对于第 $i\;(i&gt;1)$ 列，假定 $i+1$ 列一直到第 $k$ 列都符合要求，考虑第 $i$ 列的第 $i+1$ 行至第 $k$ 行，如果某一个元素在原先的矩阵中是 -1，那么代表 $i$ 与它某一个儿子有一条连边，我们在考虑这个儿子的时候就将其加到了这一列，因此这里现在是 0，而对于第 $i$ 行，它所有的儿子都对这个元素造成了 -1 的贡献，而最终与其相连而没有造成贡献的就只有 $i$ 的父亲了，因此第 $i$ 行第 $i$ 列的元素为 1. 最后直接删掉根结点所在的行和列，得到的就是符合要求的矩阵 $C_r$. \det(C_r)=0接下来证明矩阵-树定理。 证明矩阵-树定理需要使用到无向图 $G$ 的关联矩阵 $B$. $B$ 是一个 $n$ 行 $m$ 列的矩阵，其中每一行代表一个结点，每一列描述一条无限边，如果第 $i$ 条边连接了结点 $v_i$ 和 $s_i$, 那么 $B$ 中第 $i$ 列的 $v_i$ 行和 $s_i$ 行这两个元素有一个是 1，另一个是 -1. 这里正负号并不重要。$B$ 中其它的元素都是 0. 那么我们可以发现 C=BB^T这样，我们将 $C$ 转换到 $BB^T$ 上。如果 $A$ 是一个矩阵，$r$ 是一个数或者集合，定义记号 $A_r$ 代表将 $A$ 中第 $r$ 行（属于 $r$ 的集合）去掉得到的矩阵，定义 $A^r$ 代表将 $A$ 中属于 $r$ 的列提取得到的矩阵。利用 Binet-Cauchy 公式，得到 \det(C_r)=\det(B_rB_r^T)=\sum_{x\subset E\\|x|=n-1}\det(B_r^x)\det({B_r^x}^T)=\sum_{x\subset E\\|x|=n-1}\det(B_r^x{B_r^x}^T)=\sum_{x\subset E\\|x|=n-1}(\det(B_r^x))^2考虑 \sum_{x\subset E\\|x|=n-1}\det(B_r^x{B_r^x}^T)这里 $x$ 是一个由边组成的集合，集合中所有元素的数量为 $n-1$. 可以断言，如果这 $n-1$ 条边将 $n$ 个结点连城了一棵树，那么 $\det(B_r^x{B_r^x}^T)=1$, 否则必定有至少一个环出现，$\det(B_r^x{B_r^x}^T)=0$. 首先假定 $x$ 中的边构成了一棵树，那么原式相当于只看 $x$ 中的边构成的Kirchhoff矩阵的一个 $n-1$ 阶主子式，之前已经证明过它的行列式等于 1. 接下来考虑构成环的情况，我们将行列式进行行和列的对换，使得这个环中的元素集中到行列式的左上角。例如有一个大小为 3 的环，重排矩阵后 \begin{bmatrix}\begin{matrix} 1&0&1\\-1&1&0\\0&-1&-1 \end{matrix}&A^\prime\\0&B^\prime \end{bmatrix}可以发现，右上角的子矩阵 S^\prime=\begin{bmatrix} 1&0&1\\-1&1&0\\0&-1&-1 \end{bmatrix} \det(S^\prime)=0从而 \det(B_r^x)=\det(S^\prime)\det(B^\prime)=0这样，我们等同于是枚举了选择的边的集合，每次选定一个集合，就判断一下它时候构成的是一棵树，如果是就加上一点贡献。而选择的集合不重复不遗漏，我们就证明了矩阵-树定理。 上面的证明过程还存在一点缺陷，补证 A=\begin{bmatrix} A_{11}&A_{12}\\0&A_{22} \end{bmatrix}那么 \det(A)=\det(A_{11})\det(A_{22})设 A_{11}=\begin{bmatrix} a_{11}&a_{12}&\cdots&a_{1n}\\ a_{21}&a_{22}&\cdots&a_{2n}\\ \vdots&\vdots&\ddots&\vdots\\ a_{n1}&a_{n2}&\cdots&a_{nn} \end{bmatrix}\\ A_{22}=\begin{bmatrix} b_{11}&b_{12}&\cdots&b_{1m}\\ b_{21}&b_{22}&\cdots&b_{2m}\\ \vdots&\vdots&\ddots&\vdots\\ b_{m1}&b_{m2}&\cdots&b_{mm} \end{bmatrix}\\我们将 $A_{11}$ 和 $A_{22}$ 进行变换得到两个上三角矩阵，其中对于 $A_{11}$, 每一次将最右边的一列乘上一个数加到前面的一列，以使得最后一行除了最后一个数其它数全部为 0. 然后去掉最后一行和最后一列不看，继续这样处理。对于 $A_{22}$, 每一次将第一排乘上一个数加到后面的一排，以使得第一列除了最后一个数其它数全部为 0. 这样处理之后， A_{11}=\begin{bmatrix} p_{11}&p_{12}&\cdots&p_{1n}\\ 0&p_{22}&\cdots&p_{2n}\\ \vdots&\vdots&\ddots&\vdots\\ 0&0&\cdots&p_{nn} \end{bmatrix}\\ A_{22}=\begin{bmatrix} q_{11}&q_{12}&\cdots&q_{1m}\\ 0&q_{22}&\cdots&q_{2m}\\ \vdots&\vdots&\ddots&\vdots\\ 0&0&\cdots&q_{mm} \end{bmatrix}\\ \det(A_{11})=\prod_{i=0}^np_{ii} det(A_{22})=\prod_{i=0}^mq_{ii}将这两个矩阵放到原来的 $A$ 中可以发现，我们在按照上述规则进行变换完成后 $A$ 是一个上三角矩阵，那么 \det(A)=\prod_{i=0}^np_{ii}\prod_{i=0}^mq_{i+n\ i+n}=\det(A_{11})\det(A_{22})证毕。 实践为了求出给定Kirchhoff矩阵的一个 $n-1$ 阶主子式 $C_r$，我们通过不断变换使得它成为一个上三角矩阵。准确地说，从上往下处理主对角线上的每一个元素，如果这个元素 $(C_r)_{ii}$ 下面的所有元素都为 0，那么我们就处理完成了一行一列，下面移动到主对角线上的下一个元素 $(C_r)_{i+1\ i+1}$. 假定我们正在处理第 $i$ 行，现在要使得 $(C_r)_{ji}=0$. 如果 $(C_r)_{ii}&gt;(C_r)_{ji}$, 那么将第 $i$ 行减去第 $j$ 行，否则对换两行。这一个过程与欧几里得算法非常相似，可以利用其思想计算出 $t=\left\lfloor\frac{(C_r)_{ii}}{(C_r)_{ji}}\right\rfloor$, 然后一次减去多次来加速运算。每一次归位一行则将答案乘上这一行主对角线上的元素，每一次对换两行将答案变成其相反数。总时间复杂度为 $O(N^3)$.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HEOI2015 小Z的房间]]></title>
    <url>%2F2019%2F03%2F09%2FHEOI2015-%E5%B0%8FZ%E7%9A%84%E6%88%BF%E9%97%B4%2F</url>
    <content type="text"><![CDATA[将数据读入后，可以得到一个由 . 和 * 组成的矩阵，我们将所有的 . 看成是一个结点，给予这些点两两不同的哈希值，将两个具有相邻边的 . 看成一条无限边。之后，所有的结点组成集合 $V$, 所有的边组成集合 $E$, 集合 $G=\{V,\; E\}$. 接下来需要做的，就是直接求出无向图 $G$ 的不同生成树的个数即可。 求解行列式 $\det(G)$ 的Kirchhoff矩阵的时间复杂度是三次方级别的，而如果 $E$ 中包含了原图中所有的结点，那么时间复杂度就是 $O(N^3M^3)$, 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;constexpr long long MOD = 1e9;constexpr auto MAXN = 9+5;constexpr auto MAXM = MAXN;constexpr auto MAXP = MAXM*MAXN+50;bool map[MAXN][MAXM];int A[MAXP][MAXP], D[MAXP][MAXP], cnt[MAXN][MAXM];long long C[MAXP][MAXP];bool ReadChar(void);signed main(void)&#123; int totLine,totList,_cnt=0; scanf("%d%d", &amp;totLine,&amp;totList); for(int i=0;i&lt;=totLine+1;i++) map[i][0] = map[i][totList+1] = false; for(int i=0;i&lt;=totList+1;i++) map[0][i] = map[totLine+1][i] = false; for(int i=1;i&lt;=totLine;i++) for(int j=1;j&lt;=totList;j++)&#123; if((map[i][j]=ReadChar())==false)continue; cnt[i][j] = ++_cnt; if(map[i-1][j]) A[cnt[i-1][j]][cnt[i][j]] = A[cnt[i][j]][cnt[i-1][j]] = 1; if(map[i][j-1]) A[cnt[i][j-1]][cnt[i][j]] = A[cnt[i][j]][cnt[i][j-1]] = 1; &#125; for(int i=1;i&lt;=_cnt;i++)&#123; assert(D[i][i]==0); for(int j=1;j&lt;=_cnt;j++) if(A[i][j]) D[i][i]++; &#125; for(int i=1;i&lt;=_cnt;i++) for(int j=1;j&lt;=_cnt;j++) C[i][j] = (MOD + D[i][j] - A[i][j]) % MOD; //Solve _cnt--; long long ans = 1,t; for(int j=1;j&lt;=_cnt;j++)&#123; for(int i=j+1;i&lt;=_cnt;i++)&#123; //make C[i][j]==0 //Line swap target : Line j while(C[i][j])&#123; t=C[j][j]/C[i][j]; for(int k=j;k&lt;=_cnt;k++)&#123; (((C[j][k]-=t*C[i][k])%=MOD)+=MOD)%=MOD; std::swap(C[j][k], C[i][k]); &#125; ans*=-1; &#125; &#125; (((ans*=C[j][j])%=MOD)+=MOD)%=MOD; &#125; printf("%lld\n", (ans+MOD)%MOD); return 0;&#125;bool ReadChar(void)&#123; char c; do c = getchar(); while(c!='*' &amp;&amp; c!='.'); return c=='.';&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行列式的性质]]></title>
    <url>%2F2019%2F03%2F03%2F%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E6%80%A7%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[一个行列式 $D$ 形如 D=\begin{vmatrix} a_{11}&a_{12}&\cdots&a_{1n}\\ a_{21}&a_{22}&\cdots&a_{2n}\\ \vdots&\vdots&\ddots&\vdots\\ a_{n1}&a_{n2}&\cdots&a_{nn} \end{vmatrix} =\sum(-1)^ta_{1p_1}a_{2p_2}\cdots a_{np_n}在这里 $p_1\cdots p_n$ 是整数 $1\cdots n$ 的一个排列，$t$ 是这个排列的逆序数。 记 D^T=\begin{vmatrix} a_{11}&a_{21}&\cdots&a_{n1}\\ a_{12}&a_{22}&\cdots&a_{n2}\\ \vdots&\vdots&\ddots&\vdots\\ a_{1n}&a_{2n}&\cdots&a_{nn} \end{vmatrix}这里 $D^T$ 称为行列式 $D$ 的转置行列式。 性质一行列式与它的转置行列式相等。 证明： D=\sum(-1)^ta_{1p_1}a_{2p_2}\cdots a_{np_n}\\ D^T=\sum(-1)^ta_{p_11}a_{p_22}\cdots a_{p_nn}考虑 (-1)^ta_{1p_1}\cdots a_{ip_i}\cdots a_{jp_j}\cdots a_{np_n}这里将 $1\cdots i\cdots j\cdots n$ 记为标准排列。对换元素 $i$ 和 $j$ (-1)^ta_{1p_1}\cdots a_{jp_j}\cdots a_{ip_i}\cdots a_{np_n}这时，它的值没有发生变化，假定 $1\cdots j\cdots i\cdots n$ 的逆序数为 $r$, $p_1\cdots p_j\cdots p_i\cdots p_n$ 的逆序数为 $t_1$. 那么 $1|r$, $t$ 与 $t_1$ 奇偶性不同. 那么 (-1)^t=(-1)^{r+t_1}于是 (-1)^ta_{1p_1}\cdots a_{ip_i}\cdots a_{jp_j}\cdots a_{np_n}=(-1)^{r+t_1}a_{1p_1}\cdots a_{jp_j}\cdots a_{ip_i}\cdots a_{np_n}可见，对换乘积中两元素的次序，行标排列和列标排不变列同时作了相应的对换，则行标排列和列标排列的逆序数之和并不改变奇偶性。于是，经过若干次对换，使得列标排列成为标准排列。此时行标排列从标准排列变为某一个新的排列，假定这个排列为 $q_1q_2\cdots q_n$, 其逆序数为 $s$, 那么 (-1)^ta_{1p_1}a_{2p_2}\cdots a_{np_n}=(-1)^sa_{q_11}a_{q_22}\cdots a_{q_nn}如果左边某一项 $a_{ip_i}$ 在行列式中是 $a_{ij}$, 那么它在右边对应着 $a_{q_jj}$, 排列的唯一性确定。 这样，$D$ 中的任意一项都总有且仅有 $D^T$ 中的某一项与其唯一对应并且相等。从而 $D=D^T$. 证毕。 这条性质告诉我们，在行列式中行和列具有同等的地位，行列式中对于行成立的性质对于列也就必然成立，反之亦然。 性质二对换行列式中的两行（列），行列式变号。 主要证明过程与性质一相似。假定 $D_1=\det(b_{ij})$ 是由 $D=\det(a_{ij})$ 对换了 $i,\ j$ 两行得到的。那么 D_1=\sum(-1)^tb_{1p_1}\cdots b_{ip_i}\cdots b_{jp_j}\cdots b_{np_n}=-\sum(-1)^{t_1}a_{1p_1}\cdots a_{ip_j}\cdots a_{jp_i}\cdots a_{np_n}=-D证毕。 以 $r_i$ 表示行列式的第 $i$ 行，以 $c_i$ 表示行列式的第 $i$ 列，对换 $i,\ j$ 两行记作 $r_i\leftrightarrow a_j$. 推论如果行列式中有两行（列）完全相同，那么这个行列式等于零。 证明： 将这两行对换，那么 $D=-D$, $D=0$. 证毕。 性质三行列式中某一行（列）中所有的元素都乘同一个数 $k$, 等于用这个数 $k$ 乘此行列式。 第 $i$ 行（列）乘 $k$, 记作 $r_i\times k$（$c_i\times k$）. 性质四行列式中如果有两行（列）元素成比例，则此行列式等于零。 性质五若 D=\begin{vmatrix} a_{11}&a_{12}&\cdots&a_{1n}\\ \vdots&\vdots&\ddots&\vdots\\ a_{i1}+a_{i1}^\prime&a_{i2}+a_{i2}^\prime&\cdots&a_{in}+a_{in}^\prime\\ \vdots&\vdots&\ddots&\vdots\\ a_{n1}&a_{n2}&\cdots&a_{nn} \end{vmatrix}那么 D=\begin{vmatrix} a_{11}&a_{12}&\cdots&a_{1n}\\ \vdots&\vdots&\ddots&\vdots\\ a_{i1}&a_{i2}&\cdots&a_{in}\\ \vdots&\vdots&\ddots&\vdots\\ a_{n1}&a_{n2}&\cdots&a_{nn} \end{vmatrix}+\begin{vmatrix} a_{11}&a_{12}&\cdots&a_{1n}\\ \vdots&\vdots&\ddots&\vdots\\ a_{i1}^\prime&a_{i2}^\prime&\cdots&a_{in}^\prime\\ \vdots&\vdots&\ddots&\vdots\\ a_{n1}&a_{n2}&\cdots&a_{nn} \end{vmatrix}性质六将行列式中的某一行（列）的所有元素乘同一个数然后加到另一行（列）对应的元素上，行列式不变。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SP1716 GSS3 - Can you answer these queries III]]></title>
    <url>%2F2019%2F02%2F25%2FSP1716-GSS3---Can-you-answer-these-queries-III%2F</url>
    <content type="text"><![CDATA[这道题目的大致意思是，给定一个长度为 $n$ 的序列，第 $i$ 个元素为 $a_i$, 有 $m$ 次操作，其中包含修改操作，将 $a_i$ 更改为特定的值 $v$, 和查询操作，查询 $a_l\cdots a_r$ 的区间最大子段和。你需要对每一个询问操作给出正确的答案。 在一般的最大子段和问题中，我们可以使用动态规划的思想在线性的时间复杂度内解决问题，转移方程为 f(i)=\max\{f(i-1)+a_i,\ a_i\}\\ g(i)=\max\{g(i-1),\ f(i)\}=\max\{g(i-1),\ f(i-1)+a_i,\ a_i\}在本题中，我们需要使用矩阵代替方程的转移，首先定义一下这里的矩阵乘法：对于 $n\times p$ 的矩阵 $A$ 和 $p\times m$ 的矩阵 $B$, 定义乘法运算 $C=AB$ C_{i,j}=\max_{0\leq k\leq p}\{A_{i,k}+B_{k,j}\}这样的矩阵乘法与原先的类似，不满足交换律，但是满足结合律，即 (AB)C=A(BC)然后可以构造出 \begin{bmatrix} a_i&-\infty&a_i\\a_i&0&a_i\\-\infty&-\infty&0 \end{bmatrix}\begin{bmatrix} f(i-1)\\g(i-1)\\0 \end{bmatrix}=\begin{bmatrix} f(i)\\g(i)\\0 \end{bmatrix}记 A_i=\begin{bmatrix} a_i&-\infty&a_i\\a_i&0&a_i\\-\infty&-\infty&0 \end{bmatrix}那么每一个元素都对应了这样一个矩阵，在询问区间 $[l,r]$ 时，直接运算出 A=\prod_{i=l}^rA_i那么答案就是 \max\{A_{10},\ A_{12}\} 对于一个 $n\times p $ 的矩阵每一次乘上 $p\times m$ 的矩阵运算的时间复杂度是 $O(nmp)$, 这么做表面上看好像还比之间的动态规划更劣，但是这个东西是可以用线段树维护的，每一个结点上储存的信息就是它的两个叶子结点储存矩阵的乘积。至于为什么是对的，首先叶子结点保存着 $A_i$ 肯定没有问题，然后在某一层假定左右分别代表的是 $A_l\times\cdots\times A_{mid} $ 和 $A_{mid+1}\times\cdots\times A_r$, 那么直接相乘得到的就是 $(A_l\times\cdots\times A_{mid})\times(A_{mid+1}\times\cdots\times A_r)$, 两个括号内部可能还嵌套了括号，但是既然左右计算都是正确的，这么算也不会出错，然后再利用数学归纳法可知，原命题成立。 这样如果忽略掉矩阵乘法的时间开销，那么每一次操作的时间复杂度为 $O(N\log N)$, 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;constexpr auto inf = INT_MAX &gt;&gt; 1;struct Matrix &#123; int val[3][3]; Matrix() &#123; for (int i = 0; i &lt; 3; i++)for (int j = 0; j &lt; 3; j++)val[i][j] = -inf; &#125; ~Matrix() &#123;&#125; Matrix&amp; operator = (const Matrix&amp; Set) &#123; for (int i = 0; i &lt; 3; i++) for (int j = 0; j &lt; 3; j++) val[i][j] = Set.val[i][j]; return *this; &#125; Matrix operator * (const Matrix&amp; times)const &#123; Matrix ans; for (int i = 0; i &lt; 3; i++) for (int j = 0; j &lt; 3; j++) for (int k = 0; k &lt; 3; k++) ans.val[i][j] = std::max(ans.val[i][j], val[i][k] + times.val[k][j]); return ans; &#125; Matrix&amp; operator *= (const Matrix&amp; times) &#123; return *this = *this*times; &#125; Matrix&amp; Cls(void) &#123; for (int i = 0; i &lt; 3; i++)for (int j = 0; j &lt; 3; j++)val[i][j] = -inf; return *this; &#125; Matrix&amp; Default(void) &#123; val[0][0] = val[1][1] = val[2][2] = 0; return *this; &#125;&#125;;constexpr auto MAXN = 50000 + 500;constexpr auto MAXM = MAXN;namespace SegTr &#123; struct Node &#123; int fr, to; Matrix sum; Node *lft, *rgt; Node() :lft(nullptr), rgt(nullptr) &#123;&#125; ~Node() &#123;&#125; Node&amp; Update(void) &#123; if (lft != nullptr) &#123; assert(rgt != nullptr); sum = lft-&gt;sum*rgt-&gt;sum; &#125;return *this; &#125; &#125;*root = nullptr; void Build(const int &amp;siz, int *val) &#123; Node *a, *b, *t; std::queue&lt;Node*&gt; que, add; Matrix og; og.val[1][1] = og.val[2][2] = 0; og.val[0][1] = og.val[2][0] = og.val[2][1] = -inf; for (int i = 0; i &lt; siz; i++) &#123; t = new Node(); t-&gt;fr = t-&gt;to = i + 1; og.val[0][0] = og.val[1][0] = og.val[0][2] = og.val[1][2] = val[i]; t-&gt;sum = og; que.push(t); &#125; for (; que.size() &gt;= 2; std::swap(que, add)) &#123; while (que.size() &gt;= 2) &#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = new Node(); t-&gt;fr = a-&gt;fr; t-&gt;to = b-&gt;to; t-&gt;sum = a-&gt;sum*b-&gt;sum; t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if (!que.empty()) &#123; add.push(que.front()); que.pop(); &#125; &#125;root = que.front(); &#125; void Set(const int &amp;pos, const int &amp;val, Node* nowAt = root) &#123; assert(nowAt != nullptr); if (nowAt-&gt;to &lt; pos || pos &lt; nowAt-&gt;fr)return; if (nowAt-&gt;fr == pos &amp;&amp; nowAt-&gt;to == pos) nowAt-&gt;sum.val[0][0] = nowAt-&gt;sum.val[1][0] = nowAt-&gt;sum.val[0][2] = nowAt-&gt;sum.val[1][2] = val; else &#123; Set(pos, val, nowAt-&gt;lft); Set(pos, val, nowAt-&gt;rgt); nowAt-&gt;Update(); &#125; &#125; void Query(const int &amp;fr, const int &amp;to, Matrix&amp; ans, Node* nowAt = root) &#123; assert(nowAt != nullptr); if (nowAt-&gt;to&lt;fr || nowAt-&gt;fr&gt;to)return; if (fr &lt;= nowAt-&gt;fr&amp;&amp;nowAt-&gt;to &lt;= to) ans *= nowAt-&gt;sum; else &#123; Query(fr, to, ans, nowAt-&gt;lft); Query(fr, to, ans, nowAt-&gt;rgt); &#125; &#125;&#125;using namespace SegTr;int valOrig[MAXN];signed main(void) &#123; int totNums, totOptn, opt, pos, val, fr, to; Matrix ans; scanf("%d", &amp;totNums); for (int i = 0; i &lt; totNums; i++) scanf("%d", valOrig + i); Build(totNums, valOrig); scanf("%d", &amp;totOptn); while (totOptn--) &#123; scanf("%d", &amp;opt); switch (opt) &#123; case 0: scanf("%d%d", &amp;pos, &amp;val); Set(pos, val); break; case 1: scanf("%d%d", &amp;fr, &amp;to); ans.Cls().Default(); Query(fr, to, ans); printf("%d\n", std::max(ans.val[1][0],ans.val[1][2])); break; default: puts("UKE"); assert(false); break; &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>矩阵</tag>
        <tag>线段树</tag>
        <tag>动态动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SCOI2007 排列]]></title>
    <url>%2F2019%2F02%2F23%2FSCOI2007-%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[这道题目可以使用动态规划解决。 定义 $f(S,u)$ 为一个状态，其中 $S$ 是一个集合，代表已经选择了哪些数字，$u$ 是一个非负整数，这样一个状态的含义是选择 $S$ 这些数字，有多少种排列模 $t$ 余数为 $u$. 状态转移方程如下: f(S|(1]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>动态规划</tag>
        <tag>状态压缩动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】UVA1487 Volume]]></title>
    <url>%2F2019%2F02%2F14%2FUVA1487-Volume%2F</url>
    <content type="text"><![CDATA[这是一道非常简单的几何题，可以通过手推公式，利用微积分的思想解决。 大致意思是有两个全等正交圆柱体半径为 $r$, 高为 $h$, 求总体积。 首先，两个圆柱体的总体积是 $2r^2\pi h$, 然后需要减去中间重合的那一部分。 可以发现，如果我们用一个平面去切这个东西，得到的是一个个正方形。 同时，这个东西是非常对称的。 我们可以将其分为两两全等的八块 只用计算出这么一个东西的体积，然后乘上8, 就是中间重合部分的体积。 这个东西严格来说是一个牟合方盖，其体积可以用一个双重积分表示为 \iint z\,\mathrm{d}y\;\mathrm{d}x它在 $zOy$ 这个平面上的横截面是一个正方形，边长为 $\sqrt{r^2-y^2}$. 在这里 \iint z\,\mathrm{d}y\;\mathrm{d}x=\int_0^r\left[\int_0^\sqrt{r^2-x^2}\sqrt{r^2-x^2}\,\mathrm{d}x\right]\mathrm{d}y=\int_0^r\left(r^2-x^2\right)\,\mathrm{d}y=\frac23r^3也就是说，中间那一部分的体积 $V=8\times\frac23r^3$. 总体积为 V_\mbox{总}=2r^2\pi h-\frac{16}3r^3这个式子看上去完美，但是这是对于 $2r\leq h$ 时的，如果不是这样，中间重合的部分就不能构成原先那样的一个形状 看上去它的四周都被削平了，中间现在是一个立方体，长和高都是 $\frac h2$, 宽 $l=\sqrt{r^2-\left(\frac h2\right)^2}$. 除此之外，其余的部分没有变化，我们只用将之前的式子稍微修改一下 \int_l^r(r^2-x^2)\mathrm{d}y算出来 \frac18V=\int_l^r(r^2-x^2)\mathrm{d}y+V_\mbox{长}=\frac23r^3+\frac13l^3-r^2l+\frac{h^2}4\sqrt{r^2-\left(\frac h2\right)^2}首先判定一下是哪一种情况，然后按照公式计算就可以了。 代码如下: 123456789101112131415161718#include&lt;cstdio&gt;#include&lt;cmath&gt;signed main(void)&#123; const auto Pi = (double)acos(-1.0); double h, r, l, sum; while (scanf("%lf%lf", &amp;r, &amp;h) == 2) &#123; sum = r * r*h*Pi*2; if (h &lt; 2 * r) &#123; l = sqrt(r*r-h*h / 4); printf("%.4lf\n", sum - 8 * (r*r*r * 2.0 / 3.0 + l * l*l / 3.0 - r * r*l + l * h*h / 4.0)); &#125; else printf("%.4lf\n", sum - 16.0/3.0 * r*r*r); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CTSC1999 家园]]></title>
    <url>%2F2019%2F02%2F11%2FCTSC1999-%E5%AE%B6%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[这道题目有一点分层图网络流的意思。 首先我们还是建立源点 $s$, 汇点就是月球。然后连接 $s$ 和地球，容量为总人数。 随后，我们枚举需要的时间 $t$, 不断地用 Dinic 算法在残量网络上跑最大流，如果某一个时刻最大流达到了总人数，那么当前的这个 $t$ 就是答案。 在每一次增加 $t$ 的时候，我们需要对产量网络进行一定的调整。对地球和每一个太空站每过一个正点时刻就新建一个结点，假定编号为 $i$ 的太空站在第 $t_0$ 时刻的结点编号为 $T_{i,t_0}$. 同时假设第 $i$ 艘太空船这一个时刻从 $s_{i,t-1}$ 到达 $v_{i,t}$. 那么 连接 $T_{i,t_0-1}$ 和 $T_{i,t_0}$, 容量为 $\infty$. 代表上一个时刻在 $i$ 的人可以在那里等待。 连接 $s_{i,t-1}$ 和 $v_{i,t}$, 容量为太空船的容量。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;constexpr auto MAXM = 20 + 30;constexpr auto MAXN = 13 + 12;constexpr auto MAXT = 1000;struct Edge &#123; int fr, to, residual; Edge() &#123;&#125; Edge(const int &amp;ifr, const int &amp;ito, const int &amp;ire) : fr(ifr), to(ito), residual(ire) &#123;&#125;&#125;;std::vector&lt;Edge&gt; edges; std::vector&lt;int&gt; G[MAXT];void AddEdge(const int &amp;fr, const int &amp;to, const int &amp;re) &#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr, to, re)); G[to].push_back(edges.size()); edges.push_back(Edge(to, fr, 0));&#125;int s = MAXT - 2, t = MAXT - 1, maxFlow;int dis[MAXT], cur[MAXT];bool BFS(void) &#123; bool vis[MAXT]; memset(vis, false, sizeof(vis)); vis[s] = true; std::queue&lt;int&gt; que; que.push(s); dis[s] = 0; int nowAt; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); for (int i = 0; i &lt; G[nowAt].size(); i++) &#123; const auto &amp;it = edges[G[nowAt][i]]; if (it.residual &gt; 0 &amp;&amp; !vis[it.to]) &#123; vis[it.to] = true; dis[it.to] = dis[nowAt] + 1; que.push(it.to); &#125; &#125; &#125; return vis[t];&#125;int Dfs(const int &amp;nowAt, int maxFlow) &#123; if (nowAt == t || maxFlow &lt;= 0)return maxFlow; int flow = 0, deltaFlow; for (int &amp;i = cur[nowAt]; i &lt; G[nowAt].size(); i++) &#123; auto &amp;it = edges[G[nowAt][i]]; if (dis[nowAt] + 1 == dis[it.to] &amp;&amp; 0 &lt; (deltaFlow = Dfs(it.to, std::min(maxFlow, it.residual)))) &#123; flow += deltaFlow; maxFlow -= deltaFlow; it.residual -= deltaFlow; edges[G[nowAt][i] ^ 1].residual += deltaFlow; if (maxFlow &lt;= 0)break; &#125; &#125; return flow;&#125;void Dinic(void) &#123; while (BFS()) &#123; memset(cur, 0, sizeof(cur)); maxFlow += Dfs(s, INT_MAX); &#125;&#125;int array_[MAXN], *up = array_ + 1;int FindTop(const int &amp;nowAt) &#123; return up[nowAt] == nowAt ? nowAt : (up[nowAt] = FindTop(up[nowAt])); &#125;void Unity(const int &amp;a, const int &amp;b) &#123; up[FindTop(a)] = FindTop(b); &#125;std::vector&lt;int&gt; btStop[MAXM], statID[MAXN];int resi[MAXM], node_clock;signed main(void) &#123; for (int i = -1; i + 1 &lt; MAXN; i++)up[i] = i; int totStat, totBoat, totPeo, b, a, totBlk; scanf("%d%d%d", &amp;totStat, &amp;totBoat, &amp;totPeo); totBlk = totStat + 2; for (int i = 0; i &lt; totBoat; i++) &#123; scanf("%d%d", resi + i, &amp;b); while (b--) &#123; scanf("%d", &amp;a); btStop[i].push_back(a); &#125; for(int j=1;j&lt;btStop[i].size();j++) if (FindTop(btStop[i][j]) != FindTop(btStop[i][j - 1])) &#123; --totBlk; Unity(btStop[i][j], btStop[i][j - 1]); &#125; &#125;assert(totBlk &gt;= 1); if (FindTop(0) != FindTop(-1)) &#123; puts("0"); return 0; &#125; //预处理 for (int i = 0; i &lt;= totStat; i++)statID[i].push_back(node_clock++); AddEdge(s, statID[0][0], totPeo); int totTime, fr, to; for (totTime = 1; maxFlow &lt; totPeo; totTime++) &#123; for (int i = 0; i &lt;= totStat; i++) &#123; statID[i].push_back(node_clock++); AddEdge(statID[i][totTime - 1], statID[i][totTime], INT_MAX); &#125; for (int i = 0; i &lt; totBoat; i++) &#123;//i 代表当前船 fr = btStop[i][(totTime - 1) % btStop[i].size()] == -1 ? t : statID[btStop[i][(totTime - 1) % btStop[i].size()]][totTime - 1]; to = btStop[i][totTime%btStop[i].size()] == -1 ? t : statID[btStop[i][totTime%btStop[i].size()]][totTime]; AddEdge(fr, to, resi[i]); &#125; Dinic(); &#125; printf("%d\n", totTime - 1); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】方格取数加强版]]></title>
    <url>%2F2019%2F02%2F11%2F%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E5%8A%A0%E5%BC%BA%E7%89%88%2F</url>
    <content type="text"><![CDATA[题目在这里.（LG) 考虑费用流的过程，我们先是使用 SPFA 求出一条费用最小的路径，然后进行扩展，这道题目也可以转换为这样的一个问题，假定第一次到达每一个格子可得到相应的费用，然后在上面运行 $k$ 次最大费用最大流即可。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 50 + 5;constexpr auto MAXT = (MAXN*MAXN &lt;&lt; 1) + 30;constexpr auto MAXK = 10 + 5;struct Edge &#123; int fr, to, residual, cost; Edge() &#123;&#125; Edge(const int &amp;ifr, const int &amp;ito, const int &amp;ire, const int &amp;ico) :fr(ifr), to(ito), residual(ire), cost(ico) &#123;&#125;&#125;;std::vector&lt;Edge&gt;edges; std::vector&lt;int&gt;G[MAXT];void AddEdge(const int &amp;fr, const int &amp;to, const int &amp;re, const int &amp;cost) &#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr, to, re, cost)); G[to].push_back(edges.size()); edges.push_back(Edge(to, fr, 0, -cost));&#125;int s = MAXT - 2, t = MAXT - 1, maxFlow, minCost;int flow[MAXT], cost[MAXT], last[MAXT]; bool inQueue[MAXT];bool SPFA(void) &#123; memset(inQueue, false, sizeof(inQueue)); std::fill(cost, cost + MAXT, 1e9); std::queue&lt;int&gt; que; que.push(s); cost[s] = 0; flow[s] = INT_MAX; inQueue[s] = true; int nowAt; while (!que.empty()) &#123; inQueue[nowAt = que.front()] = false; que.pop(); for (int i = 0; i &lt; G[nowAt].size(); i++) &#123; const auto &amp;it = edges[G[nowAt][i]]; if (it.residual &gt; 0 &amp;&amp; cost[it.to] &gt; cost[nowAt] + it.cost) &#123; cost[it.to] = cost[nowAt] + it.cost; flow[it.to] = std::min(flow[nowAt], it.residual); last[it.to] = G[nowAt][i]; if (!inQueue[it.to]) &#123; inQueue[it.to] = true; que.push(it.to); &#125; &#125; &#125; &#125; if (cost[t] == INT_MAX)return false; maxFlow += flow[t]; minCost += flow[t] * cost[t]; for (nowAt = t; nowAt != s; nowAt = edges[last[nowAt]].fr) &#123; edges[last[nowAt]].residual -= flow[t]; edges[last[nowAt] ^ 1].residual += flow[t]; &#125; return true;&#125;std::pair&lt;int,int&gt; MCMF(const int &amp;totTimes) &#123; maxFlow = minCost = 0; for (int i = 0; i &lt; totTimes; i++) if (!SPFA())break; return std::make_pair(maxFlow, minCost);&#125;#define ToHash(x,y) (((MAXN*(y))&lt;&lt;1)+((x)&lt;&lt;1))signed main(void)&#123; int siz, k, a; scanf("%d%d", &amp;siz, &amp;k); for (int y = 0; y &lt; siz; y++) for (int x = 0; x &lt; siz; x++) &#123; scanf("%d", &amp;a); AddEdge(ToHash(x, y), ToHash(x, y) | 1, 1, -a); AddEdge(ToHash(x, y), ToHash(x, y) | 1, INT_MAX, 0); AddEdge(ToHash(x, y) | 1, ToHash(x + 1, y), INT_MAX, 0); AddEdge(ToHash(x, y) | 1, ToHash(x, y + 1), INT_MAX, 0); &#125; AddEdge(s, ToHash(0, 0), INT_MAX, 0); AddEdge(ToHash(siz - 1, siz - 1) | 1, t, INT_MAX, 0); printf("%d\n", -MCMF(k).second); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】方格取数问题]]></title>
    <url>%2F2019%2F02%2F10%2F%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目在这里.（LG) 这道题目可以转化成为一个最大权闭合子图问题。如果对整张图进行黑白染色，规定位于 $(x,y)$ 的格子是黑色当 $1|(x+y)$. 然后，如果选择了一个黑色的格子，那么位于它周围的白色格子就不能够被选。先假定能够得到所有格子上的收益，然后减去最小割，就是答案。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 100 + 50;constexpr auto MAXM = MAXN;constexpr auto MAXT = MAXN * MAXM + 20;#define Black (0)#define White (1)#define Color(x,y) (((x)+(y))&amp;1)#define ToHash(x,y) (((y)*MAXM)+(x))struct Edge &#123; int fr, to;long long residual; Edge() &#123;&#125; Edge(const int &amp;ifr, const int &amp;ito, const long long &amp;ire) : fr(ifr), to(ito), residual(ire) &#123;&#125;&#125;;std::vector&lt;Edge&gt;edges;std::vector&lt;int&gt; G[MAXT];void AddEdge(const int &amp;fr, const int &amp;to, const long long &amp;res) &#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr, to, res)); G[to].push_back(edges.size()); edges.push_back(Edge(to, fr, 0));&#125;int s = MAXT - 2, t = MAXT - 1;int dis[MAXT], cur[MAXT];bool BFS(void) &#123; bool vis[MAXT]; memset(vis, false, sizeof(vis)); vis[s] = true; std::queue&lt;int&gt; que; que.push(s); dis[s] = 0; int nowAt; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); for (int i = 0; i &lt; G[nowAt].size(); i++) &#123; const auto &amp;it = edges[G[nowAt][i]]; if (!vis[it.to] &amp;&amp; it.residual &gt; 0) &#123; vis[it.to] = true; dis[it.to] = dis[nowAt] + 1; que.push(it.to); &#125; &#125; &#125;return vis[t];&#125;long long Dfs(const int &amp;nowAt, long long maxFlow) &#123; if (nowAt == t || maxFlow &lt;= 0)return maxFlow; long long flow = 0, deltaFlow; for (int&amp; i = cur[nowAt]; i &lt; G[nowAt].size(); i++) &#123; auto &amp;it = edges[G[nowAt][i]]; if (dis[nowAt] + 1 == dis[it.to] &amp;&amp; 0 &lt; (deltaFlow = Dfs(it.to, std::min(maxFlow, it.residual)))) &#123; flow += deltaFlow; maxFlow -= deltaFlow; it.residual -= deltaFlow; edges[G[nowAt][i] ^ 1].residual += deltaFlow; if (maxFlow &lt;= 0)break; &#125; &#125; return flow;&#125;long long Dinic(void) &#123; long long flow = 0; while (BFS()) &#123; memset(cur, 0, sizeof(cur)); flow += Dfs(s, INT64_MAX); &#125; return flow;&#125;signed main(void)&#123; int sizx, sizy, xx, yy; long long a, S = 0; scanf("%d%d", &amp;sizy, &amp;sizx); for (int y = 0; y &lt; sizy; y++) for (int x = 0; x &lt; sizx; x++) &#123; scanf("%lld", &amp;a); S += a; if (Color(x, y) == Black) &#123; AddEdge(s, ToHash(x, y), a); for (int dy = -1; dy &lt;= 1; dy += 2) &#123; xx = x; yy = y + dy; if (0 &lt;= xx &amp;&amp; 0 &lt;= yy &amp;&amp; xx &lt; sizx&amp;&amp;yy &lt; sizy) AddEdge(ToHash(x, y), ToHash(xx, yy), INT64_MAX); &#125; for (int dx = -1; dx &lt;= 1; dx += 2) &#123; xx = x + dx; yy = y; if (0 &lt;= xx &amp;&amp; 0 &lt;= yy &amp;&amp; xx &lt; sizx&amp;&amp;yy &lt; sizy) AddEdge(ToHash(x, y), ToHash(xx, yy), INT64_MAX); &#125; &#125; else AddEdge(ToHash(x, y), t, a); &#125; printf("%lld\n", S - Dinic()); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】NOI2006 最大获利]]></title>
    <url>%2F2019%2F02%2F09%2FNOI2006-%E6%9C%80%E5%A4%A7%E8%8E%B7%E5%88%A9%2F</url>
    <content type="text"><![CDATA[这是一道最大权闭合图模板题，按照下列规则建模： 建立源点 $s$ 和汇点 $t$. 将 $s$ 与所有的客户连边，容量为这个客户的收益。 将所有的中转站与 $t$ 连边，容量为建造费用。 将所有客户与他们对应的两个中转站连边，费用为 $\infty$. 在这个图上求出最小割 $S$, 这个数值等于最佳方案下舍弃的客户收益与总建造费用的和。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define Attend push_backconstexpr auto MAXN = 5000+50;constexpr auto MAXM = 50000+50;constexpr auto MAXT = MAXN + MAXM + 100;struct Edge&#123; int fr,to,residual; Edge()&#123;&#125; Edge(const int &amp;ifr,const int &amp;ito,const int &amp;ires) : fr(ifr),to(ito),residual(ires) &#123;&#125;&#125;;std::vector&lt;Edge&gt; edges;std::vector&lt;int&gt; G[MAXT];void AddEdge(const int &amp;fr,const int &amp;to,const int &amp;val)&#123; G[fr].Attend(edges.size()); edges.Attend(Edge(fr,to,val)); G[to].Attend(edges.size()); edges.Attend(Edge(to,fr,0));&#125;//Dinic int s,t;int dis[MAXT],cur[MAXT];bool vis[MAXT];bool BFS(void)&#123; std::queue&lt;int&gt; que; que.push(s); dis[s] = 0; memset(vis,false,sizeof(vis)); vis[s] = true; int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(int i=0;i&lt;G[nowAt].size();i++)&#123; const auto &amp;it = edges[G[nowAt][i]]; if(!vis[it.to] &amp;&amp; it.residual&gt;0)&#123; vis[it.to] = true; dis[it.to] = dis[nowAt]+1; que.push(it.to); &#125; &#125; &#125; return vis[t];&#125;int Dfs(const int &amp;nowAt, int maxFlow)&#123; if(nowAt==t || maxFlow&lt;=0) return maxFlow; int flow=0,deltaFlow; for(int &amp;i=cur[nowAt];i&lt;G[nowAt].size();i++)&#123; auto &amp;it = edges[G[nowAt][i]]; if(dis[nowAt]+1==dis[it.to] &amp;&amp; 0&lt;(deltaFlow=Dfs(it.to,std::min(maxFlow,it.residual))))&#123; flow+=deltaFlow; maxFlow-=deltaFlow; it.residual-=deltaFlow; edges[G[nowAt][i]^1].residual+=deltaFlow; if(maxFlow&lt;=0)break; &#125; &#125; return flow;&#125;int Dinic(void)&#123; int flow=0; while(BFS())&#123; memset(cur,0,sizeof(cur)); flow+=Dfs(s,INT_MAX); &#125; return flow;&#125;//--------------------------------------signed main(void)&#123; int totN,totM,a,b,S=0,cost; s=0;t=MAXT-1; scanf("%d%d", &amp;totN,&amp;totM); for(int i=1;i&lt;=totN;i++)&#123; scanf("%d", &amp;cost); AddEdge(s,i+totM,cost); &#125; for(int i=1;i&lt;=totM;i++)&#123; scanf("%d%d%d", &amp;a,&amp;b,&amp;cost); S+=cost; AddEdge(i,t,cost); AddEdge(a+totM,i,INT_MAX); AddEdge(b+totM,i,INT_MAX); &#125; printf("%d\n", S-Dinic()); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大权闭合子图]]></title>
    <url>%2F2019%2F02%2F09%2F%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最大权闭合子图是一类问题，可以抽象地描述为一个点带有点权的有向图 $G=(V,E)$ 中选择一个点权最大的子图，必须满足所有选择的点在原图中可以抵达的所有点都必须包含在这个子图中。 这类问题可以通过建模转换为一个网络流问题： 建立源点 $s$ 和汇点 $t$. 将 $s$ 与所有点权为正的点连边，容量为点权。 将所有点权为负的点与 $t$ 连边，容量为点权的相反数。 添加 $E$ 中所有边，容量为 $\infty$. 所有点权为正的点的点权之和减去这个网络流图的最小割，即为最大权闭合子图的点权之和。 这样建模在求解最小割的时候满足一些特殊的性质。首先，$E$ 中的边容量都是 $\infty$ ,不可能被割掉，有可能在最小割集中的边一定是 2 或者 3 类边。如果割掉了一个 2 类边，那么代表放弃这个点获得的点权，不将其加入闭合子图中；如果割掉了一个 3 类边，那么代表将这个点权为负的点加入到闭合子图中。这么做最终得到的闭合子图就是最大权闭合子图。 为什么这么做是对的？首先这样的方案肯定是成立的，残量网络中 $s$ 和 $t$ 已经不再联通，而对于每一个点权为正的结点，它要么没有被选，要么可达的所有点一起被选。而这样的方案又是最优的，因为只有当 $s$ 和 $t$ 不再联通时才满足题意，不然一定可以从 $s$ 出发，找到一个选中了的正权点，沿着 $E$ 中的路径到达一个没有被选的负权点流入 $t$. 一个网络流图的最小割就是它的最大流，因此求出了模型的最大流，就解决了这个问题。如果需要求出方案，那么就是添加所有仍有残量的 2 类路径链接的正权点和它们能够到达的所有负权点。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CQOI2011 动态逆序对]]></title>
    <url>%2F2019%2F02%2F08%2FCQOI2011-%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[大致意思是给定 $n$ 个整数的一个全排列，然后会按照一定的顺序删除 $m$ 个数，求每一次删除之前的逆序对个数。 LG题目地址 可以发现，删除的过程中逆序对是只减不增的，我们可以求出每一个数对逆序对的贡献 $\omega_x​$，然后删除掉它就是减掉这个贡献就可以了。 定义一个数对逆序对个数的贡献是位置在它前面且值大于它的数的个数 $f(i)$ 加上位置在它后面且值小于它的数的个数 $g(i)$. 即 $\omega_x=f(x)+g(x)$. 由于满足上述条件的数很有可能在此之前就已经被删除了，所以我们可以用一个三元组 $(t,p,v)$ 来描述这些数。其中 $t$ 代表删除时间，$p$ 代表位置，$v$ 代表值。那么 f(i)=\sum_{j\not=i}[t_j>t_i][p_jv_i]\\ g(i)=\sum_{j\not=i}[t_j>t_i][p_j>p_j][v_j]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】ZJOI2013 K大数查询]]></title>
    <url>%2F2019%2F02%2F08%2FZJOI2013-K%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[这道题目大致意思是给定 $n$ 个空序列，其中第 $i$ 个为 $a_i$，有两种操作共 $m$ 个： 将一个区间 $[l,r]$ 内的所有序列后面加入一个整数 $c$. 查询一个区间 $[l,r]$ 中所有数中第 $C$ 大的是什么。 现在需要回答所有的 2 询问。不强制在线。 由于不用在线，所以考虑整体二分做法。当我们的询问区间是 $[qf,qt]$, 答案区间是 $[af,at]$ 时，记 $am=\frac{af+at}2$. 然后我们考虑一个查询操作前面所有在询问区间内且 $c&gt;am$ 的询问，如果这个询问的答案在区间 $[am+1,at]$ 中，那么意味着这些询问在查询区间内加入的数的个数大于 $C$. 判断这些数的个数是否大于 $C$, 也就是判断给定 $m_0$ 个区间，将这些区间内所有的数全部加 1. 然后查询一个区间内所有数的总和。在这道题目中，$m_0$ 个区间内的数就是序列中包含的元素个数，全部加 1 就相当于全部加入了一个 $c&gt;am$ 的数。这样一个操作可以用线段树在单次操作 $\log N$ 的时间复杂度内维护。 这样，考虑上整体二分，总时间复杂度就是 $O(M\log M\log N)$, 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 50000 + 50;constexpr auto MAXM = MAXN;namespace SegTr &#123; struct Node &#123; int fr, to; long long mark, sum; Node *lft, *rgt; Node() : lft(nullptr), rgt(nullptr), sum(0), mark(0) &#123;&#125; Node&amp; Mark(const long long &amp;delta) &#123; mark += delta; sum += (to - fr + 1)*delta; return *this; &#125; Node&amp; Push_Down(void) &#123; if (lft != nullptr &amp;&amp; mark) &#123; assert(rgt != nullptr); lft-&gt;Mark(mark); rgt-&gt;Mark(mark); mark = 0; &#125; return *this; &#125; Node&amp; Update(void)&#123; if (fr != to)sum = 0; if (lft != nullptr) &#123; assert(rgt != nullptr); sum = lft-&gt;sum + rgt-&gt;sum; &#125; return *this; &#125; &#125;*root = nullptr; void Build(const int &amp;siz) &#123; Node *a, *b, *t; std::queue&lt;Node*&gt; que, add; for (int i = 1; i &lt;= siz; i++) &#123; t = new Node(); t-&gt;fr = t-&gt;to = i; que.push(t); &#125; for (; que.size() &gt;= 2; std::swap(add, que)) &#123; while (que.size() &gt;= 2) &#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = new Node(); t-&gt;fr = a-&gt;fr; t-&gt;to = b-&gt;to; t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if (!que.empty()) &#123; add.push(que.front()); que.pop(); &#125; &#125; root = que.front(); &#125; void Add(const int &amp;fr, const int &amp;to, const long long &amp;val, Node* nowAt) &#123; if (nowAt == nullptr) return; if (to &lt; nowAt-&gt;fr || nowAt-&gt;to &lt; fr) return; nowAt-&gt;Push_Down(); if (fr &lt;= nowAt-&gt;fr &amp;&amp; nowAt-&gt;to &lt;= to) &#123; nowAt-&gt;Mark(val); return; &#125; else &#123; Add(fr, to, val, nowAt-&gt;lft); Add(fr, to, val, nowAt-&gt;rgt); nowAt-&gt;Update(); &#125; &#125; long long Query(const int &amp;fr, const int &amp;to, Node* nowAt) &#123; if (nowAt == nullptr) return 0; if (to &lt; nowAt-&gt;fr || nowAt-&gt;to &lt; fr) return 0; nowAt-&gt;Push_Down(); if (fr &lt;= nowAt-&gt;fr &amp;&amp; nowAt-&gt;to &lt;= to) &#123; return nowAt-&gt;sum; &#125; else return Query(fr, to, nowAt-&gt;lft) + Query(fr, to, nowAt-&gt;rgt); &#125; void Add(const int &amp;fr, const int &amp;to, const long long &amp;val) &#123; Add(fr, to, val, root); &#125; long long Query(const int &amp;fr, const int &amp;to) &#123; return Query(fr, to, root); &#125;&#125;;struct Query &#123; int fr, to, opt, ID; long long val;//opt=1是一个修改操作 Query() &#123;&#125; Query(const int &amp;iopt, const int &amp;ifr, const int &amp;ito, const long long &amp;ival) : fr(ifr), to(ito), val(ival), opt(iopt) &#123;&#125;&#125;que[MAXN], q1[MAXN], q2[MAXN];int totNums, totMi;long long ans[MAXN];void Solve(const int &amp;qfr, const int &amp;qto, const long long &amp;ans_fr, const long long &amp;ans_to) &#123; if (qfr &gt; qto || ans_fr &gt; ans_to) return; if (ans_fr == ans_to) &#123; for (int i = qfr; i &lt;= qto; i++) if (que[i].opt == 2) ans[que[i].ID] = ans_fr; return; &#125; long long ans_mid = ans_fr + (ans_to - ans_fr &gt;&gt; 1), temp; Query *s1 = q1, *s2 = q2; bool fl = false, fr = false; for (int i = qfr; i &lt;= qto; i++) switch (que[i].opt) &#123; case 1://修改操作 if (que[i].val &gt; ans_mid) &#123; *s2++ = que[i]; SegTr::Add(que[i].fr, que[i].to, 1); &#125; else *s1++ = que[i]; break; case 2://查询 temp = SegTr::Query(que[i].fr, que[i].to); if (temp &lt; que[i].val) &#123; que[i].val -= temp; fl = true; *s1++ = que[i]; &#125; else &#123; fr = true; *s2++ = que[i]; &#125; break; default: puts("UKE"); assert(false); break; &#125; //清空线段树 for (int i = qfr; i &lt;= qto; i++) if (que[i].opt == 1 &amp;&amp; que[i].val &gt; ans_mid) SegTr::Add(que[i].fr, que[i].to, -1); //复制 for (Query *i = q1; i &lt; s1; i++) que[qfr + i - q1] = *i; for (Query *i = q2; i &lt; s2; i++) que[qfr + i - q2 + s1 - q1] = *i; //递归分治 if (fl) Solve(qfr, qfr + s1 - q1 - 1, ans_fr, ans_mid); if (fr) Solve(qfr + s1 - q1, qto, ans_mid + 1, ans_to);&#125;signed main()&#123; freopen("in.in", "r", stdin); freopen("out.out", "w", stdout); int opt, a, b, Q = 0; long long min = INT64_MAX, max = INT64_MIN, c; scanf("%d%d", &amp;totNums, &amp;totMi); for (int i = 0; i &lt; totMi; i++) &#123; scanf("%d%d%d%lld", &amp;opt, &amp;a, &amp;b, &amp;c); que[i] = Query(opt, a, b, c); if (opt == 1) &#123; min = std::min(min, c); max = std::max(max, c); &#125; else que[i].ID = Q++; &#125; SegTr::Build(totNums); Solve(0, totMi - 1, min, max); //Output for (int i = 0; i &lt; Q; i++) printf("%lld\n", ans[i]); //system("pause"); return 0;&#125;]]></content>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分与分治策略]]></title>
    <url>%2F2019%2F02%2F08%2F%E4%BA%8C%E5%88%86%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[分治是一种策略，将一个问题划分成为形式相似，规模减半的两个问题进行求解，然后合并答案或者得到的信息从而解决问题。 归并排序归并排序（英文：Merge Sort）每一次将排序区间 $[l,r]$ 划分为 $[l,m]$ 和 $[m,r]$, 其中 $m=\frac{l+r}2$. 将这两个区间进行排序后合并两个有序的区间，从而完成 $[l,r]$ 区间的排序，接口如下： 12345678910111213141516template&lt;typename T&gt;void MergeSort(T* a, T* b) &#123; if (a &lt; b - 1) &#123; T* mid = a + (b - a &gt;&gt; 1); MergeSort(a, mid); MergeSort(mid, b); //分治 //合并 T *temp = new T[b - a], *l = a, *r = mid; for (size_t i = 0; i &lt; b - a; i++) temp[i] = r &gt;= b || (l &lt; mid&amp;&amp;*l &lt; *r) ? *l++ : *r++; //回写 for (size_t i = 0; i &lt; b - a; i++)a[i] = temp[i]; delete[] temp; &#125;&#125; CDQ分治CDQ分治是一种基于时域的分治策略，可以用于解决一些统计/计数类问题。 CDQ分治的主过程在很大程度上与归并排序非常类似，它可以解决的问题通常是在高维情况下统计带有多个维度限制的统计，简单情况下是 $n$ 维偏序问题。即对于一个 $n$ 元组 $(a_1,a_2,a_3,\cdots,a_n)$ 组成的数组 $A$, 统计对于一个元素 $i$ 的 \sum_{j\not=i} [a_{1_j}]]></content>
      <tags>
        <tag>CDQ分治</tag>
        <tag>整体二分</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】POI2011 MET-Meteors]]></title>
    <url>%2F2019%2F02%2F07%2FPOI2011-MET-Meteors%2F</url>
    <content type="text"><![CDATA[大致题意是 Byteotian Interstellar Union 有 $n$ 个成员国，总共有 $m$ 个空间站围成一个圈，每一个空间站属于一个国家，现在有 $K$ 场陨石雨，其中第 $i$ 场会给区间 $[l_i,r_r]$ 带来 $a_i$ 点陨石。同时每一个国家有一个收集计划，第 $i$ 个国家希望收集 $i$ 点陨石。现在询问对于每一个国家，它最早在什么时候可以完成自己的收集计划。 首先我们将事件分为两类。一种是执行区间修改操作，将区间 $[l_i,r_i]$ 整体加上 $a_i$, 如果 $l_i&gt;r_i$, 则拆分为两个区间：$[1,l_i],\,[r_1,m]$. 另外就是查询，查询一个指定的国家 $w_i$ 在考虑之前的陨石雨的情况下最早何时完成收集计划。 我们将环看成一条链，一开始上面的数全部是 0，然后依次执行修改操作，最后统一地进行查询。由于这道题目没有要求强制在线，所以可以先将所有的操作离线下来，然后用整体二分加上树状数组查询解决掉。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;#define lowbit(x) ((x)&amp;(-(x)))constexpr auto MAXN = (int)1e6 + 55;constexpr auto MAXM = MAXN + 50;//BITlong long arr[MAXM];void Add(int pos, const long long&amp; delta) &#123; for (; pos &lt; MAXM; pos += lowbit(pos)) arr[pos] += delta;&#125;long long Query(int pos) &#123; if (pos &lt;= 0) return 0LL; long long sum = 0; for (; pos &gt; 0; pos -= lowbit(pos)) sum += arr[pos]; return sum;&#125;struct Query &#123; int opt, ID, fr, to;//Opt=1 是一个国家的统计，Opt=2是陨石雨 long long val; Query() &#123;&#125;&#125;que[MAXN], q1[MAXN], q2[MAXN];int targ[MAXN], totNa, totMi, totK, ans[MAXN];std::vector&lt;int&gt; G[MAXN];void Solve(const int &amp;qfr, const int &amp;qto, const int &amp;ans_fr, const int &amp;ans_to) &#123; if (qfr &gt; qto || ans_fr &gt; ans_to) return; if (ans_fr == ans_to) &#123; for (int i = qfr; i &lt;= qto; i++) if (que[i].opt == 1) ans[que[i].ID] = ans_fr; return; &#125; int ans_mid = (ans_fr + ans_to) &gt;&gt; 1; auto *s1 = q1, *s2 = q2; long long temp; for (int i = qfr; i &lt;= qto; i++) &#123; switch (que[i].opt) &#123; case 1: temp = 0; for (const auto &amp;it : G[que[i].ID]) if ((temp += Query(it)) &gt;= que[i].val) break; if (temp &gt;= que[i].val) *s1++ = que[i]; else &#123; que[i].val -= temp; *s2++ = que[i]; &#125; break; case 2: if (que[i].ID &lt;= ans_mid) &#123; Add(que[i].fr, que[i].val); Add(que[i].to + 1, -que[i].val); *s1++ = que[i]; &#125; else *s2++ = que[i]; break; case 3: //相当于两段 [1,to] [fr,totM] if (que[i].ID &lt;= ans_mid) &#123; Add(1, que[i].val); Add(que[i].to + 1, -que[i].val); Add(que[i].fr, que[i].val); Add(totMi + 1, -que[i].val); *s1++ = que[i]; &#125; else *s2++ = que[i]; break; default: puts("UKE"); assert(false); break; &#125; &#125; for (int i = qfr; i &lt;= qto; i++) if (que[i].ID &lt;= ans_mid &amp;&amp; que[i].opt != 1) if (que[i].opt == 2) &#123; Add(que[i].fr, -que[i].val); Add(que[i].to + 1, que[i].val); &#125; else &#123; assert(que[i].opt == 3); Add(1, -que[i].val); Add(que[i].to + 1, que[i].val); Add(que[i].fr, -que[i].val); Add(totMi + 1, que[i].val); &#125; for (auto *i = q1; i &lt; s1; i++) que[qfr + i - q1] = *i; for (auto *i = q2; i &lt; s2; i++) que[qfr + i - q2 + s1 - q1] = *i; if (q1 &lt; s1) Solve(qfr, qfr + s1 - q1 - 1, ans_fr, ans_mid); if (q2 &lt; s2) Solve(qfr + s1 - q1, qto, ans_mid + 1, ans_to);&#125;signed main()&#123; int a, b, k; scanf("%d%d", &amp;totNa, &amp;totMi);//总国家数-空间站总数 for (int i = 1; i &lt;= totMi; i++) &#123; scanf("%d", &amp;a); G[a].push_back(i); &#125; for (int i = 1; i &lt;= totNa; i++) scanf("%d", targ + i); scanf("%d", &amp;totK);//事件（陨石雨）总数 for (int i = 1; i &lt;= totK; i++) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;k); que[i].ID = i; que[i].fr = a; que[i].to = b; que[i].val = k; que[i].opt = (que[i].fr &gt; que[i].to ? 3 : 2); &#125; for (int i = 1; i &lt;= totNa; i++) &#123; que[i + totK].val = targ[i]; que[i + totK].ID = i; que[i + totK].opt = 1; &#125; Solve(1, totK + totNa, 1, totK + 1); for (int i = 1; i &lt;= totNa; i++) if (ans[i] &lt;= totK) printf("%d\n", ans[i]); else puts("NIE"); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>整体二分</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】POI2015 LOG]]></title>
    <url>%2F2019%2F02%2F06%2FPOI2015-LOG%2F</url>
    <content type="text"><![CDATA[维护一个长度为 $n$ 的序列，一开始都是 $0$，支持以下两种操作： U $k$ $a$ 将序列中第 $k$ 个数修改为 $a$。 Z $c$ $s$ 在这个序列上，每次选出 $c$ 个正数，并将它们都减去 $1$，询问能否进行 $s$ 次操作。 总共 $m$ 次询问，每次询问独立，即每次询问不会对序列进行修改。 可以发现我们需要维护的是一个可重集合。考虑操作 2. 首先证明一个引理，便于答案的判定。 如果 $t$ 代表集合中不小于 $s$ 的数的个数，$sum$ 表示所有小于 $s$ 的数的数值总和，那么如果 $s(c-t)\leq sum$, 那么询问 2 的答案就是能。 我们在每一次选择的时候肯定要优先选择那些不小于 $s$ 的数，将它们每次都选上，然后我们相当于要每次选择 $c-t$ 个数，选择 $s$ 次，由于剩下的数都小于 $s$, 而且 $sum\leq s(c-t)$, 所以剩下的数的数量肯定多于 $c-t$. 那么我们需要维护的，就是前驱和区间和，这就是平衡树的基本操作，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;namespace Splay &#123;#define lft ch[0]#define rgt ch[1] struct Node &#123; long long val, sum, mark; int siz, cnt; Node *ch[2], *fa; Node() &#123; fa = ch[0] = ch[1] = nullptr; cnt = siz = 1; mark = 0; &#125; Node&amp; Refresh(void) &#123; siz = cnt; sum = val * cnt; if (ch[0] != nullptr) &#123; siz += ch[0]-&gt;siz; sum += ch[0]-&gt;sum; &#125; if (ch[1] != nullptr) &#123; siz += ch[1]-&gt;siz; sum += ch[1]-&gt;sum; &#125; return *this; &#125; short Compare(const long long &amp;comp) const &#123; return comp == val ? -1 : comp &gt; val; &#125; &#125;*root = nullptr; void Rotate(Node *targ) &#123; if (targ-&gt;fa == nullptr) return; const short p = targ-&gt;fa-&gt;Compare(targ-&gt;val); Node* faa = targ-&gt;fa; if (faa-&gt;fa != nullptr) faa-&gt;fa-&gt;ch[faa-&gt;fa-&gt;val] = targ; faa-&gt;ch[p] = targ-&gt;ch[p ^ 1]; if (targ-&gt;ch[p ^ 1] != nullptr) targ-&gt;ch[p ^ 1]-&gt;fa = faa; targ-&gt;ch[p ^ 1] = faa; targ-&gt;fa = faa-&gt;fa; faa-&gt;fa = targ; faa-&gt;Refresh(); targ-&gt;Refresh(); &#125; void Spaly(Node* targ) &#123; for (; targ-&gt;fa != nullptr&amp;&amp;targ-&gt;fa-&gt;fa != nullptr; Rotate(targ)) if (targ-&gt;fa-&gt;fa-&gt;Compare(targ-&gt;fa-&gt;fa-&gt;val) == targ-&gt;fa-&gt;Compare(targ-&gt;val)) Rotate(targ-&gt;fa); else Rotate(targ); if (targ-&gt;fa != nullptr) Rotate(targ); root = targ; &#125; void Insert(const int &amp;val) &#123; if (root == nullptr) &#123; root = new Node(); root-&gt;val = root-&gt;sum = val; return; &#125; Node* nowAt = root; short p; while (true) &#123; p = nowAt-&gt;Compare(val); if (p == -1) &#123; nowAt-&gt;cnt++; nowAt-&gt;Refresh(); Spaly(nowAt); return; &#125; else if (nowAt-&gt;ch[p] == nullptr) &#123; nowAt-&gt;ch[p] = new Node(); nowAt-&gt;ch[p]-&gt;sum = nowAt-&gt;ch[p]-&gt;val = val; nowAt-&gt;ch[p]-&gt;fa = nowAt; Spaly(nowAt-&gt;ch[p]); return; &#125; else nowAt = nowAt-&gt;ch[p]; &#125; &#125; void Add(const int &amp;orig, const int &amp;delta) &#123; Node* nowAt = root; short p; while (true) &#123; p = nowAt-&gt;Compare(orig); if (p == -1) &#123; nowAt-&gt;cnt--; nowAt-&gt;Refresh(); Spaly(nowAt); Insert(nowAt-&gt;val + delta); return; &#125; else nowAt = nowAt-&gt;ch[p]; &#125; &#125; bool Bound(const int &amp;val) &#123; Node* nowAt = root, *targ = nullptr; short p; while (nowAt != nullptr) &#123; p = nowAt-&gt;Compare(val); if (p == -1) &#123; targ = nowAt; break; &#125; if (p == 0) targ = nowAt; nowAt = nowAt-&gt;ch[p]; &#125; if (targ == nullptr)return false; Spaly(targ); return true; &#125;&#125;; using namespace Splay;constexpr auto MAXN = 1000000 + 500;int num[MAXN]; bool exist[MAXN];signed main(void)&#123; int totNums, totOptn, k, a, c, t; long long s, sum; char opt[10]; scanf("%d%d", &amp;totNums, &amp;totOptn); while (totOptn--) &#123; scanf("%s", opt); switch (*opt) &#123; case 'U': scanf("%d%d", &amp;k, &amp;a); if (!exist[k]) Insert(a); else Add(num[k], a - num[k]); exist[k] = true; num[k] = a; break; case 'Z': scanf("%d%lld", &amp;c, &amp;s); if (root == nullptr) &#123; puts(c == 0 ? "TAK" : "NIE"); break; &#125; if (Bound(s)) &#123; t = root-&gt;siz - (root-&gt;ch[0] == nullptr ? 0 : root-&gt;ch[0]-&gt;siz); sum = root-&gt;ch[0] == nullptr ? 0 : root-&gt;ch[0]-&gt;sum; &#125; else &#123; t = 0; sum = root-&gt;sum; &#125; puts(sum &gt;= s * (long long)(c - t) ? "TAK" : "NIE"); break; default: puts("UKE"); assert(false); break; &#125; &#125; return 0;&#125; 这里有几个坑放着以后再填：一个是前面未完成的证明，再就是这份不能 AC 的代码。 尽管平衡树常数大，写起来复杂，但是我们实际上没有必要将两个信息放在一起维护，而可以使用树状数组巧妙地代替平衡树完成查询。 第一颗树状数组维护一个数组，其中第 $i$ 个元素 $a_i$ 代表权值为 $a_i$ 的数出现了多少次。 第二颗树状数组维护一个数组，其中第 $i$ 个元素 $b_i$ 代表权值为 $b_i$ 的所有的数的权值总和。 为什么不能根据 $b_i=i\cdot a_i$ 从而去掉第二个树状数组呢？因为这道题目值域较大，因此需要离散化，将树状数组的下标全部替换为离散化后的值，保存的数值仍为实际值。 这么做的时间复杂度为 $O(M\log N +M\log M)$, 由于这里使用的是树状数组，因此它自带了小常数，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;#define lowbit(x) ((x)&amp;(-(x)))constexpr auto MAXN = 1000000 + 5;int arr1[MAXN]; //一个使用树状数组维护的数组，其中的元素代表 离散化之后为下标的数出现了多少次long long arr2[MAXN]; //一个使用树状数组维护的数组，其中的元素代表 离散化之后为下标的数的总权值（原值）void Add1(int pos, const int &amp;delta) &#123; for (; pos &lt; MAXN; pos += lowbit(pos)) arr1[pos] += delta;&#125;void Add2(int pos, const long long &amp;delta) &#123; for (; pos &lt; MAXN; pos += lowbit(pos)) arr2[pos] += delta;&#125;int Query1(int pos) &#123; if (pos &lt;= 0) return 0; int sum = 0; for (; pos &gt; 0; pos -= lowbit(pos)) sum += arr1[pos]; return sum;&#125;long long Query2(int pos) &#123; if (pos &lt;= 0) return 0; long long sum = 0; for (; pos &gt; 0; pos -= lowbit(pos)) sum += arr2[pos]; return sum;&#125;std::map&lt;int, int&gt; map, val;struct Query &#123; int optn, a, b; //原值 Query() &#123;&#125; Query(const int &amp;ioptn, const int &amp;ia, const int &amp;ib) : optn(ioptn), a(ia), b(ib) &#123;&#125;&#125;que[MAXN];int hash[MAXN], totVal, S;int num[MAXN];//保存序列的原值bool exist[MAXN];signed main()&#123; //puts("BEGIN"); fflush(stdout); int totNums, totOptn, a, b; char opt[10]; scanf("%d%d", &amp;totNums, &amp;totOptn); for (int i = 0; i &lt; totOptn; i++) &#123; scanf("%s%d%d", opt, &amp;a, &amp;b); hash[i] = b; que[i] = Query(*opt == 'Z', a, b); &#125; std::sort(hash, hash + totOptn); totVal = std::unique(hash, hash + totOptn) - hash; for (int i = 0; i &lt; totVal; i++) &#123; map[hash[i]] = i+1; val[i+1] = hash[i]; &#125; //puts("Checkpoint 1"); fflush(stdout); int c, t, s; long long sum; for (int i = 0; i &lt; totOptn; i++) &#123; //printf("OptionID: %d\n", i); fflush(stdout); auto it = que[i]; switch (it.optn) &#123; case 0: //修改操作 a = map[num[it.a]];/*改动之前序列这个位置上的映射值*/ b = map[it.b]; //离散化后的映射值 if (!exist[it.a]) &#123; //位置a为空 Add1(b, 1); Add2(b, it.b); exist[it.a] = true; S++; &#125; else &#123; Add1(a, -1); Add2(a, -num[it.a]); if (it.b == 0) &#123; exist[it.a] = false; S--; &#125; else &#123; Add1(b, 1); Add2(b, it.b); &#125; &#125; num[it.a] = it.b; break; case 1: c = it.a; s = it.b; b = map[s]; t = S - Query1(b - 1); sum = Query2(b - 1); puts((long long)(c - t)*(long long)s &lt;= sum ? "TAK" : "NIE"); break; default: puts("UKE"); assert(false); break; &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1108E Array and Segments]]></title>
    <url>%2F2019%2F02%2F05%2FCF1108E-Array-and-Segments%2F</url>
    <content type="text"><![CDATA[题目链接：(Easy Version),(Hard Version) 这道题目大致意思是，给定一个长度为 $n$ 的序列，其中第 $i$ 个元素为 $a_i$. 同时给定 $m$ 个区间，第 $i$ 个用一个二元组 $(fr,to)$ 表示。我们需要选择一些二元组应用到序列上，即对于每一个区间，将序列上这个区间内的数值全部减去 1. 现在我们需要求出一个最佳方案，使得应用后整个序列中最大的数与最小的数差值最大。 首先我们假定位于 $pos$ 的元素是最终的最大元素，那么显然我们应该应用所有不包含它的区间，才能让最小值尽可能小，因为如果一个区间包含了 $pos$, 那么最大值减少了 1，而最小值有可能不变（即在这个区间外部），因此应用这个区间不可能让答案更优。枚举 $pos$, 然后一个个应用符合要求的区间，同时用线段树优化，可以在 $O(NM\log N)$ 时间复杂度内通过 Easy Version. 接着考虑如何优化，我们可以发现对于一个特定的 $pos$, 应该应用的区间就是所有满足右端点小于 $pos$ 或者左端点大于 $pos$ 的区间，很明显他们是没有交集的。我们先考虑第一类区间，如果我们从左往右枚举 $pos$, 那么对于一个更靠右的 $pos​$, 比它靠左的位置应用的区间它也一定要应用。 这样，我们将区间按照右端点从小到大排序，同时定义数组 $lft_i$ 代表以 $i$ 为 $pos$, 只考虑第一类路径，应该应用下标为 $[0,lft_i)$ 的区间，可以发现 $lft_i$ 单调不减，同时 $lft_i&lt;m$, 因此我们可以在 $O(N)$ 时间内计算出 $lft$ 数组。 随后，还是利用线段树，每次考虑下一个 $pos$ 时在原来的基础上进行修改，可以处理出一个数组 $min_i$ ，代表只考虑第一类区间，以 $i$ 作为 $pos$ 时整个序列的最小值。 同样的方法也可以用于考虑第二类路径。合并一下 $min$ ，答案就是一个最大的 $a_i-min_i​$. 总时间复杂度为 $O(N+M\log N)$. 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;#define Attend push_backnamespace SegTree&#123; template&lt;typename T&gt; class SegTr&#123; private: struct Node&#123; int fr,to; T min,mark; Node *lft,*rgt; Node()&#123; lft = rgt = nullptr; mark=0; &#125; Node&amp; Push_Down(void)&#123; if(mark &amp;&amp; lft!=nullptr)&#123; assert(rgt!=nullptr); lft-&gt;mark += mark; rgt-&gt;mark += mark; lft-&gt;min += mark; rgt-&gt;min += mark; mark = 0; &#125; return *this; &#125; Node&amp; AddMark(const T&amp; val)&#123; mark += val; min += val; return *this; &#125; Node&amp; Refresh(void)&#123; if(lft!=nullptr)&#123; assert(rgt!=nullptr); min=std::min(lft-&gt;min,rgt-&gt;min); &#125; return *this; &#125; &#125;; void Free(Node* targ)&#123; if(targ-&gt;lft!=nullptr) Free(targ-&gt;lft); if(targ-&gt;rgt!=nullptr) Free(targ-&gt;rgt); free(targ); &#125; public: Node* root = nullptr; SegTr&lt;T&gt;&amp; Clear(void)&#123; if(root != nullptr) Free(root); root = nullptr; return *this; &#125; SegTr&lt;T&gt;&amp; Build(const int&amp; siz, T* arr)&#123; Node *a,*b,*t; std::queue&lt;Node*&gt; que,add; for(int i=1;i&lt;=siz;i++)&#123; t = new Node(); t-&gt;fr=t-&gt;to=i; t-&gt;min = *arr++; que.push(t); &#125; for(;que.size()&gt;=2;std::swap(add,que))&#123; while(que.size()&gt;=2)&#123; a=que.front(); que.pop(); b=que.front(); que.pop(); t= new Node(); t-&gt;fr=a-&gt;fr; t-&gt;to=b-&gt;to; t-&gt;min=std::min(a-&gt;min, b-&gt;min); t-&gt;lft=a; t-&gt;rgt=b; add.push(t); &#125; if(!que.empty())&#123; add.push(que.front()); que.pop(); &#125; &#125; root = que.front(); return *this; &#125; void Add(const int &amp;fr,const int &amp;to, const T &amp;add, Node* nowAt)&#123; if(nowAt==nullptr)return; if(to&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;fr) return; nowAt-&gt;Push_Down(); if(fr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=to) nowAt-&gt;AddMark(add); else &#123; Add(fr,to,add,nowAt-&gt;lft); Add(fr,to,add,nowAt-&gt;rgt); nowAt-&gt;Refresh(); &#125; &#125; void Query(const int &amp;fr,const int &amp;to, T&amp; min, Node* nowAt)&#123; if(nowAt==nullptr)return; if(to&lt;nowAt-&gt;fr || nowAt-&gt;to&lt;fr) return; nowAt-&gt;Push_Down(); if(fr&lt;=nowAt-&gt;fr &amp;&amp; nowAt-&gt;to&lt;=to) min=std::min(min,nowAt-&gt;min); else &#123; Query(fr,to,min,nowAt-&gt;lft); Query(fr,to,min,nowAt-&gt;rgt); &#125; &#125; &#125;;&#125;;using namespace SegTree;constexpr auto MAXN = (int)1e5+500;constexpr auto MAXM = (int)300+500;SegTr&lt;int&gt; tr;struct Segment&#123; int fr,to, ID; Segment()&#123;&#125; Segment(const int &amp;ifr,const int &amp;ito, const int &amp;iID) : fr(ifr),to(ito),ID(iID)&#123;&#125;&#125;;int lftPos[MAXN],rgtPos[MAXN];Segment lftSort[MAXM],rgtSort[MAXM];int num[MAXN],min[MAXN];signed main()&#123; int totNums,totSeq,fr,to; scanf("%d%d", &amp;totNums,&amp;totSeq); for(int i=1;i&lt;=totNums;i++) scanf("%d", num+i); for(int i=0;i&lt;totSeq;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); lftSort[i] = rgtSort[i] = Segment(fr,to,i+1); &#125; //lftTr.Build(totNums,num); rgtTr.Build(totNums,num); std::sort(lftSort,lftSort+totSeq, [](const Segment&amp; a,const Segment&amp; comp)&#123; return a.to &lt; comp.to; &#125;); std::sort(rgtSort,rgtSort+totSeq, [](const Segment&amp; a,const Segment&amp; comp)&#123; return a.fr &gt; comp.fr; &#125;); memset(lftPos,0,sizeof(lftPos)); memset(rgtPos,0,sizeof(rgtPos)); int pos = 0, res; tr.Build(totNums, num+1); for(int i=1;i&lt;=totNums;i++)&#123; lftPos[i] = lftPos[i-1]; while(i &gt; lftSort[lftPos[i]].to &amp;&amp; lftPos[i]&lt;totSeq) &#123; tr.Add(lftSort[lftPos[i]].fr,lftSort[lftPos[i]].to,-1,tr.root); lftPos[i]++; &#125; res = INT_MAX; tr.Query(1,totNums,res,tr.root); min[i] = res; &#125; tr.Clear().Build(totNums,num+1); for(int i=totNums;i&gt;0;i--)&#123; rgtPos[i] = rgtPos[i+1]; while(i &lt; rgtSort[rgtPos[i]].fr &amp;&amp; rgtPos[i]&lt;totSeq)&#123; tr.Add(rgtSort[rgtPos[i]].fr,rgtSort[rgtPos[i]].to,-1,tr.root); rgtPos[i]++; &#125; res = INT_MAX; tr.Query(1,totNums,res,tr.root); min[i] = std::min(min[i],res); if(num[i]-min[i]&gt;num[pos]-min[pos]) pos = i; &#125; printf("%d\n%d\n", num[pos]-min[pos], lftPos[pos]+rgtPos[pos]); for(int i=0;i&lt;lftPos[pos];i++)printf("%d ", lftSort[i].ID); for(int i=0;i&lt;rgtPos[pos];i++)printf("%d ", rgtSort[i].ID); putchar('\n'); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>线段树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】最小路径覆盖问题]]></title>
    <url>%2F2019%2F02%2F04%2F%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这道题目的大致意思是给定一个有向无环图 $G=(V,\,E)$，你需要选择一个路径的集合 $S$, 他说包含的所有路径 $t_i\in S$ 正好不重复不遗漏地包含所有的结点，现在需要求一组方案，使得 $|S|$ 尽可能小。 这是网络流 24 题中的一道，我们考虑如何使用网络流求解这个问题。 首先，按照下列规则建立模型： 将一个结点 $i$ 拆分成为两个，它们的散列值分别为 $2i$ 和 $2i+1$, 记作左边和右边。 建立源点 $s$, 汇点 $t$. 将 $s$ 与所有左边相连，容量为 1. 同时将所有右边与 $t$ 相连，容量为 1. $\forall\;u\to v\in E$, 将 $u$ 的左边与 $v$ 的右边相连，容量为 1. 为了便于描述，我们将一条路径看作一个序列 $L=(u_1,u_2,u_3,\cdots,u_n)$. 在这个模型中，类型 3 的路径描述了 $G$ 中所有有向边的关系，如果结点 $i$ 的左边与结点 $j$ 的右边相连，那么意味着 $i$ 和 $j$ 可以成为同一条路径中相邻的结点， 即 $u_t\in L\;,u_{t+1}\in L$. 在此模型上运行最大流算法，可以发现，所有的流的产生都是相似的，即从源点 $s$ 出发，流经一个结点 $u$ 的左边，到达另外一个结点 $v$ 的右边，然后到达汇点 $t$. 这样的一条增广路描述了一个位置关系，即 $u$ 和 $v$ 处于同一条路径当中，而且 $v$ 紧跟在 $u$ 的后面。 所有的增广路便描述了最佳的方案，我们只用依次检查每个结点的左边，看看它的下一个结点是什么，最后维护一下，统一输出即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 1000+500;int up[MAXN];int FindTop(const int nowAt)&#123; return up[nowAt]==nowAt?nowAt:(up[nowAt]=FindTop(up[nowAt])); &#125;void Unity(const int fr,const int to)&#123; up[FindTop(fr)]=FindTop(to); &#125;struct Edge&#123; int fr,to,residual; Edge(const int &amp;ifr, const int &amp;ito, const int &amp;ire) : fr(ifr),to(ito),residual(ire)&#123;&#125;&#125;;std::vector&lt;Edge&gt; edges;std::vector&lt;int&gt; G[MAXN];#define Attend push_backvoid AddEdge(const int &amp;fr,const int &amp;to,const int &amp;res)&#123; G[fr].Attend(edges.size()); edges.Attend(Edge(fr,to,res)); G[to].Attend(edges.size()); edges.Attend(Edge(to,fr,0));&#125;int dep[MAXN],cur[MAXN];bool begin[MAXN];const int s=0, t=MAXN-1;bool BFS(void)&#123; bool vis[MAXN]; memset(vis,false,sizeof(vis)); std::queue&lt;int&gt; que; que.push(s); vis[s] = true; dep[s] = 0; int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(const auto &amp;i : G[nowAt])&#123; const auto &amp;it = edges[i]; if(!vis[it.to] &amp;&amp; it.residual&gt;0)&#123; vis[it.to] = true; dep[it.to] = dep[nowAt]+1; que.push(it.to); &#125; &#125; &#125; return vis[t];&#125;int Dfs(const int &amp;nowAt, int maxFlow = INT_MAX)&#123; if(nowAt == t || maxFlow &lt;= 0) return maxFlow; int flow=0,deltaFlow; for(int&amp; i=cur[nowAt];i&lt;G[nowAt].size();i++)&#123; auto &amp;it = edges[G[nowAt][i]]; if(dep[nowAt]+1 == dep[it.to] &amp;&amp; 0&lt;(deltaFlow=Dfs(it.to,std::min(maxFlow,it.residual))))&#123; flow += deltaFlow; maxFlow -= deltaFlow; it.residual -= deltaFlow; edges[G[nowAt][i]^1].residual += deltaFlow; if(maxFlow &lt;= 0) return flow; &#125; &#125; return flow;&#125;int Dinic(void)&#123; int totFlow = 0; while(BFS())&#123; memset(cur,0,sizeof(cur)); totFlow += Dfs(s); &#125; return totFlow;&#125;signed main()&#123; memset(begin,true,sizeof(begin)); for(int i=0;i&lt;MAXN;i++) up[i]=i; int totNode, totRoad, fr,to; //编号为 i 的结点的散列值为 2i(左边), 2i+1(右边) scanf("%d%d",&amp;totNode,&amp;totRoad); for(int i=1;i&lt;=totNode;i++)&#123; AddEdge(s,i&lt;&lt;1,1); AddEdge((i&lt;&lt;1)|1,t,1); &#125; for(int i=0;i&lt;totRoad;i++)&#123; scanf("%d%d", &amp;fr,&amp;to); AddEdge(fr&lt;&lt;1,(to&lt;&lt;1)|1,1); &#125; int ans = totNode-Dinic(), nxt[MAXN]=&#123;&#125;, pre[MAXN]=&#123;&#125;,now; bool vis[MAXN]; memset(vis,false,sizeof(vis)); for(int i=1;i&lt;=totNode;i++) for(int j=0;j&lt;G[i&lt;&lt;1].size();j++)&#123; const auto &amp;it = edges[G[i&lt;&lt;1][j]]; if(it.residual == 0)&#123; pre[it.to&gt;&gt;1] = it.fr&gt;&gt;1; nxt[it.fr&gt;&gt;1] = it.to&gt;&gt;1; break; &#125; &#125; for(int i=1;i&lt;=totNode;i++) if(!vis[i])&#123; now=i;while(pre[now]!=0) now = pre[now]; for(;now!=0;now=nxt[now])&#123; printf("%d ", now); vis[now] = true; &#125; putchar('\n'); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】试题库问题]]></title>
    <url>%2F2019%2F02%2F04%2F%E8%AF%95%E9%A2%98%E5%BA%93%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[对于这道题目，按照以下规则建立模型： 赋予题目和类型一个散列值作为结点编号，编号为 $i$ 的题目散列值为 $i$, 编号为 $j$ 的类型散列值为 $j+n$, 其中 $n$ 是试题总数。 建立额外的源点 $s$, 汇点 $t$. $\forall i$, 连接 $s$ 和 $i$, 容量为 $1$. $\forall j$, 连接 $j$ 和 $t$, 容量为 $num_j$, 其中 $num_i$ 为 $i$ 类型试题需要的总数。 如果一道题目 $i$ 属于类型 $j$, 连接 $i$ 和 $j$, 容量为 1. 在这个模型上运行最大流算法，如果所有的 4 类路径流量流满容量，那么说明有解。对于一个题目结点 $i$, 它要么没有被选择，此时从它出发的所有边流量都为 0；要么被选择成为一种类型的题目出现，此时从它出发有且仅有一条边流量为 1，这一条边连接的就是它成为的类型。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (1000&lt;&lt;1)+50;constexpr auto MAXK = 20+5;constexpr auto MAXM = 1000+50;struct Edge&#123; int fr,to,residual; Edge(const int &amp;ifr, const int &amp;ito, const int &amp;ire) : fr(ifr),to(ito),residual(ire) &#123;&#125;&#125;;std::vector&lt;Edge&gt; edges;std::vector&lt;int&gt; G[MAXN];#define Attend push_backvoid AddEdge(const int &amp;fr,const int &amp;to,const int &amp;res)&#123; G[fr].Attend(edges.size()); edges.Attend(Edge(fr,to,res)); G[to].Attend(edges.size()); edges.Attend(Edge(to,fr,0));&#125;int dep[MAXN],cur[MAXN];const int s=0,t=MAXN-1;bool BFS(void)&#123; bool vis[MAXN]; memset(vis,false,sizeof(vis)); std::queue&lt;int&gt; que; que.push(s); dep[s]=0; vis[s]=true; int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(int i=0;i&lt;G[nowAt].size();i++)&#123; const auto &amp;it = edges[G[nowAt][i]]; if(!vis[it.to] &amp;&amp; it.residual&gt;0)&#123; vis[it.to]=true; dep[it.to]=dep[nowAt]+1; que.push(it.to); &#125; &#125; &#125; return vis[t];&#125;int Dfs(const int &amp;nowAt, int maxFlow = INT_MAX)&#123; if(nowAt==t || maxFlow&lt;=0) return maxFlow; int flow=0,deltaFlow; for(int &amp;i=cur[nowAt];i&lt;G[nowAt].size();i++)&#123; auto &amp;it = edges[G[nowAt][i]]; if(dep[nowAt]+1==dep[it.to] &amp;&amp; 0&lt;(deltaFlow=Dfs(it.to,std::min(maxFlow,it.residual))))&#123; flow+=deltaFlow; maxFlow-=deltaFlow; it.residual-=deltaFlow; edges[G[nowAt][i]^1].residual+=deltaFlow; if(maxFlow&lt;=0) return flow; &#125; &#125; return flow;&#125;int Dinic(void)&#123; int totFlow=0; while(BFS())&#123; memset(cur,0,sizeof(cur)); totFlow += Dfs(s); &#125; return totFlow;&#125;int category[MAXN];std::vector&lt;int&gt; Quiz[MAXK]; signed main()&#123; int totQuiz,totType,types,typ,totNums=0; // 题目 i（左边）对应的散列值 i, 类型 i（右边）对应的散列值 i+n Read: scanf("%d%d",&amp;totType,&amp;totQuiz); for(int i=1;i&lt;=totType;i++)&#123; scanf("%d",&amp;typ); totNums+=typ; AddEdge(i+totQuiz,t,typ); &#125; for(int i=1;i&lt;=totQuiz;i++)&#123; scanf("%d",&amp;types); AddEdge(s,i,1); for(int j=0;j&lt;types;j++)&#123; scanf("%d",&amp;typ); AddEdge(i,typ+totQuiz,1); &#125; &#125; if(totNums&gt;Dinic())&#123; puts("No Solution!"); goto ProgramEnd; &#125; memset(category,-1,sizeof(category)); for(int i=1;i&lt;=totQuiz;i++) for(int j=0;j&lt;G[i].size();j++) if(edges[G[i][j]].residual == 0)&#123; category[i] = edges[G[i][j]].to - totQuiz; break; &#125; for(int i=1;i&lt;=totQuiz;i++) if(category[i] &gt; 0) Quiz[category[i]].Attend(i); for(int i=1;i&lt;=totType;i++)&#123; printf("%d: ",i); for(const auto &amp;it : Quiz[i]) printf("%d ",it); putchar('\n'); &#125; ProgramEnd: //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】魔术球问题]]></title>
    <url>%2F2019%2F02%2F04%2F%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在这道题中，需要用到网络流 Dinic 算法的一些性质加上建模技巧。首先，按照下列规则建立模型： 将一个标号为 $i$ 的球拆分成为 2 个，对应的散列值分别为 $2i$ 和 $2i+1$. 分别记它们为 $i$ 的左边和右边。 建立源点 $s$ 与所有左边连接一条容量为 1 的边，将所有右边与建立的汇点 $t$ 连接一条容量为 1 的边。 $\forall i&lt;j,\;i+j\mbox{ 是一个完全平方数}$ 将 $i$ 的左边与 $j$ 的右边连接一条容量为 1 的边。 由于我们依次放入编号单调递增的小球，所以对于确定的球数 $m$, 显然需要的柱子是单调递增的，放置完成之后每一个柱子上的球的编号也是单调递增的。 对于给定的 $m$, 在运行最大流之后每经过一次类型 3 的路径，就相当于在 $i$ 的后面紧接着放入 $j$, 我们只需要看看有哪些球对应结点的左边是没有流量经过的，就得出了目前需要的柱子数量。 当我们加入了一个新的小球的时候，可以再次运行 Dinic 算法，由于 Dinic 算法中是可以撤销的，因此它总是可以给我们最优的解。如果这时有了新的流量，那么就说明经过一番调整，这个球可以放在某一个球的后面；如果没有，说明这个球需要一个新的柱子来放置。 这样，我们可以枚举一下最终的总球数，每一次加入一个球然后重复地运行 Dinic 算法，直到需要的柱子超过了总柱子数。同时，我们需要在 Dinic 的过程中记录以下流量的流向，对于一个散列值是 $u$ 的结点，它所对应的小球的编号就是 $\lfloor\frac u 2\rfloor$. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;#define sqr(x) ((x)*(x))constexpr auto MAXN = 1000000 + 500;struct Edge&#123; int fr,to,residual; Edge(const int &amp;ifr,const int &amp;ito,const int &amp;ire) : fr(ifr),to(ito),residual(ire)&#123;&#125;&#125;;std::vector&lt;Edge&gt; edges;std::vector&lt;int&gt; G[MAXN];void AddEdge(const int &amp;fr,const int &amp;to,const int &amp;maxflow)&#123; G[fr].push_back(edges.size()); edges.push_back(Edge(fr,to,maxflow)); G[to].push_back(edges.size()); edges.push_back(Edge(to,fr,0));&#125;int nxt[MAXN];int s,t;int depth[MAXN];bool BFS(void)&#123; bool inQueue[MAXN]; memset(inQueue,false,sizeof(inQueue)); std::queue&lt;int&gt; que; que.push(s); inQueue[s] = true; int nowAt; while(!que.empty())&#123; nowAt = que.front(); que.pop(); for(const auto &amp;num : G[nowAt])&#123; const auto &amp;it = edges[num]; if(!inQueue[it.to] &amp;&amp; it.residual &gt; 0)&#123; que.push(it.to); inQueue[it.to] = true; depth[it.to] = depth[nowAt] + 1; &#125; &#125; &#125; return inQueue[t];&#125;int cur[MAXN];int Dfs(const int &amp;nowAt, int maxFlow)&#123; if(nowAt == t || maxFlow &lt;= 0) return maxFlow; int flow = 0, deltaFlow; for(int&amp; i=cur[nowAt];i&lt;G[nowAt].size();i++)&#123; auto &amp;it = edges[G[nowAt][i]]; if(depth[nowAt] + 1 == depth[it.to] &amp;&amp; (deltaFlow = Dfs(it.to, std::min(maxFlow, it.residual))) &gt; 0)&#123; it.residual -= deltaFlow; edges[G[nowAt][i]^1].residual += deltaFlow; flow += deltaFlow; maxFlow -= deltaFlow; nxt[nowAt&gt;&gt;1] = it.to&gt;&gt;1; if(maxFlow &lt;=0 ) break; &#125; &#125; return flow;&#125;int Dinic(void)&#123; int totFlow = 0; while(BFS())&#123; memset(cur,0,sizeof(cur)); totFlow += Dfs(s,INT_MAX); &#125; return totFlow;&#125;int head[MAXN];signed main(void)&#123; int totPil,nowPil=0,nowBall=0; scanf("%d",&amp;totPil); s = 0; t = MAXN - 1; int flow; while(nowPil &lt;= totPil)&#123; nowBall++; //放入一个船新的球，数字为 nowBall //当前球的映射 nowBall.A -&gt; nowBall*2 nowBall.B -&gt; nowBall*2+1 AddEdge(s,nowBall&lt;&lt;1,1); AddEdge((nowBall&lt;&lt;1)|1,t,1); //找到可以将当前球放在后面的结点 for(int i=sqrt(nowBall)+1; sqr(i)&lt;(nowBall&lt;&lt;1) /* i*i-nowBall&lt;nowBall */;i++) //连接 (i*i-nowBall).A -&gt; nowBall.B //AddEdge(nowBall&lt;&lt;1,(sqr(i)-nowBall&lt;&lt;1)|1,1); AddEdge(sqr(i)-nowBall&lt;&lt;1, (nowBall&lt;&lt;1)|1, 1); if((flow=Dinic()) &lt;= 0) head[nowPil++] = nowBall; //记录当前球是一个新的柱子最底层的球。 &#125; //Output printf("%d\n",nowBall-1); for(int i=0;i&lt;totPil;i++)&#123; for(int now=head[i]; now!=0&amp;&amp;now!=(t&gt;&gt;1); now=nxt[now]) printf("%d ",now); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】NOI2014 起床困难综合症]]></title>
    <url>%2F2019%2F02%2F01%2FNOI2014-%E8%B5%B7%E5%BA%8A%E5%9B%B0%E9%9A%BE%E7%BB%BC%E5%90%88%E7%97%87%2F</url>
    <content type="text"><![CDATA[题目在这里.(LG) 这道题目可以利用贪心的做法，先让全部是 1 和全部是 0 的二进制数通过全部的位运算，然后由于这些位运算不同的位之间是互不干扰的，所以可以得到每一位是 0 或者 1 通过所有位运算之后得到的二进制数。之后，从高到低依次判断第 $i$ 位上的映射关系： 如果这一位上存在映射 $0\to 1$, 那么答案的这一位就是 1. 如果这一位上存在映射 $1\to 1$, 那么根据贪心的思想，我们尽可能让答案的这一位是 1. 这时需要考虑最大攻击力，如果大于 1&lt;&lt;$i$, 那么就将最大攻击力减去 1&lt;&lt;$i$, 然后答案的这一位就是 1 了。 其他情况无论这一位上的数是什么，最后都会变为 0，可以不用考虑。 这样，总时间复杂度为 $O(N)$. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;signed main(void)&#123; int totOptn, t, maxm; char opt[10]; long long _1 = (1LL &lt;&lt; 31) - 1, _0 = 0, ans = 0; scanf("%d%d", &amp;totOptn, &amp;maxm); while (totOptn--) &#123; scanf("%s%d", opt, &amp;t); switch (*opt) &#123; case 'A': _1 &amp;= t; _0 &amp;= t; break; case 'O': _1 |= t; _0 |= t; break; case 'X': _1 ^= t; _0 ^= t; break; default: puts("UKE!"); assert(false); break; &#125; &#125; for (int i = 31; i &gt;= 0; i--) if (_0 &gt;&gt; i &amp; 1) ans |= (1LL &lt;&lt; i); else if ((_1 &gt;&gt; i &amp; 1) &amp;&amp; (1LL &lt;&lt; i) &lt;= maxm) ans |= (1LL &lt;&lt; i), maxm -= (1LL &lt;&lt; i); printf("%d\n", ans); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】POI2008 BLO-Blockade]]></title>
    <url>%2F2019%2F01%2F30%2FPOI2008-BLO-Blockade%2F</url>
    <content type="text"><![CDATA[题目在这里.(LG) 假定有 $n$ 个结点，分别考虑每一个结点，如果当前结点不是整张图的割点，那么答案显然是 $2(n-1)$. 如果是割点，那么假定去掉了这个割点之后图被分成了 $k$ 个联通块，其中第 $i$ 个包含 $cnt_i$ 个结点。由这个结点出发或到达这个结点有 $2(n-1)$ 的贡献，经过这个结点则有 \sum_{i=1}^k\sum_{j\not=i,j\in[1,k]}cnt_i\times cnt_j利用 Tarjan 求出割点，同时统计答案，可以在 $O(N)$ 的时间复杂度内解决这道题目。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 100000 + 500;std::vector&lt;int&gt; G[MAXN];long long siz[MAXN], ans[MAXN];int dfs_clock = 1, dfn[MAXN], low[MAXN], S; bool is_cutpoint[MAXN];void Tarjan(const int&amp; nowAt) &#123; int ch = 0, sum = 0; low[nowAt] = dfn[nowAt] = dfs_clock++; siz[nowAt] = 1; for(const auto &amp;it:G[nowAt]) if (dfn[it] == -1) &#123; Tarjan(it); siz[nowAt] += siz[it]; low[nowAt] = std::min(low[nowAt], low[it]); if (low[it] &gt;= dfn[nowAt]) &#123; ans[nowAt] += siz[it] * (S - siz[it]); sum += siz[it]; ch++; if (nowAt != 1 || ch &gt; 1)is_cutpoint[nowAt] = true; &#125; &#125; else &#123; low[nowAt] = std::min(low[nowAt], dfn[it]); &#125; if (is_cutpoint[nowAt])ans[nowAt] += (long long)(S - sum - 1)*(long long)(sum + 1); else ans[nowAt] = S - 1;&#125;signed main(void)&#123; memset(dfn, -1, sizeof(dfn)); int totCity, totRoad, fr, to; scanf("%d%d", &amp;totCity, &amp;totRoad); S = totCity; for (int i = 0; i &lt; totRoad; i++) &#123; scanf("%d%d", &amp;fr, &amp;to); G[fr].push_back(to); G[to].push_back(fr); &#125; Tarjan(1); for (int i = 1; i &lt;= totCity; i++) printf("%lld\n", ans[i] + (S - 1)); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无向图的割点与割边]]></title>
    <url>%2F2019%2F01%2F30%2F%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%89%B2%E7%82%B9%E4%B8%8E%E5%89%B2%E8%BE%B9%2F</url>
    <content type="text"><![CDATA[123456789101112131415void Tarjan(const int&amp; nowAt) &#123; int ch = 0; low[nowAt] = dfn[nowAt] = dfs_clock++; for(const auto &amp;it:G[nowAt]) if (dfn[it] == -1) &#123; Tarjan(it); low[nowAt] = std::min(low[nowAt], low[it]); if (low[it] &gt;= dfn[nowAt]) &#123; ch++; if (nowAt != 1 || ch &gt; 1)is_cutpoint[nowAt] = true; &#125; &#125; else &#123; low[nowAt] = std::min(low[nowAt], dfn[it]); &#125;&#125; 123456789101112131415void Tarjan(const int&amp; nowAt) &#123; int ch = 0; low[nowAt] = dfn[nowAt] = dfs_clock++; for(const auto &amp;it:G[nowAt]) if (dfn[it] == -1) &#123; Tarjan(it); low[nowAt] = std::min(low[nowAt], low[it]); if (low[it] &gt; dfn[nowAt]) &#123; ch++; if (nowAt != 1 || ch &gt; 1)is_cutpoint[nowAt] = true; &#125; &#125; else &#123; low[nowAt] = std::min(low[nowAt], dfn[it]); &#125;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SDOI2008 洞穴勘测]]></title>
    <url>%2F2019%2F01%2F28%2FSDOI2008-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[动态树模板题。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 10000 + 500;constexpr auto MAXM = 200000 + 500;struct Node &#123; bool _rev; Node *fa, *ch[2]; Node() &#123; _rev = false; fa = ch[1] = ch[0] = nullptr; &#125; Node&amp; Reverse() &#123; _rev ^= 1; return *this; &#125; Node&amp; Push_Down() &#123; if (_rev) &#123; _rev = false; for (int i = 0; i &lt; 2; i++) if (ch[i] != nullptr)ch[i]-&gt;_rev ^= 1; std::swap(ch[0], ch[1]); &#125;return *this; &#125; bool IsRoot() &#123; return fa == nullptr || (fa-&gt;ch[0] != this&amp;&amp;fa-&gt;ch[1] != this); &#125;&#125;;Node cave[MAXN];#define Pos(x) ((x)-cave)void Rotate(Node* targ) &#123; const int p = targ-&gt;fa-&gt;ch[0] == targ ? 1 : 0; Node* faa = targ-&gt;fa; if (!faa-&gt;IsRoot())faa-&gt;fa-&gt;ch[faa-&gt;fa-&gt;ch[1] == faa] = targ; faa-&gt;ch[p ^ 1] = targ-&gt;ch[p]; if (targ-&gt;ch[p] != nullptr)targ-&gt;ch[p]-&gt;fa = faa; targ-&gt;ch[p] = faa; targ-&gt;fa = faa-&gt;fa; faa-&gt;fa = targ;&#125;std::stack&lt;Node*&gt;S;void Spaly(Node* targ) &#123; S.push(targ); for (Node* u = targ; !u-&gt;IsRoot();)S.push(u = u-&gt;fa); while (!S.empty()) &#123; S.top()-&gt;Push_Down(); S.pop(); &#125; while (!targ-&gt;IsRoot())Rotate(targ);&#125;void Access(Node* targ) &#123; for (Node* y = nullptr; targ != nullptr; targ = targ-&gt;fa) &#123; Spaly(targ); targ-&gt;ch[1] = y; y = targ; &#125;&#125;void Make_Root(Node* targ) &#123; Access(targ); Spaly(targ); targ-&gt;Reverse();&#125;Node* Find_Root(Node* targ) &#123; Access(targ); Spaly(targ); for (targ-&gt;Push_Down(); targ-&gt;ch[0] != nullptr; targ-&gt;Push_Down()) targ = targ-&gt;ch[0]; return targ;&#125;void Split(Node* x, Node* y) &#123; Make_Root(x); Access(y); Spaly(y);&#125;void Link(Node* x, Node* y) &#123; Make_Root(x); if (Find_Root(y) != x)x-&gt;fa = y;&#125;void Cut(Node* x, Node* y) &#123; Make_Root(x); if (Find_Root(y) != x || x-&gt;ch[1] != nullptr || x-&gt;fa != y)return; else x-&gt;fa = y-&gt;ch[0] = nullptr;&#125;bool LINE(Node* x, Node* y) &#123; Make_Root(x); return Find_Root(y) == x;&#125;signed main(void)&#123; int totCave, totOptn, a, b; char opt[10]; scanf("%d%d", &amp;totCave, &amp;totOptn); while (totOptn--) &#123; scanf("%s%d%d", opt, &amp;a, &amp;b); switch (*opt) &#123; case 'C': Link(cave + a, cave + b); break; case 'D': Cut(cave + a, cave + b); break; case 'Q': puts(LINE(cave + a, cave + b) ? "Yes" : "No"); break; default: puts("Error"); assert(false); break; &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】小Z的袜子]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;#define sqr(x) ((x)*(x))constexpr auto MAXN = 50000 + 500;template&lt;typename T&gt;T gcd(T a, T b) &#123; return b == 0 ? a : gcd(b, a%b);&#125;struct Query &#123; int fr, to, blk, ID; long long up, down; Query()&#123;&#125; Query(const int &amp;ifr, const int &amp;ito) : fr(ifr),to(ito) &#123; blk = sqrt(ifr); &#125; Query&amp; Solve(const long long &amp;iup) &#123; up = iup; down = 1LL * (to - fr + 1)*(to - fr); if (fr == to) &#123; up = 0; down = 1; return *this; &#125; if (up == 0) &#123; down = 1; return *this; &#125; long long GCD = gcd(up, down); up /= GCD; down /= GCD; return *this; &#125; bool operator &lt; (const Query&amp; comp)const &#123; return blk &lt; comp.blk || (blk == comp.blk&amp;&amp;to &lt; comp.to); &#125;&#125;qut[MAXN];int num[MAXN];long long aptime[MAXN];#define Calc(x) (sqr(aptime[(x)]) - aptime[(x)])signed main(void)&#123; int totNums, totQuery, fr, to; scanf("%d%d", &amp;totNums, &amp;totQuery); for (int i = 0; i &lt; totNums; i++)scanf("%d", num + i); for (int i = 0; i &lt; totQuery; i++) &#123; scanf("%d%d", &amp;fr, &amp;to); assert(fr &lt;= to); qut[i] = Query(fr - 1, to - 1); qut[i].ID = i; &#125;std::sort(qut, qut + totQuery); int nowBlk = INT_MIN; long long up = 0; fr = 1; to = 0; for (int now = 0; now &lt; totQuery; now++) &#123; auto &amp;it = qut[now]; /*if (it.blk != nowBlk) &#123; memset(aptime, 0, sizeof(aptime)); nowBlk = it.blk; fr = it.fr; to = it.to; up = 0; for (int i = fr; i &lt;= to; i++) &#123; up -= Calc(num[i]); aptime[num[i]]++; up += Calc(num[i]); &#125;it.Solve(up); continue; &#125;*/ while (fr &lt; it.fr) &#123; up -= Calc(num[fr]); aptime[num[fr]]--; up += Calc(num[fr]); ++fr; &#125; while (fr &gt; it.fr) &#123; --fr; up -= Calc(num[fr]); aptime[num[fr]]++; up += Calc(num[fr]); &#125; while (to &lt; it.to) &#123; ++to; up -= Calc(num[to]); aptime[num[to]]++; up += Calc(num[to]); &#125; while (to &gt; it.to) &#123; up -= Calc(num[to]); aptime[num[to]]--; up += Calc(num[to]); --to; &#125; it.Solve(up); &#125; std::sort(qut, qut + totQuery, [](const Query&amp; a, const Query&amp; comp) &#123;return a.ID &lt; comp.ID; &#125;); for (int i = 0; i &lt; totQuery; i++) &#123; if (qut[i].up == 0) printf("0/1\n"); else printf("%lld/%lld\n", qut[i].up, qut[i].down); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三维偏序]]></title>
    <url>%2F2019%2F01%2F27%2F%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[三维偏序是一种问题。给定 $n$ 个三维坐标系中的点，第 $i$ 个形如 $(x_i,y_i,z_i)$, 记 $f(i)=\sum_{j\not=i}[x_j\leq x_i][y_j\leq y_i][z_j\leq z_i]$. 现在需要求出对于所有 $d\in[0,n)$, $f(i)=d$ 的数量。 LG题目地址. K-Dtree这道题目中，我们先考虑满足 $x_j\leq x_i$, 对第一维排序，此时位置靠后的元素是无法对位置相对靠前的元素产生贡献的，所以我们依次扫过去，求出每一个 $f(i)$, 这时问题就变成了二维的。每一次先在二维平面内查询一下 $(0,0),(y,z)$ 中点的个数，然后在 $(y,z)$ 处放置一个点。 求完了所有的 $f(i)$, 这个时候再来统计 $d$ 就很容易了。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;template&lt;typename T&gt;struct Vector2 &#123; T x, y; Vector2()&#123;&#125; Vector2(const T&amp; ix,const T&amp; iy) : x(ix),y(iy)&#123;&#125; Vector2&amp; MinMerge(const Vector2&lt;T&gt;&amp; mg) &#123; x = std::min(x, mg.x); y = std::min(y, mg.y); return *this; &#125; Vector2&amp; MaxMerge(const Vector2&lt;T&gt;&amp; mg) &#123; x = std::max(x, mg.x); y = std::max(y, mg.y); return *this; &#125; bool operator == (const Vector2&lt;T&gt;&amp; comp)const &#123; return x == comp.x&amp;&amp;y == comp.y; &#125; bool operator &lt;= (const Vector2&lt;T&gt;&amp; comp)const &#123; return x &lt;= comp.x&amp;&amp;y &lt;= comp.y; &#125; bool operator &gt;= (const Vector2&lt;T&gt;&amp; comp)const &#123; return x &gt;= comp.x&amp;&amp;y &gt;= comp.y; &#125;&#125;;constexpr auto Alpha = .65;constexpr auto MAXN = 100000 + 500;struct Node &#123; Vector2&lt;int&gt; pos, ld, rt; int val, sum, siz; Node *lft, *rgt; Node() &#123; lft = rgt = nullptr; siz = 1; &#125; Node&amp; Refresh(void) &#123; ld = rt = pos; sum = val; siz = 1; if (lft != nullptr) &#123; siz += lft-&gt;siz; sum += lft-&gt;sum; ld.MinMerge(lft-&gt;ld); rt.MaxMerge(lft-&gt;rt); &#125;if (rgt != nullptr) &#123; siz += rgt-&gt;siz; sum += rgt-&gt;sum; ld.MinMerge(rgt-&gt;ld); rt.MaxMerge(rgt-&gt;rt); &#125;return *this; &#125; int Maxch(void) &#123; int ret = 0; if (lft != nullptr)ret = std::max(ret, lft-&gt;siz); if (rgt != nullptr)ret = std::max(ret, rgt-&gt;siz); return ret; &#125;&#125;*root = nullptr;std::vector&lt;Node*&gt; arr;Node* Rebuild(const int &amp;fr, const int &amp;to, const bool &amp;book) &#123; if (fr &lt; to) &#123; int mid = (fr + to) &gt;&gt; 1; if (book) std::nth_element(arr.begin() + fr, arr.begin() + mid, arr.begin() + to, [](const Node* a, const Node* comp) &#123;return a-&gt;pos.x &lt; comp-&gt;pos.x; &#125;); else std::nth_element(arr.begin() + fr, arr.begin() + mid, arr.begin() + to, [](const Node* a, const Node* comp) &#123;return a-&gt;pos.y &lt; comp-&gt;pos.y; &#125;); Node* ret = arr[mid]; ret-&gt;lft = Rebuild(fr, mid, !book); ret-&gt;rgt = Rebuild(mid + 1, to, !book); ret-&gt;Refresh(); return ret; &#125; else return nullptr;&#125;void dfs(Node* nowAt) &#123; arr.push_back(nowAt); if (nowAt-&gt;lft != nullptr)dfs(nowAt-&gt;lft); if (nowAt-&gt;rgt != nullptr)dfs(nowAt-&gt;rgt);&#125;Node* Check(Node* targ, const bool &amp;book) &#123; if (targ-&gt;siz*Alpha &lt; targ-&gt;Maxch()) &#123; dfs(targ); targ = Rebuild(0, arr.size(), !book); &#123;std::vector&lt;Node*&gt;T; std::swap(arr, T); &#125; return targ; &#125;return targ;&#125;Node* Attend(const Vector2&lt;int&gt;&amp; pos, const int &amp;val, const bool &amp;book, Node* nowAt = root) &#123; if (nowAt == nullptr) &#123; nowAt = new Node(); nowAt-&gt;val = val; nowAt-&gt;pos = pos; nowAt-&gt;Refresh(); return nowAt; &#125; if (nowAt-&gt;pos == pos) nowAt-&gt;val += val; else &#123; if ((book&amp;&amp;nowAt-&gt;pos.x &lt; pos.x) || (!book&amp;&amp;nowAt-&gt;pos.y &lt; pos.y)) nowAt-&gt;lft = Attend(pos, val, !book, nowAt-&gt;lft); else nowAt-&gt;rgt = Attend(pos, val, !book, nowAt-&gt;rgt); &#125; nowAt-&gt;Refresh(); return (nowAt = Check(nowAt, book));&#125;int Query(const Vector2&lt;int&gt;&amp; ld, const Vector2&lt;int&gt;&amp; rt, const bool &amp;book, Node *nowAt = root) &#123; if (nowAt == nullptr)return 0; if (nowAt-&gt;ld &gt;= ld &amp;&amp; nowAt-&gt;rt &lt;= rt)return nowAt-&gt;sum; if (nowAt-&gt;ld.x &gt; rt.x || nowAt-&gt;rt.x&lt;ld.x || nowAt-&gt;ld.y&gt;rt.y || nowAt-&gt;rt.y &lt; ld.y)return 0; return Query(ld, rt, !book, nowAt-&gt;lft) + Query(ld, rt, !book, nowAt-&gt;rgt) + ((ld.x &lt;= nowAt-&gt;pos.x&amp;&amp;nowAt-&gt;pos.x &lt;= rt.x &amp;&amp; ld.y &lt;= nowAt-&gt;pos.y&amp;&amp;nowAt-&gt;pos.y &lt;= rt.y) ? nowAt-&gt;val : 0);&#125;struct Data &#123; int t, x, y; Data()&#123;&#125; Data(const int &amp;it,const int &amp;ix,const int &amp;iy) : t(it),x(ix),y(iy)&#123;&#125; bool operator &lt; (const Data&amp; comp)const &#123; return t &lt; comp.t; &#125;&#125;que[MAXN];bool inTree[MAXN];int ans[MAXN];signed main(void)&#123; int totNums, N, t, x, y; scanf("%d%d", &amp;totNums, &amp;N); que[totNums] = Data(INT_MAX, 0, 0); for (int i = 0; i &lt; totNums; i++) &#123; scanf("%d%d%d", &amp;t, &amp;x, &amp;y); que[i] = Data(t, x, y); &#125; std::sort(que, que + totNums + 1); for (int i = 0; i &lt; totNums; i++) &#123; if (!inTree[i]) &#123; root = Attend(Vector2&lt;int&gt;(que[i].x, que[i].y), 1, true); inTree[i] = true; for (int j = i + 1; que[j].t == que[j - 1].t; j++) &#123; root = Attend(Vector2&lt;int&gt;(que[j].x, que[j].y), 1, true); inTree[j] = true; &#125; &#125;++ans[Query(Vector2&lt;int&gt;(0, 0), Vector2&lt;int&gt;(que[i].x, que[i].y), true) - 1]; &#125; for (int i = 0; i &lt; totNums; i++)printf("%d\n", ans[i]); //system("pause"); return 0;&#125; 虽然这个做法看上去完美，但是时间复杂度令人难以忍受，因此需要采取别的方法。 CDQ分治这是可以很好地解决这道题目的一种算法。 跟之前一样，将第一维作为第一关键字，第二维作为第二关键字，以此类推来排序。这样就可以降维成一个二维问题。接着，对第二维进行从大到小的归并排序，假定目前排序区间是 $[fr,to)$, 其中 $[fr,mid)$ 记为 $h_1$ 和 $[mid,to)$ 记为 $h_2$ 已经有序。去掉第一维不看，现在我们操作的对象就是一堆形如 $(y,z)$ 的二元组。 需要注意的是，此时相对靠后的元素 $x$ 坐标一定不小于相对靠前元素的 $x$ 坐标，考虑 $h_1$ 中元素对 $h_2$ 中元素的贡献。如果对于某一个时刻， $h_1$ 中的元素取了 $[fr,hd_1)$, $h_2$ 中的元素取了 $[mid,hd_2)$, 这时如果 $hd_{2_y}&gt;hd_{1_y}$, 那么 $[fr,hd_1)$ 这些元素中 $z$ 坐标小于 $hd_{2_z}$ 的都可以对 $hd_2$ 产生一点贡献，我们可以用一个树状数组维护前缀和，这样就可以 $O(\log K)$ 进行插入，查询。 当第二次排序将 $y$ 从大到小排好后，所有的贡献也就计算完了，可以统一回答所有询问，总时间复杂度为 $O(N\log M)$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 100000 + 500;constexpr auto MAXM = 200000 + 500;int totNode, maxValue;struct Point &#123; int x, y, z, cnt, ID; bool operator == (const Point&amp; comp)const &#123; return x == comp.x&amp;&amp;y == comp.y&amp;&amp;z == comp.z; &#125; bool operator () (const Point&amp; a, const Point&amp; comp)const &#123; return a.x &lt; comp.x || (a.x == comp.x&amp;&amp;a.y &lt; comp.y) || (a.x == comp.x&amp;&amp;a.y == comp.y&amp;&amp;a.z &lt; comp.z); &#125;&#125;arr[MAXN],temp[MAXN];std::stack&lt;std::pair&lt;int, int&gt;&gt; S;int numAt[MAXM];#define Lowbit(x) ((-(x))&amp;(x))void Add(const int &amp;pos, const int &amp;val) &#123; for (int i = pos; i &lt;= maxValue; i += Lowbit(i))numAt[i] += val;&#125;int Query(const int &amp;pos) &#123; int sum = 0; for (int i = pos; i &gt; 0; i -= Lowbit(i))sum += numAt[i]; return sum;&#125;int f[MAXN], d[MAXN];void Calc(const int &amp;fr, const int &amp;to) &#123; if (to - fr &gt; 1) &#123; int mid = (fr + to) &gt;&gt; 1; Calc(fr, mid); Calc(mid, to); //Merge int hd1 = fr, hd2 = mid; for (int i = fr; i &lt; to; i++) &#123; if (hd1 &lt; mid &amp;&amp; (hd2 &gt;= to || arr[hd1].y &lt;= arr[hd2].y)) &#123; Add(arr[hd1].z, arr[hd1].cnt); S.push(std::make_pair(arr[hd1].z, arr[hd1].cnt)); temp[i] = arr[hd1++]; &#125; else &#123; f[arr[hd2].ID] += Query(arr[hd2].z); temp[i] = arr[hd2++]; &#125; &#125; for (int i = fr; i &lt; to; i++)arr[i] = temp[i]; while (!S.empty()) &#123; const auto it = S.top(); S.pop(); Add(it.first, -it.second); &#125; &#125;&#125;signed main(void)&#123; int totNode; scanf("%d%d", &amp;totNode, &amp;maxValue); for (int i = 0; i &lt; totNode; i++) &#123; scanf("%d%d%d", &amp;arr[i].x, &amp;arr[i].y, &amp;arr[i].z); arr[i].cnt = 1; arr[i].ID = i; &#125;std::sort(arr, arr + totNode, Point()); bool *exist = new bool[totNode]; *exist = true; for (int i = 1; i &lt; totNode; i++) if (arr[i] == arr[i - 1])exist[i] = false; else exist[i] = true; for(int i=0;i&lt;totNode;i++) if (exist[i]) arr[::totNode++] = arr[i]; else arr[::totNode - 1].cnt++; delete[] exist; Calc(0, ::totNode); for (int i = 0; i &lt; ::totNode; i++)f[arr[i].ID] += arr[i].cnt - 1; for (int i = 0; i &lt; ::totNode; i++)d[f[arr[i].ID]] += arr[i].cnt; for (int i = 0; i &lt; totNode; i++)printf("%d\n", d[i]); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
        <tag>K-Dtree</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】简单题]]></title>
    <url>%2F2019%2F01%2F27%2F%E7%AE%80%E5%8D%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这是一道 K-Dtree 的模板题，题目在这里. 首先，这道题目强制在线，而且空间只有 20MB, 因此需要一个优秀的在线算法，甚至这个矩阵都不能渲染。 将一个二元组 $(x,y)$ 作为结点放入 K-Dtree, 代表某一个值不为 0 的点的坐标，同时维护一些额外的信息： val 这个点目前的值 size 子树大小 x_1, y_1, x_2, y_2 所代表矩形的左下和右上点的坐标 sum 代表矩形中所有数的和 这样，我们在 K-Dtree 中可以实现插入和修改，同时像线段树中那样查询，即每到达一个结点，判断这个结点代表的矩形是否完全在目标矩形中，如果是则累加答案，如果完全不包含返回 0，如果交叉则左右递归。 在这道题目中，总时间复杂度为 $O(M\log N)$, 空间复杂度为 $O(M)$, 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;constexpr auto Alpha = .65;struct Node &#123; int y, x, x_1, y_1, x_2, y_2; int val, sum, siz; Node *lft, *rgt; //lft &lt; rgt Node() &#123; lft = rgt = nullptr; siz = 1; &#125; Node&amp; Resize(const int &amp;x, const int &amp;y) &#123; x_1 = std::min(x_1, x); y_1 = std::min(y_1, y); x_2 = std::max(x_2, x); y_2 = std::max(y_2, y); return *this; &#125; Node&amp; Refresh(void) &#123; sum = val; siz = 1; x_1 = x_2 = x; y_1 = y_2 = y; if (lft != nullptr) &#123; sum += lft-&gt;sum; siz += lft-&gt;siz; this-&gt;Resize(lft-&gt;x_1, lft-&gt;y_1); this-&gt;Resize(lft-&gt;x_2, lft-&gt;y_2); &#125; if (rgt != nullptr) &#123; sum += rgt-&gt;sum; siz += rgt-&gt;siz; this-&gt;Resize(rgt-&gt;x_1, rgt-&gt;y_1); this-&gt;Resize(rgt-&gt;x_2, rgt-&gt;y_2); &#125; return *this; &#125; int Maxch(void) &#123; int ret = 0; if (lft != nullptr)ret = std::max(ret, lft-&gt;siz); if (rgt != nullptr)ret = std::max(ret, rgt-&gt;siz); return ret; &#125;&#125;*root = nullptr;//重构std::vector&lt;Node*&gt; arr;Node* Build(const int &amp;fr, const int &amp;to, const bool &amp;book) &#123; if (fr &lt; to) &#123; int mid = (fr + to) &gt;&gt; 1; if (book) std::nth_element(arr.begin()+fr, arr.begin() + mid, arr.begin()+to, [](const Node* a, const Node* comp) &#123;return a-&gt;x &lt; comp-&gt;x; &#125;); else std::nth_element(arr.begin()+fr, arr.begin() + mid, arr.begin()+to, [](const Node* a, const Node* comp) &#123;return a-&gt;y &lt; comp-&gt;y; &#125;); Node* ret = arr[mid]; ret-&gt;lft = Build(fr, mid, !book); ret-&gt;rgt = Build(mid + 1, to, !book); ret-&gt;Refresh(); return ret; &#125; else return nullptr;&#125;void dfs(Node* nowAt) &#123; arr.push_back(nowAt); if (nowAt-&gt;lft != nullptr)dfs(nowAt-&gt;lft); if (nowAt-&gt;rgt != nullptr)dfs(nowAt-&gt;rgt);&#125;Node* Check(Node* targ, const bool&amp; book) &#123; if (targ-&gt;siz*Alpha &lt; targ-&gt;Maxch()) &#123; //重建 &#123; std::vector&lt;Node*&gt;T; std::swap(T, arr); &#125; dfs(targ); targ = Build(0, arr.size(), book); &#125;return targ;&#125;bool book; //是否为 | 分割 左&lt;右 下&lt;上Node* Attend(Node* nowAt,const int &amp;y,const int &amp;x,const int &amp;a, const bool book) &#123; if (nowAt == nullptr) &#123; nowAt = new Node(); nowAt-&gt;x = nowAt-&gt;x_1 = nowAt-&gt;x_2 = x; nowAt-&gt;y = nowAt-&gt;y_1 = nowAt-&gt;y_2 = y; nowAt-&gt;val = nowAt-&gt;sum = a; return nowAt; &#125; if (nowAt-&gt;y == y&amp;&amp;nowAt-&gt;x == x)nowAt-&gt;val += a; else &#123; if ((book &amp;&amp; x &lt; nowAt-&gt;x) || (!book &amp;&amp; y &lt; nowAt-&gt;y)) //Lft nowAt-&gt;lft = Attend(nowAt-&gt;lft, y, x, a, !book); else nowAt-&gt;rgt = Attend(nowAt-&gt;rgt, y, x, a, !book); &#125;nowAt-&gt;Refresh(); nowAt = Check(nowAt, book); return nowAt;&#125;#define Between(a,x,b) (((a)&lt;=(x))&amp;&amp;((x)&lt;=(b)))int Query(const int&amp; x_1, const int &amp;y_1, const int &amp;x_2, const int &amp;y_2, Node* nowAt, const bool book) &#123; if (nowAt == nullptr)return 0; if (Between(x_1, nowAt-&gt;x_1, x_2) &amp;&amp; Between(x_1, nowAt-&gt;x_2, x_2) &amp;&amp; Between(y_1, nowAt-&gt;y_1, y_2) &amp;&amp; Between(y_1, nowAt-&gt;y_2, y_2)) return nowAt-&gt;sum; if (nowAt-&gt;x_1 &gt; x_2 || nowAt-&gt;x_2&lt;x_1 || nowAt-&gt;y_1&gt;y_2 || nowAt-&gt;y_2 &lt; y_1)return 0; int ans; if (book) &#123; ans = Query(x_1, y_1, x_2, y_2, nowAt-&gt;lft, !book) + Query(x_1, y_1, x_2, y_2, nowAt-&gt;rgt, !book); &#125; else &#123; ans = Query(x_1, y_1, x_2, y_2, nowAt-&gt;lft, !book) + Query(x_1, y_1, x_2, y_2, nowAt-&gt;rgt, !book); &#125; return ans + ((x_1 &lt;= nowAt-&gt;x&amp;&amp;nowAt-&gt;x &lt;= x_2 &amp;&amp; y_1 &lt;= nowAt-&gt;y&amp;&amp;nowAt-&gt;y &lt;= y_2) ? nowAt-&gt;val : 0);&#125;signed main(void)&#123; int N, opt, last_ans = 0; int x, y, a, x_1, x_2, y_1, y_2; scanf("%d", &amp;N); while (true) &#123; scanf("%d", &amp;opt); switch (opt) &#123; case 1: scanf("%d%d%d", &amp;x, &amp;y, &amp;a); x ^= last_ans; y ^= last_ans; a ^= last_ans; root = Attend(root, y, x, a, true); break; case 2: scanf("%d%d%d%d", &amp;x_1, &amp;y_1, &amp;x_2, &amp;y_2); x_1 ^= last_ans; y_1 ^= last_ans; x_2 ^= last_ans; y_2 ^= last_ans; if (x_1 &gt; x_2)std::swap(x_1, x_2); if (y_1 &gt; y_2)std::swap(y_1, y_2); printf("%d\n", (last_ans = Query(x_1, y_1, x_2, y_2, root, true))); break; case 3: exit(0); default: puts("UKE"); assert(false); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>K-Dtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF897D Ithea Plays With Chtholly]]></title>
    <url>%2F2019%2F01%2F26%2FCF897D-Ithea-Plays-With-Chtholly%2F</url>
    <content type="text"><![CDATA[这时一道交互题，题目在这里. 这道题目的大致意思是，给定一个一开始全部是空白的数组，然后每一轮给定一个数 $x\in [1,c]$. 你需要在 $n\lceil\frac{c}{2}\rceil$ 轮内使得整个数组成为一个不下降序列。 假定当前时刻数组中第 $i$ 个数为 $a_i$. 由于有 $n\lceil\frac{c}{2}\rceil$ 轮机会，我们每一次接受一个数 $x$, 分为两种情况： 如果 $x&lt;\lceil\frac{c}{2}\rceil$, 那么从前往后寻找到第一个位置 $i$ 使得 $a_i&gt;x$ 或者 $a_i=\varnothing$. 令 $a_i=x$. 如果 $x\ge\lceil\frac{c}{2}\rceil$, 那么从后往前执行这个操作。 如果某一时刻整个数组不存在空白位置，那么退出程序。 首先我们将数组分为左边和右边，前若干轮中间一整块是没有数的，而左右两边显然不降，当中间空白的部分被填补后，整个数组就是不降的，因此这种做法是正确的。 在最坏情况下，数组中每一个位置都会经过 $\lceil\frac{c}{2}\rceil$ 次才最终确定，因为每一次更改都会将它至少增大（减小）1. 而当某一个位置无法增大（减小）时最多需要 $\lceil\frac{c}{2}\rceil$ 轮，因此总轮数最多 $n\lceil\frac{c}{2}\rceil$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;signed main(void)&#123; int totNums, totRounds, C; int num[1200] = &#123;&#125;, _count = 0; scanf("%d%d%d", &amp;totNums, &amp;totRounds, &amp;C); int x; while (_count &lt; totNums) &#123; scanf("%d", &amp;x); if (x &lt;= (C &gt;&gt; 1)) &#123; for (int i = 0; i &lt; totNums; i++) &#123; if (num[i] == 0)_count++; if (num[i] == 0 || num[i] &gt; x) &#123; num[i] = x; printf("%d\n", i + 1); fflush(stdout); break; &#125; &#125; &#125; else &#123; for (int i = totNums - 1; i &gt;= 0; i--) &#123; if (num[i] == 0)_count++; if (num[i] == 0 || num[i] &lt; x) &#123; num[i] = x; printf("%d\n", i + 1); fflush(stdout); break; &#125; &#125; &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SCOI2010 生成字符串]]></title>
    <url>%2F2019%2F01%2F26%2FSCOI2010-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目在这里.(LG) 对于这道题目，可以形象地转换到一个平面内，$x$ 轴代表字符数量，$y$ 轴代表 $\sum[1]-\sum[0]$. 我们需要从 $(0,0)$ 到达 $(n+m,n-m)$, 而且不能经过 $y=-1$. 计算出所有的方案数，再减去经过了 $y=-1$ 的，也就是 \mathbb{C}_{n+m}^n-\mathbb{C}_{n+m}^{m-1}利用逆元，打表阶乘，即可解决。 代码如下： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;constexpr auto MOD = 20100403, MAXN = 3000000;long long arr[MAXN];long long fpow(long long a, long long b, const long long&amp; MOD = ::MOD) &#123; long long ans = 1; for (; b &gt; 0; b &gt;&gt;= 1, (a *= a) %= MOD) if (b &amp; 1)(ans *= a) %= MOD; return ans;&#125;long long C(long long n, long long r, const long long&amp; MOD = ::MOD) &#123; long long n_r = arr[n - r]; n = arr[n]; r = arr[r]; return n * fpow(r*n_r%MOD, MOD - 2) % MOD;&#125;signed main(void)&#123; int n, m, siz; scanf("%d%d", &amp;n, &amp;m); siz = n + m + 5; arr[1] = 1; for (int i = 2; i &lt; siz; i++) arr[i] = (arr[i - 1] * i) % MOD; printf("%lld\n", ((C(n + m, n) - C(n + m, m - 1)) % MOD + MOD) % MOD); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】跑路]]></title>
    <url>%2F2019%2F01%2F25%2F%E8%B7%91%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[题目在这里(LG) 对于这道题目，我们需要求出一个数组 $dis_{i\to j} = t$ 代表从 $i$ 到 $j$ 需要 $t$ 单位的时间。由于每一秒移动的距离是 $2^k$, 所以我们先求出所有的 $dis=1$, 然后又因为一定有一条路从 1 到 $n$, 所以直接 Floyd 即可得到答案。 求出 $dis=1$ 需要用到动态规划的思想，定义 $D_{i,j,k}$ 代表 $i\to j$ 是否存在一条距离为 $2^k$ 的路径。状态转移方程为 D_{i,j,k}=D_{i,u,k-1}|D_{u,j,k-1} 这样总时间复杂度为 $O(\log (\texttt{MaxLongInt})N^3)$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;const int MAXN=60;int dis[MAXN][MAXN];bool D[MAXN][MAXN][70];signed main(void)&#123; for(int i=0;i&lt;MAXN;i++)for(int j=0;j&lt;MAXN;j++)dis[i][j]=10000; memset(D,false,sizeof(D)); int totNode,totRoad; int fr,to; scanf("%d%d",&amp;totNode,&amp;totRoad); for(int i=0;i&lt;totRoad;i++)&#123; scanf("%d%d",&amp;fr,&amp;to); dis[fr][to] = 1; D[fr][to][0] = true; &#125; //Dp for(int base=1;base&lt;=64;base++) for(int vis=1;vis&lt;=totNode;vis++) for(int fr=1;fr&lt;=totNode;fr++) for(int to=1;to&lt;=totNode;to++) if(D[fr][vis][base-1] &amp;&amp; D[vis][to][base-1])&#123; D[fr][to][base]=true; dis[fr][to]=1; &#125; //Floyd for(int vis=1;vis&lt;=totNode;vis++) for(int fr=1;fr&lt;=totNode;fr++) for(int to=1;to&lt;=totNode;to++) if(dis[fr][vis]+dis[vis][to]&lt;dis[fr][to]) dis[fr][to]=dis[fr][vis]+dis[vis][to]; printf("%d\n",dis[1][totNode]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>动态规划</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】聪聪可可]]></title>
    <url>%2F2019%2F01%2F24%2F%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%2F</url>
    <content type="text"><![CDATA[题目在这里.(LG) 在这道题目中，如果我们点分治过程中位于一棵子树，它的根是 $r$, 我们假定已经考虑过了的儿子所有路径长度 $\mod 3$ 之后余 $0,1,2$ 的路径条数分别有 $rem_0,rem_1,rem_2$ 条，现在我们在考虑 $r$ 的一个儿子 $u$. 首先还是求出 $u$ 的后代到 $r$ 的所有路径长，并将他们$\mod 3$, 假定余 $0,1,2$ 的路径分别有 $add_0,add_1,add_2$ 条，那么 $u$ 对于答案的贡献就是 (rem_2\times add_1+rem_1\times add_2+add_0+add_0\times rem_0)\times 21total += rem[2] * add[1] + rem[1] * add[2] + *add + *add**rem &lt;&lt; 1; 按照这个原理计数，时间复杂度为 $O(N)$, 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define sqr(x) ((x)*(x))constexpr auto MAXN = 20000 + 50;constexpr auto MOD = 3;struct LINE &#123; int to, val; LINE(const int &amp;ito, const int &amp;ival) &#123; to = ito; val = ival % MOD; &#125;&#125;;std::vector&lt;LINE&gt;G[MAXN];bool vis[MAXN];int root, mx[MAXN], siz[MAXN], S;void Find(const int &amp;nowAt, const int &amp;fa = 0) &#123; mx[nowAt] = 0; siz[nowAt] = 1; for(const auto &amp;it:G[nowAt]) if (!vis[it.to] &amp;&amp; it.to != fa) &#123; Find(it.to, nowAt); siz[nowAt] += siz[it.to]; mx[nowAt] = std::max(mx[nowAt], siz[it.to]); &#125; mx[nowAt] = std::max(mx[nowAt], S - siz[nowAt]); if (mx[nowAt] &lt; mx[root])root = nowAt;&#125;int rem[3], add[3], total;void Get_Dis(const int &amp;nowAt, const int &amp;fa, const int &amp;len) &#123; for (const auto &amp;it : G[nowAt]) if (it.to != fa &amp;&amp; !vis[it.to]) &#123; add[(len + it.val) % MOD]++; Get_Dis(it.to, nowAt, (len + it.val) % MOD); &#125;&#125;void Calc(const int &amp;nowAt) &#123; memset(rem, 0, sizeof(rem)); for (const auto &amp;it : G[nowAt]) if (!vis[it.to]) &#123; memset(add, 0, sizeof(add)); add[it.val%MOD]++; Get_Dis(it.to, nowAt, it.val); total += rem[2] * add[1] + rem[1] * add[2] + *add + *add**rem &lt;&lt; 1; for (int i = 0; i &lt; 3; i++)rem[i] += add[i]; &#125;&#125;void Divide(const int &amp;nowAt) &#123; vis[nowAt] = true; Calc(nowAt); for (const auto &amp;it : G[nowAt]) if (!vis[it.to]) &#123; S = siz[it.to]; mx[root = 0] = INT_MAX; Find(it.to); Divide(root); &#125;&#125;template&lt;typename T&gt;T GCD(const T&amp; a, const T&amp; b) &#123; return b == 0 ? a : GCD(b, a%b); &#125;signed main(void)&#123; int totNode, fr, to, val; scanf("%d", &amp;totNode); for (int i = 1; i &lt; totNode; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;val); G[fr].push_back(LINE(to, val)); G[to].push_back(LINE(fr, val)); &#125; mx[root = 0] = INT_MAX; S = totNode; Find(1); Divide(root); total += totNode; int div, power = sqr(totNode); while ((div = GCD(total, power)) != 1) &#123; total /= div; power /= div; &#125; printf("%d/%d\n", total, power); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】点分治]]></title>
    <url>%2F2019%2F01%2F22%2FLG%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[这是一道点分治的模板题目，LG地址在这里。 在这道题目中，给定一个整数组成的序列，我们需要查询一颗带边权的树上是否出现这些权值的路径。 在点分治的统计过程中，我们假定当前考虑的根结点为 $r$, 现在我们正在统计 $r$ 的一个儿子 $u$. 首先我们计算出以 $u$ 为根的子树所有结点到达 $u$ 的权值之和，假定 $u$ 有 $cnt_u$ 个后代，第 $i$ 个后代到达 $r$ 的权值之和为 $val_{i\to r}$. 我们枚举 $i$ 为 $u$ 的一个后代，$j$ 为某一个询问 $qry_j$ 长度的路径是否存在。假定 $v$ 为之前已经考虑过了的 $r$ 的一个儿子，一个集合 $A=\{val_{t\to r}|t\ \mbox{为}\ v\ \mbox{的后代}\}$. 如果 $qry_j-val_{i\to r}\in A$, 那么标记这个询问的答案是存在。开始考虑 $r$ 的下一个儿子之前，将之前得到的 $val$ 添加到 $A$ 中。 如果询问个数为 $T$, 那么总时间复杂度为 $O(NT\log N)$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 10000 + 500;constexpr auto MAXM = 100 + 5;struct LINE &#123; int to, val; LINE(const int &amp;ito, const int &amp;ival) &#123; to = ito; val = ival; &#125;&#125;;std::vector&lt;LINE&gt;G[MAXN];bool vis[MAXN], test[MAXM];int totQuery, totNode, query[MAXM];int root, siz[MAXN], mx[MAXN], S;void Find(const int &amp;nowAt, const int &amp;fa) &#123; siz[nowAt] = 1; mx[nowAt] = 0; for (const auto &amp;it : G[nowAt]) if (it.to != fa &amp;&amp; (!vis[it.to])) &#123; Find(it.to, nowAt); siz[nowAt] += siz[it.to]; mx[nowAt] = std::max(mx[nowAt], siz[it.to]); &#125; mx[nowAt] = std::max(mx[nowAt], S - siz[nowAt]); if (mx[nowAt] &lt; mx[root])root = nowAt;&#125;bool judge[10000005];int _count, dis[MAXN], rem[MAXN], q[MAXN];void Get_Dist(const int &amp;nowAt, const int &amp;fa) &#123; rem[_count++] = dis[nowAt]; for (const auto &amp;it : G[nowAt]) if (it.to != fa &amp;&amp; (!vis[it.to])) &#123; dis[it.to] = dis[nowAt] + it.val; Get_Dist(it.to, nowAt); &#125;&#125;void Calc(const int &amp;nowAt) &#123; int cnt = 0; for (const auto &amp;it : G[nowAt]) if (!vis[it.to]) &#123; _count = 0; dis[it.to] = it.val; Get_Dist(it.to, nowAt); for (int i = 0; i &lt; totQuery; i++) for (int j = 0; j &lt; _count; j++) if (rem[j] &lt;= query[i]) test[i] |= judge[query[i] - rem[j]]; for (int i = 0; i &lt; _count; i++) &#123; q[cnt++] = rem[i]; judge[rem[i]] = true; &#125; &#125; while (cnt--)judge[q[cnt]] = false;&#125;void Divide(const int &amp;nowAt) &#123; *judge = vis[nowAt] = true; Calc(nowAt); for (const auto &amp;it : G[nowAt]) if (!vis[it.to]) &#123; S = siz[it.to]; mx[root = 0] = INT_MAX; Find(it.to, 0); Divide(root); &#125;&#125;signed main(void)&#123; int fr, to, val; scanf("%d%d", &amp;totNode, &amp;totQuery); for (int i = 1; i &lt; totNode; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;val); G[fr].push_back(LINE(to, val)); G[to].push_back(LINE(fr, val)); &#125; for (int i = 0; i &lt; totQuery; i++)scanf("%d", query + i); memset(vis, false, sizeof(vis)); memset(judge, false, sizeof(judge)); memset(test, false, sizeof(test)); mx[root = 0] = INT_MAX; S = totNode; Find(1, 0); Divide(root); for (int i = 0; i &lt; totQuery; i++) puts(test[i] ? "AYE" : "NAY"); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点分治]]></title>
    <url>%2F2019%2F01%2F22%2F%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[点分治是用于树上静态统计的一种思想。 例如，如果我们需要统计一棵树上满足某种条件的简单路径是否存在或者存在多少条，我们可以将这棵树转换为一颗有根树，将路径分为两类 经过根结点 不经过根结点 对于经过根结点的路径，首先先选择该根结点 $r$ 的一个儿子 $u$ ，假定这条路径有一个顶点在这颗子树中。dfs 一遍求出 $u$ 所有的儿子到 $u$ 的权值，然后枚举询问和所有 $u$ 的儿子，查找剩下的那一部分权值是否在 $r$ 之前某一个已经考虑过了的子树中标记，即是否存在 $r$ 的另一个儿子 $v$, 使得 $v\to r+r\to u=query$ 。将找到的答案标记，然后统一输出即可。 对于第二类直接递归求解。将已经考虑过的根结点打上标记，代表它已经被删除，然后使用同样的方法处理它所有的子树。 在选择一个无根树的根的时候，应该选择它的重心，这样每一次递归子树的规模都会缩小一半，以限制 $\log N$ 层递归，确保 $O(N\log N)$ 的点分治时间复杂度。 求一棵树的重心可以使用动态规划的思想，时间复杂度为 $O(N)$. 123456789101112int root, siz[MAXN], mx[MAXN], S;void Find(const int &amp;nowAt, const int &amp;fa) &#123; siz[nowAt] = 1; mx[nowAt] = 0; for (const auto &amp;it : G[nowAt]) if (it.to != fa &amp;&amp; (!vis[it.to])) &#123; Find(it.to, nowAt); siz[nowAt] += siz[it.to]; mx[nowAt] = std::max(mx[nowAt], siz[it.to]); &#125; mx[nowAt] = std::max(mx[nowAt], S - siz[nowAt]); if (mx[nowAt] &lt; mx[root])root = nowAt;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】NOI2010 超级钢琴]]></title>
    <url>%2F2019%2F01%2F21%2FNOI2010-%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4%2F</url>
    <content type="text"><![CDATA[题目在这里.(LG) 这道题目的大致意思是，给定一个序列 $a$, 你需要求出它最大的 $k$ 个长度介于 $[L,R]$ 之间的子序列的所有元素之和。 记 $s_i=\sum_{i=1}^ia_i$. 对于一个三元组 $(l,L,R)$ 描述一个候选区间的左端点为 $l$, 右端点必须在 $[L,R]$ 之间。这时对于这个区间根据贪心的思想我们应该选择一个最大的 $a_i\ (i\in[L,R])$. 然后它对于答案的贡献就是 $s_{a_i}-s_{l-1}$. 之后为了不重复选择，需要添加两个区间到达候选的队列中： $(l,L,a_i-1)$ $(l,a_i+1,R)$ 每一次从候选队列中选择一个对答案最大的，重复上面的操作 $k$ 次。使用优先队列可以在对数级别的复杂度内维护这个候选队列。 总时间复杂度为 $O((N+K)\log N)$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 500000 + 500;int table[MAXN][20]; long long sum[MAXN];int Query(const int &amp;fr, const int &amp;to) &#123; int k = log2(to - fr + 1), x = table[fr][k], y = table[to - (1 &lt;&lt; k) + 1][k]; return sum[x] &gt; sum[y] ? x : y;&#125;struct Node &#123; int l, rb, re, t, val; Node() &#123;&#125; Node(const int &amp;il, const int &amp;irb, const int &amp;ire) : l(il), rb(irb), re(ire),t(Query(irb,ire)),val(sum[t]-sum[l-1]) &#123;&#125; friend bool operator &gt; (const Node&amp; a, const Node&amp; comp) &#123; return a.val &lt; comp.val; &#125;&#125;;std::priority_queue&lt;Node, std::vector&lt;Node&gt;, std::greater&lt;Node&gt; &gt; que;signed main(void)&#123; int totNote, totCse, L, R; scanf("%d%d%d%d", &amp;totNote, &amp;totCse, &amp;L, &amp;R); for (int i = 1; i &lt;= totNote; i++) &#123; scanf("%lld", sum + i); sum[i] += sum[i - 1]; &#125;*sum = 0; for (int i = 1; i &lt;= totNote; i++)table[i][0] = i; for (int j = 1; (1 &lt;&lt; j) &lt;= totNote; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= totNote; i++) &#123;#define A table[i][j-1]#define B table[i+(1&lt;&lt;j-1)][j-1] table[i][j] = sum[A] &gt; sum[B] ? A : B; //printf("Note %d~%d, max=%d\n", i, i + (1 &lt;&lt; j)-1, table[i][j]); &#125; for (int i = 1; i + L - 1 &lt;= totNote; i++) que.push(&#123; i,i + L - 1,std::min(i + R - 1,totNote) &#125;); long long ans = 0; while (totCse--) &#123; const auto it = que.top(); que.pop(); ans += it.val; if (it.rb &lt; it.t)que.push(Node(it.l,it.rb,it.t - 1)); if (it.re &gt; it.t)que.push(Node(it.l,it.t + 1,it.re)); &#125; printf("%lld\n", ans); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>优先队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】Nim游戏]]></title>
    <url>%2F2019%2F01%2F20%2FNim%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[模板题目在这里(LG). 这类题目可以抽象成为这样的一个模型：有 $n$ 堆石子，两名玩家轮流操作，每一次选择一堆，取任意数量石子，如果轮到一名玩家操作时没有石子可取，那么这名玩家判负。也就是这道题目的模型。 这类游戏的局面可以分为两种，先手必胜的 N-position 和先手必败的 P-position. 如果一个局面是 N-position, 那么它必定有至少一个子局面为 P-position. 如果一个局面是 P-position, 那么它的所有子局面都是 N-position. 在这道题目中，记第 $i$ 堆火柴有 $a_i$ 个，那么如果 $a_1\ \texttt{xor}\ a_2\ \texttt{xor}\ a_3\ \texttt{xor}\cdots\texttt{xor}\ a_n = 0 $ , 当前局面为 P-position. 也就是说，如果所有火柴堆的异或等于 0.那么先手必败。 如果不是这样，那么说明当前局面是 N-position, 它有一个 P-position 子局面，这个子局面是满足 $a_1\ \texttt{xor}\ a_2\ \texttt{xor}\ a_3\ \texttt{xor}\cdots\texttt{xor}\ a_n = 0 $ 的。如何取到这个局面呢？记 $S=a_1\ \texttt{xor}\ a_2\ \texttt{xor}\ a_3\ \texttt{xor}\cdots\texttt{xor}\ a_n$. 将 $S$ 采用二进制表示，$S$ 必定有至少一个位置上的数是 1. 现在我们考虑最高位的那个 1. 一定是存在某一堆火柴 $a_t$ 二进制表示之后在这个位置上也有这么一个 1, 我们只用操作这一堆火柴，使得减少后的 $S_1=0$，可以发现，减少的 $\Delta = a_t-(S\ \texttt{xor}\ a_t)$. 这样，说明所有 $S\not=0$ 的局面存在一种操作使得 $S_1=0$. 如果 $S=0$, 无论如何移动必然 $S_1\not=0$. 确定的 P-position 是所有的火柴堆都是 0. 此时显然 $S=0$. 然后运用数学归纳法，发现这么做是对的。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 500000 + 50;int arr[MAXN];signed main(void)&#123; int totNums, ans = 0; scanf("%d", &amp;totNums); for (int i = 0; i &lt; totNums; i++) &#123; scanf("%d", arr + i); ans ^= arr[i]; &#125; if (ans == 0)puts("lose"); else &#123; int temp, delta; for (int i = 1; i &lt;= ans; i &lt;&lt;= 1) if (ans&amp;i)temp = i; for (int i = 0; i &lt; totNums; i++) if (arr[i] &amp; temp) &#123; delta = arr[i] - (ans ^ arr[i]); printf("%d %d\n", delta, i + 1); arr[i] -= delta; break; &#125; for (int i = 0; i &lt; totNums; i++)printf("%d ", arr[i]); putchar('\n'); &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚树]]></title>
    <url>%2F2019%2F01%2F13%2F%E8%99%9A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[虚树是一颗假想中的树，可以用来优化 DP. 例如在 SDOI2011 消耗战 中，我们需要多次 DP, 但是树中只有少数关键点是我们需要考虑的，虚树可以去除掉多数不相干的结点，只保留下有用的结点，包括： 根结点 关键点 两个关键点的 LCA. 在这道题目中，对于每一次询问，我们依次考虑每一个关键点，并维护一个一开始只包含根结点栈。 如果当前关键点与栈顶元素的最近公共祖先是栈顶元素，那么直接入栈。 否则，不断取出栈顶的两个元素，如果他们当中深度较浅的结点仍然比当前结点与栈顶的最近公共祖先深，那么在两个栈顶结点之间连边，重复这个过程。 否则，检查当前栈顶元素是不是当前关键点的祖先如果是，在他们之间连边。 否则，将他们的最近公共祖先加入虚树。 在此之前，我们需要先预处理LCA. 并维护结点倍增之后向上路径上的最小权值，代表如果使得这一整条路径不再联通花费的最小代价。 建立完成虚树之后，按照状态转移方程进行动态规划即可。 f_i=\begin{cases} \min (lev_{i\to j},\;f_j)& \mbox{若 }j\mbox{ 不是关键点}\\ len_{i\to j}&\mbox{otherwise} \end{cases}\qquad j\in i.son代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 250000 + 500;struct Way &#123; int to;long long val; &#125;;std::vector&lt;Way&gt; G[MAXN];bool vis[MAXN];int up[MAXN][21], depth[MAXN], ID[MAXN], dfn;long long siglen[MAXN][21];void Render_LCA(const int rootNow, const int &amp;fa = 0, const int &amp;lenTo = 0) &#123; vis[rootNow] = true; depth[rootNow] = depth[fa] + 1; ID[rootNow] = ++dfn; up[rootNow][0] = fa; siglen[rootNow][0] = lenTo; for (int i = 1; i &lt; 21; i++) &#123; up[rootNow][i] = up[up[rootNow][i - 1]][i - 1]; siglen[rootNow][i] = std::min(siglen[up[rootNow][i - 1]][i - 1], siglen[rootNow][i - 1]); &#125; for (const auto &amp;it : G[rootNow]) if (!vis[it.to])Render_LCA(it.to, rootNow, it.val);&#125;std::pair&lt;int, long long&gt;LCA(int a, int b) &#123; long long sum = INT64_MAX; if (depth[a] &lt; depth[b])std::swap(a, b); for (int i = 20; i &gt;= 0; i--) if (depth[up[a][i]] &gt;= depth[b]) &#123; sum = std::min(sum, siglen[a][i]); a = up[a][i]; &#125; if (a == b)return std::make_pair(a, sum); for (int i = 20; i &gt;= 0; i--) if (up[a][i] != up[b][i]) &#123; sum = std::min(sum, std::min(siglen[a][i], siglen[b][i])); a = up[a][i]; b = up[b][i]; &#125; return std::make_pair(up[a][0], std::min(sum, std::min(siglen[b][0], siglen[a][0])));&#125;int arr[MAXN];int stack[MAXN], *attend = stack;#define top (*(attend-1))#define topp (*(attend-2))#define size (attend-stack)std::vector&lt;Way&gt; VirtG[MAXN];#define Cls(x) &#123;std::vector&lt;Way&gt; T;std::swap(T,VirtG[x]);&#125;long long DP(const int &amp;nowAt = 1) &#123; long long ans = 0, res; for (const auto &amp;it : VirtG[nowAt]) &#123; res = DP(it.to); if (vis[it.to])ans += it.val; else ans += std::min(res, it.val); &#125;return ans;&#125;signed main(void)&#123; std::pair&lt;int, long long&gt;res, btlink; int totIsland, totQuery, fr, to, val, totbkup, in; scanf("%d", &amp;totIsland); for (int i = 1; i &lt; totIsland; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;val); G[fr].push_back(&#123; to,val &#125;); G[to].push_back(&#123; fr,val &#125;); &#125; //预处理 LCA memset(::up, 0, sizeof(::up)); memset(::siglen, 0, sizeof(::siglen)); memset(::vis, false, sizeof(::vis)); Render_LCA(1); memset(::vis, false,sizeof(::vis)); scanf("%d", &amp;totQuery); while (totQuery--) &#123; attend = stack; scanf("%d", &amp;totbkup); for (int i = 0; i &lt; totbkup; i++) &#123; scanf("%d", arr + i); vis[arr[i]] = true; &#125;std::sort(arr, arr + totbkup, [](const int a, const int b) &#123;return ID[a] &lt; ID[b]; &#125;); //Build *attend++ = 1; Cls(1); for (int* it = arr; it &lt; arr + totbkup; it++) if (*it != 1) &#123; res = LCA(*it, top);//LCA - len if (res.first != top) &#123; while (size &gt; 2 &amp;&amp; ID[res.first] &lt; ID[topp]) &#123; btlink = LCA(top, topp); VirtG[topp].push_back(&#123; top,btlink.second &#125;); attend--; &#125; if (ID[res.first] &gt; ID[topp]) &#123; //添加两个关键点的LCA Cls(res.first); btlink = LCA(res.first, top); VirtG[res.first].push_back(&#123; top,btlink.second &#125;); top = res.first; &#125; else &#123; btlink = LCA(res.first, top); VirtG[res.first].push_back(&#123; top,btlink.second &#125;); attend--; &#125; &#125; Cls(*it); *attend++ = *it; //添加一个关键点 &#125; for (int* i = stack + 1; i &lt; attend; i++) &#123; res = LCA(*i, *(i - 1)); VirtG[*(i - 1)].push_back(&#123; *i,res.second &#125;); &#125; //Dp printf("%lld\n", DP(1)); for(int i=0;i&lt;totbkup;++i) vis[arr[i]] = false; &#125; return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>虚树</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Link-Cut Tree]]></title>
    <url>%2F2019%2F01%2F07%2FLink-Cut-Tree%2F</url>
    <content type="text"><![CDATA[模板题目在这里。 Link-Cut Tree是一种动态树问题中的数据结构。它使用到了树链剖分的思想，利用Splay进行维护。在这道题目中，我们看到它可以维护一个森林，而且高效地支持： 两点之间连边 两点之间断边 求整颗子树的 Xor 更改一个点的权 在树链剖分中，我们将路径分为一般路径和重路径，在LCT中，路径有两种，实际存在的重路径和不那么明显的虚路径。整体上看，一颗LCT维护的全集是一个森林，其中包含若干颗有根树，而有根树中的每一个结点最多一条重路径，这些有根树并不是二叉树，我们用Splay维护每一个重路径，Splay也是有根的，但是与有根树的根一样，不显式存储。 首先定义一个结点，这个结点显式存储的指针包含两个儿子和父亲，这是将这个结点放在Splay角度来说的，然而，如果一个结点包含许多儿子，那么只显式地存储重路径，至于那些虚路径连接的结点，只用将他们连接对象的父亲设置好即可。可以形象地理解为，对于这个结点而言，它知道自己的父亲是哪个结点，但是这个父结点并不知道自己有这个儿子。 LCT中最重要的一个操作是Access操作，执行了这个操作之后，一个指定的结点到他所在的有根树的根之间的路径全部变为重路径，而且这条路径上的所有结点构成一颗Splay.具体实现方式是每一次跳到Splay的根，然后让自己的父亲认自己作为右儿子。 除此之外，LCT还支持很多操作。比较常用的有 操作 描述 时间复杂度 Access(x) 将指定结点 $x$ 到有根树的根打通，形成一个 Splay 均摊 $O(\log N)$ Make_Root(x) 将一个指定结点 $x$ 作为当前有根树的根 均摊 $O(\log N)$ Spaly(x) 将一个指定结点 $x$ 作为当前 Splay 的根 均摊 $O(\log N)$ Find_Root(x) 找到 $x$ 的根 均摊 $O(\log N)$ Link(x, y) 在 $x$ 与 $y$ 之间连边 均摊 $O(\log N)$ Cut(x, y) 断开 $x$ 与 $y$ 的连边 均摊 $O(\log N)$ 模板题代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)3e5 + 500;constexpr auto MAXM = MAXN;struct Node &#123; int val, ans; bool rev; Node *ch[2], *fa;//右儿子深度大于左儿子 Node&amp; Push_Down() &#123; if (rev) &#123; rev = false; ch[0]-&gt;rev ^= 1; ch[1]-&gt;rev ^= 1; std::swap(ch[0], ch[1]); &#125;return *this; &#125; Node&amp; Update() &#123; ans = ch[0]-&gt;ans^ch[1]-&gt;ans^val; return *this; &#125; bool IsRoot() &#123; return (fa-&gt;ch[0] != this &amp;&amp; fa-&gt;ch[1] != this); &#125; Node&amp; Reverse() &#123; rev ^= 1; return *this; &#125;&#125;*null;void Rotate(Node* targ) &#123; int p = targ-&gt;fa-&gt;ch[0] == targ ? 1 : 0; Node* faa = targ-&gt;fa; if (!faa-&gt;IsRoot())faa-&gt;fa-&gt;ch[faa-&gt;fa-&gt;ch[1] == faa] = targ; faa-&gt;ch[p ^ 1] = targ-&gt;ch[p]; if (targ-&gt;ch[p] != null)targ-&gt;ch[p]-&gt;fa = faa; targ-&gt;ch[p] = faa; targ-&gt;fa = faa-&gt;fa; faa-&gt;fa = targ; faa-&gt;Update(); targ-&gt;Update();&#125;std::stack&lt;Node*&gt; S;void Spaly(Node* nowAt) &#123; Node* u = nowAt; S.push(u); while (!u-&gt;IsRoot())S.push(u = u-&gt;fa); while (!S.empty()) &#123; u = S.top(); S.pop(); u-&gt;Push_Down(); &#125; while (!nowAt-&gt;IsRoot())Rotate(nowAt);&#125;void Access(Node* targ) &#123; for (Node* y = null; targ != null; targ = targ-&gt;fa) &#123; Spaly(targ); targ-&gt;ch[1] = y; targ-&gt;Update(); y = targ; &#125;&#125;void Make_Root(Node* targ) &#123; Access(targ); Spaly(targ); targ-&gt;Reverse();&#125;Node* Find_Root(Node* nowAt) &#123; Access(nowAt); Spaly(nowAt); for (nowAt-&gt;Push_Down(); nowAt-&gt;ch[0] != null; nowAt-&gt;Push_Down()) nowAt = nowAt-&gt;ch[0]; return nowAt;&#125;void Split(Node* x, Node* y) &#123; Make_Root(y); Access(x); Spaly(y);&#125;void Link(Node* x, Node* y) &#123; Make_Root(x); if (Find_Root(y) != x) x-&gt;fa = y;&#125;void Cut(Node* x, Node* y) &#123; Make_Root(x); if (Find_Root(y) != x || x-&gt;fa != y || x-&gt;ch[1] != null)return; else x-&gt;fa = y-&gt;ch[0] = null;&#125;Node* nodes[MAXN];#define Pos(x) ((x)-nodes)signed main(void) &#123; null = new Node; null-&gt;val = 0; null-&gt;ans = 0; null-&gt;ch[0] = null-&gt;ch[1] = null-&gt;fa = nullptr; int totNums, totOptn, opt, x, y; scanf("%d%d", &amp;totNums, &amp;totOptn); for (int i = 0; i &lt; totNums; i++) &#123; scanf("%d", &amp;x); nodes[i] = new Node; auto&amp; it = nodes[i]; it-&gt;fa = it-&gt;ch[0] = it-&gt;ch[1] = null; it-&gt;ans = it-&gt;val = x; it-&gt;rev = false; &#125; while (totOptn--) &#123; scanf("%d%d%d", &amp;opt, &amp;x, &amp;y); --x; --y; switch (opt) &#123; case 0: Make_Root(nodes[y]); Access(nodes[x]); Spaly(nodes[y]); printf("%d\n", nodes[y]-&gt;ans); break; case 1: Link(nodes[x], nodes[y]); break; case 2: Cut(nodes[x], nodes[y]); break; case 3: Spaly(nodes[x]); nodes[x]-&gt;val = ++y; nodes[x]-&gt;Update(); break; default: puts("UKE"); assert(false); break; &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>动态树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】文艺平衡树]]></title>
    <url>%2F2019%2F01%2F06%2F%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 100000 + 50;struct Node &#123; int val, siz; bool mark; Node *ch[2], *fa; Node&amp; Init(void) &#123; mark = false; siz = 1; ch[0] = ch[1] = fa = nullptr; return *this; &#125; Node&amp; Push_Down(void) &#123; if (!mark)return *this; mark = false; if (ch[0] != nullptr) ch[0]-&gt;mark ^= 1; if (ch[1] != nullptr) ch[1]-&gt;mark ^= 1; std::swap(ch[0], ch[1]); return *this; &#125; Node&amp; Reverse(void) &#123; mark ^= 1; return *this; &#125; Node&amp; Refresh(void) &#123; siz = 1; if (ch[0] != nullptr)siz += ch[0]-&gt;siz; if (ch[1] != nullptr)siz += ch[1]-&gt;siz; return *this; &#125;&#125;nodes[MAXN], *root = nullptr;Node* Kth_Element(int kth, Node* nowAt = root) &#123; while (nowAt != nullptr) &#123; nowAt-&gt;Push_Down(); if (nowAt-&gt;ch[0] != nullptr) &#123; if (nowAt-&gt;ch[0]-&gt;siz &gt;= kth) &#123; nowAt = nowAt-&gt;ch[0]; continue; &#125; kth -= nowAt-&gt;ch[0]-&gt;siz; &#125; if (kth == 1)return nowAt; nowAt = nowAt-&gt;ch[1]; --kth; &#125;assert(false);&#125;void Rotate(Node*&amp; targ) &#123; bool p = targ-&gt;fa-&gt;ch[0] == targ; Node* faa = targ-&gt;fa; if (faa-&gt;fa != nullptr)faa-&gt;fa-&gt;ch[faa-&gt;fa-&gt;ch[1] == faa] = targ; faa-&gt;ch[p ^ 1] = targ-&gt;ch[p]; if (targ-&gt;ch[p] != nullptr)targ-&gt;ch[p]-&gt;fa = faa; targ-&gt;ch[p] = faa; targ-&gt;fa = faa-&gt;fa; faa-&gt;fa = targ; faa-&gt;Refresh(); targ-&gt;Refresh();&#125;std::stack&lt;Node*&gt; S;void Spaly(Node* nowAt, Node* pos) &#123; while (nowAt-&gt;fa != pos)Rotate(nowAt);&#125;void dfs(Node* nowAt = root) &#123; nowAt-&gt;Push_Down(); if (nowAt-&gt;ch[0] != nullptr)dfs(nowAt-&gt;ch[0]); if (nowAt-&gt;val != 0)printf("%d ", nowAt-&gt;val); if (nowAt-&gt;ch[1] != nullptr)dfs(nowAt-&gt;ch[1]);&#125;signed main(void)&#123; int totNums, totOptn; scanf("%d%d", &amp;totNums, &amp;totOptn); for (int i = 0; i &lt;= totNums + 1; i++)nodes[i].Init(); for (int i = 1; i &lt;= totNums; i++) &#123; nodes[i].val = i; nodes[i].ch[1] = nodes + i + 1; nodes[i].siz = totNums + 2 - i; &#125; for (int i = 1; i &lt;= totNums; i++)nodes[i].fa = nodes + i - 1; root = nodes; nodes[totNums + 1].fa = nodes + totNums; root-&gt;ch[1] = nodes + 1; root-&gt;siz = totNums + 2; nodes[totNums + 1].siz = 1; int fr, to; while (totOptn--) &#123; scanf("%d%d", &amp;fr, &amp;to); if (fr &gt; to)continue; Spaly(root = Kth_Element(fr), nullptr); Spaly(Kth_Element(to + 2), root); root-&gt;ch[1]-&gt;ch[0]-&gt;Reverse(); &#125;dfs(); putchar('\n'); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速傅里叶变换]]></title>
    <url>%2F2019%2F01%2F04%2FFFT%2F</url>
    <content type="text"><![CDATA[快速傅里叶变换(Fast Fourier Transform，FFT)是一种经常用于信号处理的算法，可以在 $O(N\log N )$ 时间内完成的离散傅里叶变换(Discrete Fourier transform，DFT)算法。在这里我们用它来加速多项式乘法。 即如果存在两个多项式 $A(x)$ 和 $B(x)$. 项数分别为 $n$ 和 $m$, 系数构成的向量为 A(x)=(a_0,a_1,a_2,\cdots,a_{n-1})\\ B(x)=(b_0,b_1,b_2,\cdots,b_{n-1})那么它们的乘积 $C(x)$ 的系数可以构成一个 $n+m-1$ 维向量。代码如下： 123for ( int i = 0 ; i &lt; n ; ++ i ) for ( int j = 0 ; j &lt; m ; ++ j ) c [i + j] += a [i] * b [j] ; 时间复杂度为 $O(N^2)$. 利用快速傅里叶变换及其逆变换可以加速这个过程。 多项式假定 $A(x)$ 是一个关于 $x$ 的 $n-1$ 次多项式，那么它有两种不同的表示方法：系数表示法和点值表示法。 系数表示法即 A(x)=\sum_{i=0}^{n-1}a_ix^i点值表示法这种表示方法在快速傅里叶变换中会使用到。基本思想是将 $A(x)$ 看作一条关于 $x$ 的函数，画在笛卡尔平面直角坐标系中，然后在当中取 $n$ 个不同的点，由它们的 $x,y$ 坐标值，即可确定这个多项式。 即将一组不同的的 $(x_0,x_1,x_2,\cdots,x_{n-1})$ 代入 $A(x)$ 得到 $(y_0,y_1,y_2,\cdots,y_{n-1})$. 其中 \forall i\in[0,n)\quad y_i=\sum_{j=0}^{n-1}a_jx_i^j在这当中，已知点值表示求系数表示的过程称为插值。 多项式乘法之前提到过，如果是两个系数表示的多项式朴素地求它们的乘积时间复杂度为 $O(N^2)$. 而如果是点值表示法的多项式呢？ 如果将一组不同的的 $(x_0,x_1,x_2,\cdots,x_{n-1})$ 分别代入 $A(x),\,B(x)$ 得到 $(y_0,y_1,y_2,\cdots,y_{n-1}),\;(y^\prime_0,y^\prime_1,y^\prime_2,\cdots,y^\prime_{n-1})$. 那么 $C(x)=A(x)\times B(x)$ 的点值表达为 (y_0y^\prime_0,y_1y^\prime_1,y_2y^\prime_2,\cdots,y_{n-1}y^\prime_{n-1})复数形如 $a+bi$ 的数称为复数，复数的集合用 $C$ 表示，其中 $a$ 为实部，$b$ 为虚部，$i$ 为虚数单位，满足 i^2=-1每一个复数 $a+bi$ 都对应了复平面上的一个向量 $(a,b)$, 在这样的平面中实轴是水平的，虚轴是竖直的。 单位复数根如果复数 $\omega$ 满足 \omega^n=1那么则称 $\omega$ 为 $n$ 次单位复数根。$n$ 次单位复数根一共有 $n$ 个，对于正整数 $k\in[0,n)$， 这些根是 e^{\frac{2\pi ik}{n}}其中记 $\omega_n = e^{\frac{2\pi i}{n}}$, 称为主$n$次复数根。 消去定理 \forall n\in\mathbb{n},\;k\in\mathbb{N},\;d\in\mathbb{R}^+\quad \omega_{dn}^{dk}=\omega_n^k证明： \omega_{dn}^{dk}=\left(e^{\frac{2\pi i}{dn}}\right)^{dk}=\left(e^{\frac{2\pi i}{n}}\right)^k=\omega_n^k同时我们还可以得到如下推论： \forall n\in\mathbb{Z}^+,2|n\quad \omega_n^{\frac{n}{2}}=\omega_2=-1证明： \omega_n^{\frac{n}{2}}=\left(e^{\frac{2\pi i}{n}}\right)^{\frac{n}{2}}=\left(e^{\pi i}\right)=\omega_2折半定理对于任何大于0的偶数 $n$，都有 $n$ 个 $n$ 次单位复根的平方的集合，等于 $\frac{n}{2}$ 个 $\frac{n}{2}$ 次单位复根的集合。 证明： (\omega_n^{k + \frac{n}{2}})^2 = \omega_n^{2k + n} = \omega_n^{2k}\omega_n^n = \omega_n^{2k} = (\omega_n^k)^2求和引理 \forall n>0,k\nmid n\quad \sum\limits_{j =0}^{n-1}{(w_n^k)^j} = 0因此 \sum\limits_{j =0}^{n-1}{(w_n^k)^j} = \frac{(w_n^k)^n -1}{w_n^k -1} = \frac{(w_n^n)^k -1}{w_n^k -1} = \frac{(1)^k -1}{w_n^k -1}思想快速傅里叶变换快速傅里叶变换基于分治思想，即每一次将问题规模减半，然后合并。从这里开始，通篇假定 $n$ 为 2 的次幂。 之前提到过，如果想要求 $C(x)=A(x)B(x)$ 的点值表达式，那么需要带 $n$ 个值进去运算，时间复杂度为 $O(N^2)$. 但是如果是带一些特殊的值，那么可以将时间复杂度降低到 $O(N\log N)$. 这些特殊的值就是一组向量 (\omega_n^0,\omega_n^1,\omega_n^2,\cdots,\omega_n^{n-1})得到 (y_0y^\prime_0,y_1y^\prime_1,y_2y^\prime_2,\cdots,y_{n-1}y^\prime_{n-1})也就是说 y_i=A(\omega_n^i)\\ y_i^\prime = B(\omega_n^i)现在我们考虑如何计算 $y_i$. 假定 A(x)=\sum_{i=0}^{n-1}a_ix^i令 A_0(x)=\sum_{j=0}^{\frac{n}{2}-1}a_{2j}x^j\\ A_1(x)=\sum_{j=0}^{\frac{n}{2}-1}a_{2j+1}x^j那么 A(x)=A_0(x^2)+xA_1(x^2)将 $x=\omega_n^k(k&lt;\frac n2)$ 代入得 A(\omega_n^k)=A_0\left(\omega_\frac n2^k\right)+\omega_n^kA_1\left(\omega_\frac n2^k\right)将 $x=\omega_n^{k+\frac n2}(k&lt;\frac n2)$ 代入得 A\left(\omega_n^{k+\frac n2}\right)=A_0\left(\omega_n^{2k}\omega_n^n\right)+\omega_n^k\omega_n^\frac n2A_1\left(\omega_n^{2k}\omega_n^n\right)\\ \because \omega_n^n=1,\;\omega_n^\frac n2=-1\\ \therefore A\left(\omega_n^{k+\frac n2}\right)=A_0\left(\omega_\frac n2^k\right)-\omega_n^kA_1\left(\omega_\frac n2^k\right)这两个式子只有一个符号的差别，因此我们在得知 $A_0$ 和 $A_1$ 的点值表达式之后，可以在 $O(N)$ 的时间复杂度内将其合并得到 $A$. 对于 $A_0$ 和 $A_1$ 的点值表达式，可以递归地计算，如果某一时刻 $A$ 只剩下一项，那么可以直接返回。这样，整个快速傅里叶变换过程的时间复杂度为 $O(N\log N)$. 快速傅里叶逆变换在转换成为点值表达式之后，可以在 $O(N)$ 的时间复杂度内计算出多项式 $C$ 的点值表达式，而快速傅里叶逆变换则是可以在 $O(N\log N)$ 时间复杂度内完成插值，将点值表达式重新转换为系数表达式的一种方法。 同一个多项式的点值表示可以写成很多种不同的形式，但是一旦确定了某一种点值表示，那么它对应的系数表示（如果存在）就是唯一的。考虑求值的过程，可以用一个范德蒙德矩阵描述为 \begin{bmatrix} 1&1&1&\cdots&1\\ 1&\omega_n&\omega_n^2&\cdots&\omega_n^{n-1}\\ 1&\omega_n^2&\omega_n^4&\cdots&\omega_n^{2(n-1)}\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 1&\omega_n^{n-1}&\omega_n^{2(n-1)}&\cdots&\omega_n^{(n-1)^2} \end{bmatrix}\begin{bmatrix} a_0\\a_1\\a_2\\\vdots\\a_{n-1} \end{bmatrix}=\begin{bmatrix} y_0\\y_1\\y_2\\\vdots\\y_{n-1} \end{bmatrix}由于这个范德蒙德矩阵的逆矩阵是唯一的，所以这一组点值表达式对应的系数表达式也是唯一的。 假定 $(y_0,y_1,y_2,\cdots,y_{n-1})$ 为 $(a_0,a_1,a_2,\cdots,a_{n-1})$ 经过傅里叶变换之后的点值表达式。另外一个向量 $(c_0,c_1,c_2,\cdots,c_{n-1})$ 是多项式 $B(x)=\sum_{i=0}^{n-1}a_ix^i$ 在 $(\omega_n^0,\omega_n^{-1},\omega_n^{-2},\cdots,\omega_n^{-(n-1)})$ 处的点值表达，满足 \forall k\in[0,n),\quad c_k=\sum_{i=0}^{n-1}y_i(\omega_n^{-k})^i那么可以推导出 c_k=\sum_{i=0}^{n-1}\left(\sum_{j=0}^{n-1}a_j(\omega_n^i)^j\right)(\omega_n^{-k})^i\\ =\sum_{i=0}^{n-1}\left(\sum_{j=0}^{n-1}a_j(\omega_n^j)^i\right)(\omega_n^{-k})^i\\ =\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j(\omega_n^{j-k})^i\\ =\sum_{j=0}^{n-1}a_j\left(\sum_{i=0}^{n-1}(\omega_n^{j-k})^i\right)令 $S(x)=\sum_{i=0}^{n-1}x^i$, 将 $\omega_n^k$ 代入得到 S(\omega_n^k)=1+\omega_n^k+(\omega_n^k)^2+\cdots+(\omega_n^k)^{n-1}当 $k!=0$ 时，两边同时乘上 $\omega_n^k$ \omega_n^kS(\omega_n^k)=\omega_n^k+(\omega_n^k)^2+(\omega_n^k)^3+\cdots+(\omega_n^k)^n两式相减得到 \omega_n^kS(\omega_n^k)-S(\omega_n^k)=(\omega_n^k)^n-1\\ S(\omega_n^k)=\frac{(\omega_n^k)^n-1}{\omega_n^k-1}\\ S(\omega_n^k)=\frac{(\omega_n^n)^k-1}{\omega_n^k-1}\\ S(\omega_n^k)=\frac{1-1}{\omega_n^k-1}\\ \because \omega_n^k-1\not=0\\ \therefore S(\omega_n^k)=0当 $k=0$ 时 S(\omega_n^0)=n在之前的式子中， c_k=\sum_{j=0}^{n-1}a_j\left(\sum_{i=0}^{n-1}(\omega_n^{j-k})^i\right)\\ c_k=na_k\\ a_k=\frac{c_k}n这样，我们就找到了点值与系数之间的关系，由于 $c_k=\sum_{i=0}^{n-1}y_i(\omega_n^{-k})^i$, 在这里一组 $(c_0,c_1,c_2,\cdots,c_{n-1})$ 就相当于将 $(\omega_n^0,\omega_n^{-1},\omega_n^{-2},\cdots,\omega_n^{-(n-1)})$ 带入到多项式 $Y(x)=\sum_{i=0}^{n-1} y_ix^i$ 中，与求值的过程是类似的，所以我们可以再次调用之前的函数，但是将所带入的单位复数根次数换成负的，即可求出所有的 $c_k$, 然后全部除以 $n$, 就完成了整个过程。 优化在具体的实现过程中，需要通过数个优化，进一步加快变换的速度。 蝴蝶操作注意到 A(\omega_n^k)=A_0\left(\omega_{\frac n2}^k\right)+\omega_n^kA_1\left(\omega_{\frac n2}^k\right)\\ A\left(\omega_n^{k+\frac n2}\right)=A_0\left(\omega_{\frac n2}^k\right)-\omega_n^kA_1\left(\omega_{\frac n2}^k\right)我们可以将 $\omega_n^kA_1\left(\omega_{\frac n2}^k\right)$ 的值记下来，省掉一步运算。 迭代实现从表面上看，实现这个过程需要进行递归运算，这样难免会使用额外的空间，甚至耗费大量计算能力，这个递归的过程可以看做一个将原序列先划分再合并的过程。 记一个整数 $a=\sum_{i\in \mathbb{N}^+}2^i$ 的二进制表示为 $a=0b\overline{a_1a_2a_3\cdots}$ 经过观察可以发现，原先在序列第 $i=0b\overline{a_1a_2\cdots a_m}$ 位置的数，递归到底层就到了位置 $j=0b\overline{a_ma_{m-1}\cdots a_1}$. 于是，我们可以预处理一个数组 $r_i$ 记录下原序列中位置为 $i$ 的数，递归到底层的位置。这个数组递推公式如下： r_i=(r_{\frac i2}>>1)|\left((i\&1)1=0b\overline{0a_{m-1}a_{m-2}\cdots a_1}\\ (i\&1)1)|\left((i\&1)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀排序]]></title>
    <url>%2F2019%2F01%2F01%2F%E5%90%8E%E7%BC%80%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[后缀排序指给定一个字符串 $s$, 我们需要求出它所有的后缀排序后的结果。 使用倍增+基数排序可以在 $O(N\log N)$ 的时间复杂度内解决这个问题。在这里 $sa_i$ 代表排名为 $i$ 的后缀的下标 $x_i$ 代表下标 $i$ 的位置值（对于已考虑的长度后缀而言） $y_i$ 代表第二维排名为 $i$ 的二元组第一维的下标 123for (i = 0; i &lt; n; i++)++basket[x[i] = s[i]];for (i = 1; i &lt; m; i++)basket[i] += basket[i - 1];for (i = n - 1; i &gt;= 0; i--)sa[--basket[x[i]]] = i; 在一开始我们先进行一次基数排序，处理出单个字符的 $sa$. 之后每一轮基数排序的对象就是二元组了，根据基数排序的思想，我们应该先对第二维进行排序，实际上这个过程可以直接使用 $sa$ 数组快速得到。 12for (p = 0, i = n - j; i &lt; n; i++)y[p++] = i;for (i = 0; i &lt; n; i++)if (sa[i] &gt;= j)y[p++] = sa[i] - j; 可以发现的是第二维排在最前的就是那些第二维已经超出数组范围的二元组，由于这里是靠前的优先，所以 $y$ 数组的前几项对应着这些超出范围的二元组。 后面一行是根据 $sa$ 数组计算 $y$ 数组，因为此时 $sa_i$ 代表的就是排名为 $i$ 的后缀的下标，第二维排序后结果应与 $sa$ 类似，如果某一个位置排名为 $i$, 那么就说明以这个位置作为第二维的二元组排名为 $i$. 当然，如果是非常靠前的元素那就不能作为一个二元组的第二维了，这里特判一下。 1234memset(basket, 0, sizeof(basket));for (i = 0; i &lt; n; i++)++basket[x[i]];for (i = 1; i &lt;= m; i++)basket[i] += basket[i - 1];for (i = n - 1; i &gt;= 0; i--)sa[--basket[x[y[i]]]] = y[i]; 接着使用基数排序对第一维进行排序。根据基数排序思想我们应该按照第二维降序进行扫描来计算新的 $sa$ 数组，而第二维的降序，就是反转 $y$ 数组。注意 $sa_i$ 的含义是排名为 $i$ 的后缀的下标，指代的应该是第一维，与 $y_i$ 指代的相同。 123std::swap(x, y);for (p = 1, x[*sa] = 0, i = 0; i &lt; n; i++) x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + j] == y[sa[i - 1] + j]) ? p - 1 : p++; 最后一步就是计算新的 $x$ 数组，这里 $y$ 数组已经没有用了，将它清空来存放新的 $x$ 数组中的值。根据原有的 $x$ 和 $sa$ 数组可以计算出新的 $x$ 数组。注意由于 $x$ 数组中代表的是二元组的位置值，如果两个二元组是完全一样的，那么他们对应的 $x$ 值也应该相等。所以我们按照排名先后进行扫描，如果当前二元组和比它排名靠前一名的二元组完全相同，那么这两个二元组应有相同的 $x$ 值，如果不同，那么靠后二元组的 $x$ 值就是靠前的 $x$ 值加1. 这里 $n$ 代表字符串长度，是一个常量。$m$ 代表字符集大小，从表面上看好像是一个常量，但是需要注意的是，进行很多轮倍增之后，$x$ 中保存的是二元组的位置值，尽管构成这些二元组的字符集大小并不大，但是将它们看作一个整体，就有多种不同的组合了，因此 $m$ 会不断变大。 一轮倍增结束后，这里 $p$ 代表的就是到目前为止不同的后缀的个数，如果它已经等于字符串长度 $n$, 那么说明此刻所有的后缀都得到了一个独特的排名，就不用进行下一轮倍增了。 完整代码如下: 123456789101112131415161718192021222324constexpr auto MAXN = (int)1e6 + (int)5e4;;char s[MAXN];int basket[MAXN], sa[MAXN], _1[MAXN], _2[MAXN];void Render_SA(int n, int m)&#123; int i, j, p, *x = _1, *y = _2; memset(basket, 0, sizeof(basket)); for (i = 0; i &lt; n; i++)++basket[x[i] = s[i]]; for (i = 1; i &lt; m; i++)basket[i] += basket[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--basket[x[i]]] = i; for (j = 1, p = 1; p &lt; n; j &lt;&lt;= 1, m = p) &#123; for (p = 0, i = n - j; i &lt; n; i++)y[p++] = i; for (i = 0; i &lt; n; i++)if (sa[i] &gt;= j)y[p++] = sa[i] - j; memset(basket, 0, sizeof(basket)); for (i = 0; i &lt; n; i++)++basket[x[i]]; for (i = 1; i &lt;= m; i++)basket[i] += basket[i - 1]; for (i = n - 1; i &gt;= 0; i--)sa[--basket[x[y[i]]]] = y[i]; std::swap(x, y); for (p = 1, x[*sa] = 0, i = 0; i &lt; n; i++) x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + j] == y[sa[i - 1] + j]) ? p - 1 : p++; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG2766 最长不下降子序列问题]]></title>
    <url>%2F2019%2F01%2F01%2F%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目在这里. 这道题目设有三个问题，我们将它们分开，看作三个不同的题目求解。 首先将所有的数读入，每一个数 $a_i$ 看作一个结点，转换为一个图论模型。 最长不下降子序列的长度$s$首先枚举 $j&lt;i$ 如果 $a_j\leq a_i$ 那么在它们之间连边。建立虚拟的源点和汇点，其中源点与所有结点连边，长度为 0. 所有结点与汇点连边，长度为 1. 完成这一步之后，使用 SPFA 算法跑一遍最长路，即为答案 $s$. 最多可取出多少个长度为 $s$ 的不下降子序列使用网络费用流的思想，将之前的距离看作为费用，每一次增广之前先检查一下费用是否恰好等于 $s$, 如果是，进行增广，反之直接结束算法。最终答案就是在此基础之上的最大流。 允许在取出的序列中多次使用 $x_1$ 和 $x_n$ ，则从给定序列中最多可取出多少个长度为 $s$ 的不下降子序列在原先的模型基础之上进行一些删改： 断掉源点与 $x_1$ 之间所有的连边 断掉 $x_n$ 与汇点之间所有的连边 在源点与 $x_1$ 之间连边，容量为 $\infty$ ，费用为 0. 在 $x_n$ 与汇点之间连边，容量为 $\infty$， 费用为 1. 再次执行最大费用最大流算法，确保每次增广费用等于 $s$, 答案即为最大流。 代码如下 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 550;int totNums, num[MAXN] = &#123;&#125;;int s, t;struct Edge &#123; int fr, to, cost, residual;&#125;;std::vector&lt;Edge&gt;edges; std::vector&lt;int&gt; G[MAXN];void AddEdge(const int &amp;fr, const int &amp;to, const int &amp;cost, const int &amp;residual) &#123; G[fr].push_back(edges.size()); edges.push_back(&#123; fr,to,cost,residual &#125;); G[to].push_back(edges.size()); edges.push_back(&#123; to,fr,-cost,0 &#125;);&#125;int cost[MAXN], last[MAXN], flow[MAXN];int maxFlow, minCost;bool SPFA(const int &amp;maxCost) &#123; std::queue&lt;int&gt;que; bool inQueue[MAXN]; memset(cost, 0x7f, sizeof(cost)); memset(inQueue, false, sizeof(inQueue)); que.push(s); inQueue[s] = true; cost[s] = 0; flow[s] = INT_MAX; int nowAt; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); inQueue[nowAt] = false; for (int i = 0; i &lt; G[nowAt].size(); i++) &#123; auto &amp;it = edges[G[nowAt][i]]; if (it.residual &gt; 0 &amp;&amp; cost[it.to] &gt; cost[nowAt] + it.cost) &#123; cost[it.to] = cost[nowAt] + it.cost; last[it.to] = G[nowAt][i]; flow[it.to] = std::min(flow[nowAt], it.residual); if (!inQueue[it.to]) &#123; inQueue[it.to] = true; que.push(it.to); &#125; &#125; &#125; &#125; if (cost[t] &gt; maxCost)return false; minCost += flow[t] * cost[t]; maxFlow += flow[t]; nowAt = t; while (nowAt != s) &#123; edges[last[nowAt]].residual -= flow[t]; edges[last[nowAt] ^ 1].residual += flow[t]; nowAt = edges[last[nowAt]].fr; &#125;return true;&#125;signed main(void)&#123; scanf("%d", &amp;totNums); s = totNums + 1; t = totNums; for (int i = 0; i &lt; totNums; i++)scanf("%d", num + i); for (int i = 0; i &lt; totNums; i++)for (int j = i + 1; j &lt; totNums; j++) if (num[i] &lt;= num[j]) AddEdge(i, j, -1, 1); for (int i = 0; i &lt; totNums; i++) &#123; AddEdge(i, t, -1, 1); AddEdge(s, i, 0, 1); &#125; SPFA(INT_MAX); int mark = minCost, flow; while (SPFA(mark)); AddEdge(s, 0, 0, INT_MAX); AddEdge(totNums - 1, t, -1, INT_MAX); flow = maxFlow; while (SPFA(mark)); printf("%d\n%d\n%d\n", -mark, flow, maxFlow); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】换教室]]></title>
    <url>%2F2018%2F12%2F31%2F%E6%8D%A2%E6%95%99%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[LG题目地址在这里。 定义状态为 $D_{i,j,0/1}$ 代表目前考虑了前 $i$ 个时间段，已经提出了 $j$ 次申请，第 $i$ 个时间段是否提出申请的数学期望。可以发现这个方程的转移非常复杂，但是思路却很清晰，就是使用概率的那些公式，把所有情况不重复不遗漏考虑清楚即可。 总时间复杂度为 $O(NM)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 2050;constexpr auto MAXM = 350;double D[MAXN][MAXN][2];double k[MAXN], dis[MAXM][MAXM];int clas[MAXN] = &#123;&#125;, dclas[MAXN] = &#123;&#125;;signed main(void)&#123; int totNums, totChange, totClass, totRoad; for (int i = 0; i &lt; MAXM; i++)for (int j = 0; j &lt; MAXM; j++)dis[i][j] = INT_MAX; memset(k, 0, sizeof(k)); //read scanf("%d%d%d%d", &amp;totNums, &amp;totChange, &amp;totClass, &amp;totRoad); for (int i = 0; i &lt; totNums; i++)scanf("%d", clas + i); for (int i = 0; i &lt; totNums; i++)scanf("%d", dclas + i); for (int i = 0; i &lt; totNums; i++) &#123; --clas[i]; --dclas[i]; &#125; for (int i = 0; i &lt; totNums; i++)scanf("%lf", k + i); int fr, to;double dist; for (int i = 0; i &lt; totRoad; i++) &#123; scanf("%d%d%lf", &amp;fr, &amp;to, &amp;dist); --fr; --to; dis[fr][to] = dis[to][fr] = std::min(dis[fr][to], dist); &#125; //Floyd for (int via = 0; via &lt; totClass; via++) for (int i = 0; i &lt; totClass; i++) for (int j = 0; j &lt; totClass; j++) dis[i][j] = std::min(dis[i][j], dis[i][via] + dis[via][j]); for (int i = 0; i &lt; MAXM; i++)dis[i][i] = 0; for (int i = 0; i &lt; MAXN; i++)for (int j = 0; j &lt; MAXN; j++)D[i][j][0] = D[i][j][1] = INT_MAX; D[0][0][false] = 0; D[0][1][true] = 0; for (int i = 1; i &lt; totNums; i++) &#123; D[i][0][false] = D[i - 1][0][false] + dis[clas[i - 1]][clas[i]]; for (int j = 1; j &lt;= totChange &amp;&amp; j &lt;= i + 1; j++) &#123; D[i][j][false] = std::min( D[i - 1][j][false] + dis[clas[i - 1]][clas[i]], D[i - 1][j][true] + dis[dclas[i - 1]][clas[i]] * k[i - 1] + dis[clas[i - 1]][clas[i]] * (1 - k[i - 1]) ); D[i][j][true] = std::min( D[i - 1][j - 1][false] + dis[clas[i - 1]][clas[i]] * (1 - k[i]) + dis[clas[i - 1]][dclas[i]] * k[i], D[i - 1][j - 1][true] + dis[clas[i - 1]][clas[i]] * (1 - k[i - 1])*(1 - k[i]) + dis[clas[i - 1]][dclas[i]] * (1 - k[i - 1])*k[i] + dis[dclas[i - 1]][clas[i]] * k[i - 1] * (1 - k[i]) + dis[dclas[i - 1]][dclas[i]] * k[i - 1] * k[i] ); &#125; &#125; double min = INT_MAX; for (int i = 0; i &lt;= totChange; i++) min = std::min(min, std::min(D[totNums - 1][i][false], D[totNums - 1][i][true])); printf("%.2lf\n", min); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】高斯消元法]]></title>
    <url>%2F2018%2F12%2F31%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95%2F</url>
    <content type="text"><![CDATA[高斯消元法可以用于求解一个 $n$ 元一次方程组，形如关于 $a_0,a_1,\cdots,a_{n-1}$ 的方程组： \begin{cases} k_{0,0}a_0+k_{0,1}a_1+\cdots+k_{0,n-1}a_{n-1}=b_0\\ k_{1,0}a_0+k_{1,1}a_1+\cdots+k_{1,n-1}a_{n-1}=b_1\\ \qquad\vdots\\ k_{n-1,0}a_0+k_{n-1,1}a_1+\cdots+k_{n-1,n-1}a_{n-1}=b_{n-1}\\ \end{cases} 如果这个方程组有解，那么它一定是有唯一解的。 我们可以将上述方程组转换为一个规格为 $n\times (n+1)$ 的矩阵： \begin{bmatrix} k_{0.0}&k_{0,1}&\cdots&k_{0.n-1}&b_0\\ k_{1,0}&k_{1,1}&\cdots&k_{1,n-1}&b_1\\ \vdots&\vdots&\ddots&\vdots&\vdots\\ k_{n-1,0}&k_{n-1,1}&\cdots&k_{n-1,n-1}&b_{n-1} \end{bmatrix} 高斯消元的思想是，一行行地处理这个矩阵，如果当前位于第 $i$ 行，那么就通过变换，将 $i+1$ 至 $n$ 行中第 $i$ 列的系数化为0. 按照这个思路，到达最后一行时就只剩下一个般形式的一元一次方程： ta_{n-1}=s这个方程的解是显然的，求出了一个未知数的解，即可回代到之前的方程中，可以发现第 $n-1$ 行中也只有一个未知数了。这样一路计算下去，就可以知道所有未知数的解。 在某些情况下，一个方程组是无解或者有无限组解的，这样的方程组可以在计算途中判断出来是否是这样。方法是在所有除法之前检查除数是否为0. 总时间复杂度为 $O(N^3)$, 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 100;double Matrix[MAXN][MAXN + 1];bool Gauss(const int &amp;totLine)&#123; int targLine; double x; for (int nowLine = 0; nowLine &lt; totLine; nowLine++) &#123; targLine = nowLine; for (int i = nowLine + 1; i &lt; totLine; i++) if (fabs(Matrix[i][nowLine]) &gt; fabs(Matrix[targLine][nowLine])) targLine = i; if (targLine != nowLine) for (int i = 0; i &lt;= totLine; i++)std::swap(Matrix[nowLine][i], Matrix[targLine][i]); //消掉后面每一行中 nowLine 列的元 for (targLine = nowLine + 1; targLine &lt; totLine; targLine++) &#123; if (Matrix[nowLine][nowLine] == 0)return false; x = Matrix[targLine][nowLine] / Matrix[nowLine][nowLine]; for (int i = nowLine + 1; i &lt;= totLine; i++) Matrix[targLine][i] -= x * Matrix[nowLine][i]; &#125; &#125; //回代 for (int nowLine = totLine - 1; nowLine &gt;= 0; nowLine--) &#123; for (int i = nowLine + 1; i &lt; totLine; i++) Matrix[nowLine][totLine] -= Matrix[i][totLine] * Matrix[nowLine][i]; if (Matrix[nowLine][nowLine] == 0)return false; Matrix[nowLine][totLine] /= Matrix[nowLine][nowLine]; &#125;return true;&#125;signed main(void)&#123; int totLine; scanf("%d", &amp;totLine); for (int i = 0; i &lt; totLine; i++) for (int j = 0; j &lt;= totLine; j++) scanf("%lf", Matrix[i] + j); if (!Gauss(totLine))puts("No Solution"); else for (int i = 0; i &lt; totLine; i++) printf("%.2lf\n", Matrix[i][totLine]); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】Manacher]]></title>
    <url>%2F2018%2F12%2F30%2FManacher%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)51000000;char s[MAXN &lt;&lt; 1], str[MAXN];int RL[MAXN];int Manacher(void) &#123; size_t len = strlen(str); *s = '#'; for (int i = 0; i &lt; len; i++) &#123; s[(i &lt;&lt; 1) + 1] = str[i]; s[(i &lt;&lt; 1) + 2] = '#'; &#125;len &lt;&lt;= 1; int max = 0, pos, maxRight = -1; memset(RL, 0, sizeof(RL)); for (int i = 0; i &lt; len; i++) &#123; if (i &lt; maxRight) RL[i] = std::min(RL[(pos &lt;&lt; 1) - i], maxRight - i); else RL[i] = 1; while (i - RL[i] &gt;= 0 &amp;&amp; i + RL[i] &lt;= len &amp;&amp; s[i - RL[i]] == s[i + RL[i]])++RL[i]; if (i + RL[i] &gt; maxRight) &#123; pos = i; maxRight = i + RL[i]; &#125; max = std::max(max, RL[i] - 1); &#125; return max;&#125;signed main(void)&#123; int totLines = 1; //std::cin &gt;&gt; totLines; while (totLines--) &#123; std::cin &gt;&gt; str; std::cout &lt;&lt; Manacher() &lt;&lt; std::endl; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四边形不等式优化动态规划]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[前一段时间照着题解打出了诗人小G，这是一道非常标准的四边形不等式优化动态规划题目。这里总结方法并给出部分结论的证明。 这里还是以此题目为例，探究一维四边形不等式优化动态规划的方法。 定义一般来讲，如果定义在整数集合上的二元函数 $w$ 则在其定义域上 \forall a\leq b\leq c\leq d\qquad w(a,d)+w(b,c)\ge w(a,c)+w(b,d)或者 \forall a]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】左偏树]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%B7%A6%E5%81%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 100051;struct Node &#123; int val, dis; int lft, rgt, up;&#125;;Node tr[MAXN];int Merge(int a, int b) &#123; if (a == 0 || b == 0) return a + b; if (tr[a].val &gt; tr[b].val || (tr[a].val == tr[b].val &amp;&amp; a &gt; b)) std::swap(a, b); tr[a].rgt = Merge(tr[a].rgt, b); tr[tr[a].rgt].up = a; if (tr[tr[a].rgt].dis &gt; tr[tr[a].lft].dis)std::swap(tr[a].lft, tr[a].rgt); tr[a].dis = tr[tr[a].rgt].dis + 1; return a;&#125;signed main(void)&#123; int totNums, totOpt, opt, x, y; scanf("%d%d", &amp;totNums, &amp;totOpt); tr-&gt;dis = -1; for (int i = 1; i &lt;= totNums; i++) &#123; tr[i].up = tr[i].lft = tr[i].rgt = 0; scanf("%d", &amp;tr[i].val); &#125; while (totOpt--) &#123; scanf("%d", &amp;opt); switch (opt) &#123; case 1: scanf("%d%d", &amp;x, &amp;y); if (tr[x].val == -1 || tr[y].val == -1)break; while (tr[x].up)x = tr[x].up; while (tr[y].up)y = tr[y].up; if (x == y)break; Merge(x, y); break; case 2: scanf("%d", &amp;x); if (tr[x].val == -1) &#123; puts("-1"); break; &#125; while (tr[x].up)x = tr[x].up; printf("%d\n", tr[x].val); tr[x].val = -1; tr[tr[x].rgt].up = tr[tr[x].lft].up = 0; Merge(tr[x].lft, tr[x].rgt); break; default: puts("UKE"); assert(false); &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】拉拉队排练]]></title>
    <url>%2F2018%2F12%2F30%2F%E6%8B%89%E6%8B%89%E9%98%9F%E6%8E%92%E7%BB%83%2F</url>
    <content type="text"><![CDATA[LG题目地址在这里. 首先，我们先求出以每一个位置为对称轴的最长回文串长度，这样的位置有 $n\times 2-1$ 个，然后将这些数排序，去掉偶数，得到一个数组 $a$. 需要注意的是，如果存在一个足够大的 $a_i$，那么它不仅代表原串中以某一个对称轴有长度为 $a_i$ 的回文子串，同时在那个对称轴也存在长度为 $a_i-2,\,a_i-4,\cdots$ 这些长度的回文子串。 在具体实现中，使用 Manacher 算法、桶排序和快速幂优化，可以将时间复杂度降低到 $O(N\log N)$. 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)1e6 + (int)5e5;constexpr auto MOD = 19930726LL;char str[MAXN], s[MAXN &lt;&lt; 1]; int RL[MAXN &lt;&lt; 1], book[MAXN &lt;&lt; 1];void Manacher(int&amp; len) &#123; *s = '#'; for (int i = 0; i &lt; len; i++) &#123; s[(i &lt;&lt; 1) + 1] = str[i]; s[i + 1 &lt;&lt; 1] = '#'; &#125;len &lt;&lt;= 1; int pos, maxRight = -1; for (int i = 0; i &lt;= len; i++) &#123; if (i &lt; maxRight)RL[i] = std::min(maxRight - i, RL[(pos &lt;&lt; 1) - i]); else RL[i] = 1; while (i - RL[i] &gt;= 0 &amp;&amp; i + RL[i] &lt;= len &amp;&amp; s[i + RL[i]] == s[i - RL[i]])++RL[i]; if (i + RL[i] &gt; maxRight) &#123; maxRight = i + RL[i]; pos = i; &#125; &#125;&#125;template&lt;typename T&gt;T Pow(T a, T b, const T&amp; mod = MOD) &#123; T ret = 1; for (; b &gt; 0; b &gt;&gt;= 1, (a *= a) %= mod) if (b &amp; 1)(ret *= a) %= mod; return ret;&#125;signed main(void)&#123; int totNums, range; long long K, ans = 1; scanf("%d%I64d%s", &amp;totNums, &amp;K, str); Manacher(totNums); for (int i = 1; i &lt; totNums; i++)++book[RL[i] - 1]; totNums |= 1; long long cnt = 0; for (int i = totNums; i &gt; 0; i -= 2) &#123; cnt += book[i]; if (cnt &lt;= 0)continue; if (cnt &lt; K) &#123; K -= cnt; (ans *= Pow((long long)i, cnt)) %= MOD; &#125; else &#123; (ans *= Pow((long long)i, K)) %= MOD; K = 0; break; &#125; &#125; if (K &lt;= 0)printf("%lld\n", ans); else puts("-1"); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>模拟</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斜率优化动态规划]]></title>
    <url>%2F2018%2F12%2F27%2F%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92%2F</url>
    <content type="text"><![CDATA[以题目&lt;任务安排&gt;为例。LG题目地址在这里. 经历了接近5个月的学习与摸索，我终于对斜率优化动态规划的思想有了清晰的抽象认识。在大多数（尤其是与数学有关的）题目中，我们可以发现，容易理解，较为形象的代码和算法实现总是为超时超空间，而往往是那些非常抽象的算法，能够很好地解题。 这是一道非常简单的动态规划题目，直接写出状态转移方程如下： F(i)=\min\{F(j)+T_i(C_i-C_j)+S(C_n-C_j)\}其中 $F(i)$ 代表完成前 $i$ 个任务需要的时间（这里将后面的暖机花费也考虑了进去），记第 $i$ 个任务的费用系数为 $cost_i$, 需要时间为 $time_i$, 暖机一次耗费时间为 $S$. $T_j=\sum_{i=1}^jtime_i\quad C_j=\sum_{i=1}^jcost_i$. 去掉 $\min$ 函数，将 $j$ 看为常量。整理得 F(j)=(T_i+S)C_j+F_i-C_iT_i-SC_n一条直线的解析式是 $f(x)=kx+b$. 与上述形式上类似，如果我们现在需要求 $F_i$. 那么这个一次函数的斜率是确定的，截距未知，一旦截距确定，可以轻易地算出 $F_i$. 经过观察可以发现，一旦确定了 $j$, 等同于在笛卡尔平面直角坐标系中确定了一个点 $(C_j,F_j)$. 这个点就是先前某一次计算出的一个结果，所以我们只需要在所有的点中，找到令截距最小的即可。从几何意义上来看，我们就是将一条斜率已经确定的直线自下而上平移，直到碰到了一个点，就停止下来，执行转移。 运用斜率优化的一个条件就是，随着 $i$ 的增大，斜率单调递增，另外，可以确定 $C_j$ 单调递增，所以后加入的点一定在先前的点的右方，如果任意三点形成了一个上凸壳，那么中间一点永远不可能取到，这一点从代数和几何角度都很好证明，而如果最左边两点的斜率小于直线斜率，那么说明右点比左点更优，而且此后左点永远不可能再次成为最优决策点。 这样一来，整个坐标系中的点可以用一个单调队列进行维护，始终保持斜率的单调递增，将相邻两点斜率小于目前直线斜率的左点视作无用的点及时地删去，然后在插入的时候维护下凸壳性质即可。 这样队头元素即为目前的最优决策点，直接使用这个点执行状态转移。寻找最优决策点的时间复杂度变成了均摊 $O(1)$. 在没有改变状态转移方程的情况下，将整个算法从 $O(N^2)$ 优化到了 $O(N)$. 对于这道题目，代码如下： 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;int main()&#123; constexpr auto MAXN = 5000 + 50; int totMission, warmTime, time[MAXN] = &#123;&#125;, cost[MAXN] = &#123;&#125;; int que[MAXN] = &#123;0&#125;, *head = que, *tail = que; int D[MAXN] = &#123;&#125;; scanf("%d%d", &amp;totMission, &amp;warmTime); for (int i = 1; i &lt;= totMission; i++)scanf("%d%d", time + i, cost + i); for (int i = 1; i &lt;= totMission; i++)time[i] += time[i - 1], cost[i] += cost[i - 1]; for (int i = 1; i &lt;= totMission; i++) &#123; while (head &lt; tail/*队列中至少有两个元素*/ and D[*(head + 1)] - D[*head] &lt; (time[i] + warmTime)*(cost[*(head + 1)] - cost[*head]) /*斜率小于直线斜率*/ )++head; D[i] = D[*head] - cost[*head] * (time[i] + warmTime) + cost[i] * time[i] + warmTime * cost[totMission]; //直接使用队头最为最优决策点执行状态转移 //删除队尾多余元素 while (head &lt; tail and (D[i] - D[*tail])*(cost[*tail] - cost[*(tail - 1)]) &lt; (D[*tail] - D[*(tail - 1)])*(cost[i] - cost[*tail]) )--tail; *++tail = i; &#125; printf("%d\n", D[totMission]); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率优化动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【API】Splay]]></title>
    <url>%2F2018%2F12%2F25%2FSplay%2F</url>
    <content type="text"><![CDATA[圣诞节到了，给自己种了一棵双旋 Splay 平衡树。 What has come into being in him was life, and the life was the light of all people. The light shines in the darkness, and the darkness did not overcome it. ——John 1-4,5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include&lt;bits/stdc++.h&gt;template&lt;typename type&gt;class Splay_Tree&#123;protected:#define ROTATE_LEFT 0#define ROTATE_RIGHT 1private: struct Node &#123; type val; size_t cnt, size; Node *up, *ch[2]; int Comp(const type &amp;CompVal)const &#123; if (CompVal == val)return -1; else return CompVal &lt; val ? 0 : 1; &#125; Node&amp; Refresh(void) &#123; size = cnt; if (ch[0] != nullptr)size += ch[0]-&gt;size; if (ch[1] != nullptr)size += ch[1]-&gt;size; return *this; &#125; bool Exist(void) const &#123; return cnt &gt; 0; &#125; &#125;*root = nullptr; Node* NewNode() &#123; Node* ret = (Node*)malloc(sizeof(Node)); ret-&gt;up = ret-&gt;ch[0] = ret-&gt;ch[1] = nullptr; return ret; &#125; void Rotate(Node *&amp;targ) &#123; Node* fa = targ-&gt;up; const int position = fa-&gt;Comp(targ-&gt;val) ^ 1; fa-&gt;ch[position ^ 1] = targ-&gt;ch[position]; if (targ-&gt;ch[position] != nullptr) targ-&gt;ch[position]-&gt;up = fa; targ-&gt;ch[position] = fa; targ-&gt;up = fa-&gt;up; fa-&gt;up = targ; fa-&gt;Refresh(); targ-&gt;Refresh(); &#125; void Splay(Node *nowAt) &#123; for (; nowAt-&gt;up != nullptr &amp;&amp; nowAt-&gt;up != root; Rotate(nowAt)) if (nowAt-&gt;up-&gt;Comp(nowAt-&gt;val) == nowAt-&gt;up-&gt;up-&gt;Comp(nowAt-&gt;up-&gt;val)) Rotate(nowAt-&gt;up); else Rotate(nowAt); if (nowAt-&gt;up == root)Rotate(nowAt); root = nowAt; &#125; void Insert(Node* ins) &#123; Node* nowAt = root; int nxt; while (true) &#123; nxt = nowAt-&gt;Comp(ins-&gt;val); nowAt-&gt;size += ins-&gt;size; if (nowAt-&gt;ch[nxt] == nullptr) &#123; nowAt-&gt;ch[nxt] = ins; ins-&gt;up = nowAt; Splay(nowAt-&gt;ch[nxt]); return; &#125; else nowAt = nowAt-&gt;ch[nxt]; &#125; &#125; void AccessRoot(void) &#123; if (root-&gt;Exist())return; Node* del = root; if (root-&gt;ch[0] == nullptr&amp;&amp;root-&gt;ch[1] == nullptr) &#123; free(del); root = nullptr; return; &#125; else if (root-&gt;ch[0] == nullptr) &#123; root = root-&gt;ch[1]; root-&gt;up = nullptr; &#125; else if (root-&gt;ch[1] == nullptr) &#123; root = root-&gt;ch[0]; root-&gt;up = nullptr; &#125; else &#123; Node *a = root-&gt;ch[0]; root = root-&gt;ch[1]; root-&gt;up = nullptr; Insert(a); &#125;free(del); &#125;public: Splay_Tree&amp; Insert(const type&amp; ins) &#123; if (root == nullptr) &#123; root = NewNode(); root-&gt;cnt = root-&gt;size = 1; root-&gt;val = ins; return *this; &#125; Node* nowAt = root; int nxt; while(true) &#123; nxt = nowAt-&gt;Comp(ins); nowAt-&gt;size++; if (nxt == -1) &#123; nowAt-&gt;cnt++; Splay(nowAt); return *this; &#125; if (nowAt-&gt;ch[nxt] == nullptr) &#123; nowAt-&gt;ch[nxt] = NewNode(); nowAt-&gt;ch[nxt]-&gt;up = nowAt; nowAt-&gt;ch[nxt]-&gt;val = ins; nowAt-&gt;ch[nxt]-&gt;cnt = nowAt-&gt;ch[nxt]-&gt;size = 1; Splay(nowAt-&gt;ch[nxt]); return *this; &#125; else nowAt = nowAt-&gt;ch[nxt]; &#125; &#125; type KthElement(const size_t &amp;kth) &#123; Node* nowAt = root; size_t cnt = 0; while (nowAt != nullptr) &#123; if (nowAt-&gt;ch[0] != nullptr) &#123; if ((cnt + nowAt-&gt;ch[0]-&gt;size) &lt; kth) cnt += nowAt-&gt;ch[0]-&gt;size; else &#123; nowAt = nowAt-&gt;ch[0]; continue; &#125; &#125; if (cnt &lt; kth &amp;&amp; kth &lt;= cnt + nowAt-&gt;cnt) &#123; Splay(nowAt); return root-&gt;val; &#125; cnt += nowAt-&gt;cnt; nowAt = nowAt-&gt;ch[1]; &#125; throw 1; &#125; size_t GetPosition(const type&amp; query) &#123; size_t cnt = 0; Node* nowAt = root; while (nowAt != nullptr) &#123; if (nowAt-&gt;val &gt; query) &#123; nowAt = nowAt-&gt;ch[0]; continue; &#125; if (nowAt-&gt;ch[0] != nullptr)cnt += nowAt-&gt;ch[0]-&gt;size; if (nowAt-&gt;val == query) &#123; Splay(nowAt); return cnt + 1; &#125; cnt += nowAt-&gt;cnt; nowAt = nowAt-&gt;ch[1]; &#125;throw - 1; &#125; type Upper(const type &amp;lower) &#123; bool found = false; type match; Node* nowAt = root, *targ; while (nowAt != nullptr) &#123; if (nowAt-&gt;val &gt; lower) &#123; found = true; match = nowAt-&gt;val; targ = nowAt; nowAt = nowAt-&gt;ch[0]; &#125; else nowAt = nowAt-&gt;ch[1]; &#125; if (found) &#123; Splay(targ); return match; &#125; else throw 1; &#125; type Lower(const type &amp;Upper) &#123; bool found = false; type match; Node* nowAt = root, *targ; while (nowAt != nullptr) &#123; if (nowAt-&gt;val &lt; Upper) &#123; found = true; match = nowAt-&gt;val; targ = nowAt; nowAt = nowAt-&gt;ch[1]; &#125; else nowAt = nowAt-&gt;ch[0]; &#125; if (found) &#123; Splay(targ); return match; &#125; else throw 1; &#125; Splay_Tree&amp; Delete(const type &amp;val) &#123; Node* nowAt = root; int nxt; while (nowAt != nullptr) &#123; --nowAt-&gt;size; if (nowAt-&gt;val == val) &#123; --nowAt-&gt;cnt; Splay(nowAt); AccessRoot(); return *this; &#125; nowAt = nowAt-&gt;ch[nowAt-&gt;Comp(val)]; &#125;throw 1; &#125;&#125;;Splay_Tree&lt;int&gt; tr;signed main(void)&#123; int totOptn, opt; int val; scanf("%d", &amp;totOptn); while (totOptn--) &#123; scanf("%d%d", &amp;opt, &amp;val); switch (opt) &#123; case 1: tr.Insert(val); break; case 2: tr.Delete(val); break; case 3: printf("%d\n", tr.GetPosition(val)); break; case 4: printf("%d\n", tr.KthElement(val)); break; case 5: printf("%d\n", tr.Lower(val)); break; case 6: printf("%d\n", tr.Upper(val)); break; default: puts("UKE"); assert(false); break; &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG1251 餐巾计划问题]]></title>
    <url>%2F2018%2F12%2F23%2FLG1251-%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目在这里. 这道题目的大致意思是，一个餐厅在接下来 $n$ 天中第 $i$ 天需要使用 $r_i$ 块餐巾，有一个快洗部和慢洗部洗涤一块餐巾的时间分别为 $t_a,\,t_b$, 费用分别为 $c_a,c_b$, 购买一条新的餐巾费用为 $c$. 一开始没有任何餐巾，求 $n$ 天之后的最小花费。 这题可以非常巧妙地使用网络流求解，首先我们将每一天拆分成两个结点：白昼和夜晚，建立虚拟源点和汇点，然后按照如下方式建模： 将源点同每一天的白昼相连，容量为 $\infin$ 费用为 $c$. 代表购买餐巾。 将每一天的白昼与汇点相连，容量为 $r_i$ 费用为 $0$. 代表使用掉一条餐巾。 将源点与每一天的夜晚相连，容量为 $r_i$ 费用为 0. 代表这一天白昼产生的脏餐巾。 将每一天的夜晚同后一天夜晚相连，容量为 $\infin$ 费用为 0. 代表保留一条脏餐巾到下一天。 将每一天的夜晚同后 $t_a$ 天的白昼相连，容量为 $\infin$ 费用为 $c_a$. 代表快洗一条餐巾。 将每一天的夜晚同后 $t_b$ 天的白昼相连，容量为 $\infin$ 费用为 $c_b$. 代表慢洗一条餐巾。 注意有些情况下可能会超出范围，这时就不建立相应的边，因为相应的操作不可能存在。 建好模型之后，直接跑一遍最小费用最大流，即可求得答案。 接下来我们考虑为什么这么做是正确的。 首先看看最小割，可以发现尽管当中有很多容量为 $\infin$ 的边，但是所有与汇点相连接的边，容量都是 $r_i$. 因此最大流就是 $\sum r_i$. 算法跑完这些容量一定都是跑满了的，这正好符合题意。唯一一点令人匪夷所思的是源点与夜晚的连边，这条边代表的是这一天白昼产生的脏餐巾，但是由于流到白昼结点的流量的唯一出路就是汇点，所以无法处理脏餐巾，因此才从汇点无费用地流出当天使用量的脏餐巾。同时可以保存干净餐巾以后使用，这与保存脏餐巾是同样的，为了让白昼结点所有的流量流向汇点，这里的策略是保留脏餐巾。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 5500;struct Edge &#123; int fr, to; long long residual, cost;&#125;;std::vector&lt;Edge&gt; edges; std::vector&lt;int&gt; G[MAXN];void AddEdge(const int &amp;fr, const int &amp;to, const long long &amp;cap, const long long &amp;cost) &#123; G[fr].push_back(edges.size()); edges.push_back(&#123; fr,to,cap,cost &#125;); G[to].push_back(edges.size()); edges.push_back(&#123; to,fr,0,-cost &#125;);&#125;bool inQueue[MAXN];int s, t; long long minCost, maxFlow;long long flow[MAXN], cost[MAXN]; int last[MAXN];bool SPFA(void) &#123; memset(inQueue, false, sizeof(inQueue)); std::fill(cost, cost + MAXN, INT64_MAX); std::queue&lt;int&gt; que; que.push(s); inQueue[s] = true; flow[s] = INT64_MAX; cost[s] = 0; int nowAt; while (!que.empty()) &#123; inQueue[nowAt = que.front()] = false; que.pop(); for (int i = 0; i &lt; G[nowAt].size(); i++) &#123; auto&amp; it = edges[G[nowAt][i]]; if (it.residual &gt; 0 &amp;&amp; cost[it.to] &gt; cost[nowAt] + it.cost) &#123; cost[it.to] = cost[nowAt] + it.cost; flow[it.to] = std::min(flow[nowAt], it.residual); last[it.to] = G[nowAt][i]; if (!inQueue[it.to]) &#123; inQueue[it.to] = true; que.push(it.to); &#125; &#125; &#125; &#125; if (cost[t] == INT64_MAX)return false; maxFlow += flow[t]; minCost += flow[t] * cost[t]; nowAt = t; while (nowAt != s) &#123; edges[last[nowAt]].residual -= flow[t]; edges[last[nowAt] ^ 1].residual += flow[t]; nowAt = edges[last[nowAt]].fr; &#125;return true;&#125;void MCMF(void) &#123; minCost = 0; maxFlow = 0; while (SPFA());&#125;signed main(void)&#123; int totNums, in, slow, fast; int need[MAXN], pri, fwsh_pr, slsh_pr, fw_day, sl_day; //Read scanf("%d", &amp;totNums); s = 0; t = (totNums &lt;&lt; 1) + 1; slow = t + 1; fast = t + 2; for (int i = 1; i &lt;= totNums; i++)scanf("%d", need + i); scanf("%d%d%d%d%d", &amp;pri, &amp;fw_day, &amp;fwsh_pr, &amp;sl_day, &amp;slsh_pr); //Build for (int i = 1; i &lt;= totNums; i++)AddEdge(i, t, need[i], 0); for (int i = 1; i &lt;= totNums; i++)AddEdge(s, i, INT64_MAX, pri); for (int i = 1; i &lt;= totNums; i++)AddEdge(s, totNums + i, need[i], 0); for (int i = fw_day + 1; i &lt;= totNums; i++)AddEdge(i - fw_day + totNums, i, INT64_MAX, fwsh_pr); for (int i = sl_day + 1; i &lt;= totNums; i++)AddEdge(i - sl_day + totNums, i, INT64_MAX, slsh_pr); for (int i = totNums + 2; i &lt; t; i++)AddEdge(i - 1, i, INT64_MAX, 0); MCMF(); printf("%lld\n", minCost); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG4014 分配问题]]></title>
    <url>%2F2018%2F12%2F23%2FLG4014-%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目在这里. 首先，建立源点和汇点，由于每个人只能做一个工作，所以从源点向每一个人连容量为0，费用为0的边，汇点也类似。对于每一个工作产生的利益 $c_{i,j}$, 在第 $i$ 个人和第 $j$ 个工作之间连接一条容量为1，费用为 $c_{i,j}$ 的边，这么做求出来的就是最小值。 至于最大值需要跑一边最大费用最大流，先将之前建立的模型销毁，然后源点和汇点还是照常连边，人和工作之间连接的边费用为 $-c_{i,j}$. 然后还是执行相同的算法，将求得的最小费用取相反数，即为所求值。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 250;struct Edge &#123; int fr, to; long long residual, cost;&#125;;std::vector&lt;Edge&gt;edges; std::vector&lt;int&gt; G[MAXN];void AddEdge(const int &amp;fr, const int &amp;to, const long long &amp;cap, const long long &amp;cost) &#123; G[fr].push_back(edges.size()); edges.push_back(&#123; fr,to,cap,cost &#125;); G[to].push_back(edges.size()); edges.push_back(&#123; to,fr,0,-cost &#125;);&#125;int s, t; long long minCost, maxFlow;bool inQueue[MAXN];int last[MAXN];long long cost[MAXN], flow[MAXN];bool SPFA(void) &#123; memset(inQueue, false, sizeof(inQueue)); std::fill(cost, cost + MAXN, INT64_MAX); std::queue&lt;int&gt; que; que.push(s); inQueue[s] = true; cost[s] = 0; flow[s] = INT64_MAX; int nowAt; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); inQueue[nowAt] = false; for (int i = 0; i &lt; G[nowAt].size(); i++) &#123; Edge&amp; it = edges[G[nowAt][i]]; if (it.residual &gt; 0 &amp;&amp; cost[it.to] &gt; cost[nowAt] + it.cost) &#123; cost[it.to] = cost[nowAt] + it.cost; last[it.to] = G[nowAt][i]; flow[it.to] = std::min(flow[nowAt], it.residual); if (!inQueue[it.to]) &#123; que.push(it.to); inQueue[it.to] = true; &#125; &#125; &#125; &#125; if (cost[t] == INT64_MAX)return false; maxFlow += flow[t]; minCost += flow[t] * cost[t]; nowAt = t; while (nowAt != s) &#123; edges[last[nowAt]].residual -= flow[t]; edges[last[nowAt] ^ 1].residual += flow[t]; nowAt = edges[last[nowAt]].fr; &#125;return true;&#125;void MCMF(void) &#123; minCost = 0; maxFlow = 0; while (SPFA());&#125;signed main()&#123; int totNums; long long x[MAXN][MAXN] = &#123;&#125;, res; scanf("%d", &amp;totNums); s = 0; t = 1 + (totNums &lt;&lt; 1); for (int i = 1; i &lt;= totNums; i++) &#123; AddEdge(s, i, 1, 0); AddEdge(totNums + i, t, 1, 0); for (int j = totNums + 1; j &lt;= (totNums &lt;&lt; 1); j++) &#123; scanf("%lld", x[i] + j); AddEdge(i, j, 1, -x[i][j]); &#125; &#125;MCMF(); res = -minCost; edges.clear(); for (int i = 0; i &lt; MAXN; i++)G[i].clear(); for (int i = 1; i &lt;= totNums; i++) &#123; AddEdge(s, i, 1, 0); AddEdge(totNums + i, t, 1, 0); for (int j = totNums + 1; j &lt;= (totNums &lt;&lt; 1); j++)AddEdge(i, j, 1, x[i][j]); &#125;MCMF(); printf("%lld\n%lld\n", minCost, res); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG4016 负载平衡问题]]></title>
    <url>%2F2018%2F12%2F23%2FLG4016-%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这道题目表面上看与均分纸牌十分相似，但由于是一个环，所以不能用原先的方法解决。这题有相应的数学方法，这里讨论网络流解法。 建立源点和汇点，如果一个点大于平均值则从源点引入一条边，如果大于则从它引入一条边到汇点。然后在相邻的点之间两两连边，调整一下每条边的流量和花费，跑一边最小费用最大流就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 150;struct Edge &#123; int fr, to;long long cost, residual;&#125;;std::vector&lt;Edge&gt; edges; std::vector&lt;int&gt; G[MAXN];void AddEdge(const int &amp;fr, const int &amp;to, const long long &amp;cost, const long long &amp;cap) &#123; G[fr].push_back(edges.size()); edges.push_back(&#123; fr,to,cost,cap &#125;); G[to].push_back(edges.size()); edges.push_back(&#123; to,fr,-cost,0 &#125;);&#125;int s = 0, t;long long maxFlow, minCost;long long last[MAXN], flow[MAXN], cost[MAXN];bool inQueue[MAXN];bool SPFA() &#123; memset(inQueue, false, sizeof(inQueue)); std::fill(cost, cost + MAXN, INT64_MAX); std::queue&lt;int&gt;que; que.push(s); last[s] = -1; flow[s] = INT64_MAX; cost[s] = 0; int nowAt; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); inQueue[nowAt] = false; for (int i = 0; i &lt; G[nowAt].size(); i++) &#123; Edge&amp; it = edges[G[nowAt][i]]; if (it.residual &gt; 0 &amp;&amp; cost[it.to] &gt; cost[nowAt] + it.cost) &#123; cost[it.to] = cost[nowAt] + it.cost; flow[it.to] = std::min(it.residual, flow[nowAt]); last[it.to] = G[nowAt][i]; if (!inQueue[it.to]) &#123; inQueue[it.to] = true; que.push(it.to); &#125; &#125; &#125; &#125; if (cost[t] == INT64_MAX)return false; nowAt = t; maxFlow += flow[t]; minCost += flow[t] * cost[t]; while (nowAt != s) &#123; edges[last[nowAt]].residual -= flow[t]; edges[last[nowAt] ^ 1].residual += flow[t]; nowAt = edges[last[nowAt]].fr; &#125;return true;&#125;void MCMF() &#123; maxFlow = 0; minCost = 0; while (SPFA());&#125;int main()&#123; long long totNums, num[MAXN] = &#123;&#125;, ava = 0; scanf("%lld", &amp;totNums); t = totNums + 1; for (int i = 1; i &lt;= totNums; i++) &#123; scanf("%lld", num + i); ava += num[i]; &#125; ava /= totNums; //Build for (int i = 1; i &lt;= totNums; i++) if (num[i] &gt; ava) AddEdge(s, i, 0, num[i] - ava); else if (num[i] &lt; ava)AddEdge(i, t, 0, ava - num[i]); for (int i = 1; i &lt;= totNums; i++) &#123; AddEdge(i, i%totNums + 1, 1, INT64_MAX); AddEdge(i, i - 1 == 0 ? totNums : i - 1, 1, INT64_MAX); &#125;MCMF(); printf("%lld\n", minCost); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】SA后缀数组]]></title>
    <url>%2F2018%2F12%2F23%2FSA%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)1e6 + 50;constexpr auto SIGMA_SIZE = 200;int sa[MAXN], rank[MAXN];// SA[i] 字典序排名第i是谁// Rank[i] 后缀i字典序排名int wa[MAXN], wb[MAXN], basket[MAXN]/*ws*/;void SA(char* s, int n)&#123; int *x = wa, *y = wb, *t, m = SIGMA_SIZE, i; memset(basket, 0, sizeof(basket)); for (i = 0; i &lt; n; ++i)++basket[x[i] = s[i]]; for (i = 1; i &lt; m; ++i)basket[i] += basket[i - 1]; for (i = n - 1; i &gt;= 0; --i)sa[--basket[x[i]]] = i; for (int j = 1, p = 1; p &lt; n; j &lt;&lt;= 1, m = p) &#123; for (p = 0, i = n - j; i &lt; n; ++i)y[p++] = i; for (i = 0; i &lt; n; ++i)if (sa[i] &gt;= j)y[p++] = sa[i] - j; memset(basket, 0, sizeof(basket)); for (i = 0; i &lt; n; ++i)++basket[x[y[i]]]; for (i = 1; i &lt; m; ++i)basket[i] += basket[i - 1]; for (i = n - 1; i &gt;= 0; --i)sa[--basket[x[y[i]]]] = y[i]; std::swap(x, y); for (p = 1, x[*sa] = 0, i = 1; i &lt; n; ++i) x[sa[i]] = (y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + j] == y[sa[i] + j]) ? p - 1 : p++; &#125;&#125;char s[MAXN];signed main(void)&#123; std::cin &gt;&gt; s; int len = strlen(s); /*for (int i = 0; i &lt; len; i++)printf("%d ", s[i]); putchar('\n');*/ SA(s, len); for (int i = 0; i &lt; len; i++)printf("%d ", sa[i] + 1); putchar('\n'); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】可持久化线段树（主席树）]]></title>
    <url>%2F2018%2F12%2F23%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)2e5 + 500;std::map&lt;int, int&gt; val, mp;struct Node &#123; int fr, to, sum; Node *lft, *rgt; Node&amp; Copy(Node *targ) &#123; fr = targ-&gt;fr; to = targ-&gt;to; sum = targ-&gt;sum; lft = targ-&gt;lft; rgt = targ-&gt;rgt; return *this; &#125;&#125;;Node* NewNode() &#123; Node* ret = (Node*)malloc(sizeof(Node)); ret-&gt;lft = ret-&gt;rgt = nullptr; return ret;&#125;std::vector&lt;Node*&gt; version;int num[MAXN], cnt[MAXN], orig[MAXN], fr[MAXN], to[MAXN], rank[MAXN];std::queue&lt;Node*&gt; que, add;signed main(void)&#123; int totNums, totQuery, cnt; //Read scanf("%d%d", &amp;totNums, &amp;totQuery); for (int i = 0; i &lt; totNums; i++)scanf("%d", num + i); for (int i = 0; i &lt; totQuery; i++)scanf("%d%d%d", fr + i, to + i, rank + i); //Render for (int i = 0; i &lt; totNums; i++) orig[i] = num[i]; std::sort(num, num + totNums); cnt = 0; int tmp; mp[val[0] = *num] = cnt++; for (int i = 1; i &lt; totNums; i++) if (num[i] != num[i - 1]) tmp = cnt,mp[val[tmp] = num[i]] = cnt++; for (int i = 0; i &lt; totNums; i++)::cnt[num[i] = mp[orig[i]]]++; //Build Node *a, *b, *t; for (int i = 0; i &lt; cnt; i++) &#123; t = NewNode(); t-&gt;fr = t-&gt;to = i; t-&gt;sum = ::cnt[i]; que.push(t); &#125; for (; que.size() &gt;= 2; std::swap(que, add)) &#123; while (que.size() &gt;= 2) &#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = NewNode(); t-&gt;fr = a-&gt;fr; t-&gt;to = b-&gt;to; t-&gt;sum = a-&gt;sum + b-&gt;sum; t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if (!que.empty()) &#123; add.push(que.front()); que.pop(); &#125; &#125;version.push_back(que.front()); //New Versions for (int del = 0; del &lt; totNums; del++) &#123; const int &amp;target = num[del]; t = a = NewNode(); b = version.back(); while (true) &#123; a-&gt;Copy(b); a-&gt;sum--; if (a-&gt;fr == target &amp;&amp; a-&gt;to == target)break; if (a-&gt;lft-&gt;fr &lt;= target &amp;&amp; target &lt;= a-&gt;lft-&gt;to) &#123; a-&gt;lft = NewNode(); a = a-&gt;lft; b = b-&gt;lft; &#125; else &#123; a-&gt;rgt = NewNode(); a = a-&gt;rgt; b = b-&gt;rgt; &#125; &#125;version.push_back(t); &#125; //Query int rnk; for (int i = 0; i &lt; totQuery; i++) &#123; a = version[--fr[i]]; b = version[to[i]]; rnk = rank[i]; while (true) &#123; if (a-&gt;lft == nullptr) &#123; printf("%d\n", val[a-&gt;fr]); break; &#125; if (a-&gt;lft-&gt;sum - b-&gt;lft-&gt;sum &gt;= rnk) &#123; a = a-&gt;lft; b = b-&gt;lft; &#125; else &#123; rnk -= a-&gt;lft-&gt;sum - b-&gt;lft-&gt;sum; a = a-&gt;rgt; b = b-&gt;rgt; &#125; &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】ISAP]]></title>
    <url>%2F2018%2F12%2F16%2FISAP%2F</url>
    <content type="text"><![CDATA[与 Dinic 类似，ISAP 算法可以用于解决网络最大流问题。在多数情况下，虽然 Dinic 与 ISAP 复杂度同级，但 ISAP 常数略小于 Dinic. 思想在 Dinic 中，我们通过不断地 BFS 重构层次图，以此加快效率，ISAP 中同样用到了层次图，但是与 Dinic 不同，它并不会频繁地调用 BFS，而是在增广的途中不断修改层次图，而这么做很重要的一个依据就是 每次增广之后，在残量网络中任意节点到汇点的最短距离都不会变得更短。 定义 $d(i) = $ 结点 $i$ 到 $t$ 的最短距离，$cnt(x) = |D_x|$ 其中 $D_x = \{a|d(a)=x\}$. 可以发现，一旦满足下列条件中任意一条，当前残量网络就不能再增广： $d(s)&gt;n$. 存在 $cnt(i)=0$. 与 Dinic 类似，寻找增广路的方法就是从 $s$ 开始不断地往前走，这个过程在 ISAP 中叫做 Advance. 同时记录当前结点是从哪一条边走过来的，记为 $last$ 数组。 123if (depth[it.to] == depth[nowAt] - 1 &amp;&amp; it.residual &gt; 0) &#123; //可行边 last[it.to] = G[nowAt][i]; cur[nowAt] = i; nowAt = it.to; //Advance&#125; 如果无路可走，就直接后退一步，这个过程叫做 Retreat. 同时，我们需要更新一下当前结点的 $d(i)$. 前面提到，如果存在 $cnt(i)=0$ ,那么不能再增广，判断是否满足这个条件也很简单，只用开一个数组记录一下有多少个结点的 $d(i)$ 等于某一特定的数即可。 12345678int m = totNode - 1;for (int i = 0; i &lt; G[nowAt].size(); i++) &#123; Edge&amp; it = edges[G[nowAt][i]]; if (it.residual &gt; 0)m = std::min(m, depth[it.to]);&#125;if (--num[depth[nowAt]] == 0)break; //gapnum[depth[nowAt] = m + 1]++;if (nowAt != s)nowAt = edges[last[nowAt]].fr; 具体地说，在上述代码中 $num_x = \sum_{i\in G} [d(i)=x]$ . 这一步的优化在 ISAP 中叫做 Gap 优化。 除此之外，我们还可以像在 Dinic 中一样，加上当前弧优化。 如果在某一时刻，我们到达了汇点，那么只用从汇点出发，一路沿着 $last$ 往回走，就可以还原整条路径。我们需要重复走两次，一次找到最大增广，另一次修改各个弧的信息。 12345678910111213int Augment() &#123; int deltaFlow = INT_MAX, nowAt = t; while (nowAt != s) &#123; Edge&amp; it = edges[last[nowAt]]; deltaFlow = std::min(deltaFlow, it.residual); nowAt = it.fr; &#125;nowAt = t; while (nowAt != s) &#123; edges[last[nowAt]].residual -= deltaFlow; edges[last[nowAt] ^ 1].residual += deltaFlow; nowAt = edges[last[nowAt]].fr; &#125;return deltaFlow;&#125; 算法流程 构建层次图 定义当前结点为 $s$ 如果当前结点为 $t$ , Augment. 如果 $d(s)\ge n$, 结束算法。 从当前结点出发，寻找是否存在可行弧，存在则前往5，否则跳到6. Advance, 回到3. Retreat. 如果发现 $num=0$ ，结束算法，否则回到3. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 10000 + 50;int s, t, totNode, totEdges;struct Edge &#123; int fr, to, residual;&#125;;std::vector&lt;int&gt; G[MAXN]; std::vector&lt;Edge&gt; edges;int num[MAXN], cur[MAXN], depth[MAXN], last[MAXN];void BFS() &#123; std::queue&lt;int&gt; que; que.push(t); bool inQueue[MAXN]; memset(inQueue, false, sizeof(inQueue)); memset(depth, 0x7f, sizeof(depth)); depth[t] = 0; int nowAt; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); for (const auto &amp;i : G[nowAt]) &#123; Edge&amp; it = edges[i]; if (it.residual == 0) &#123; depth[it.to] = std::min(depth[it.to], depth[nowAt] + 1); if (!inQueue[it.to]) &#123; inQueue[it.to] = true; que.push(it.to); &#125; &#125; &#125; &#125;&#125;int Augment() &#123; int deltaFlow = INT_MAX, nowAt = t; while (nowAt != s) &#123; Edge&amp; it = edges[last[nowAt]]; deltaFlow = std::min(deltaFlow, it.residual); nowAt = it.fr; &#125;nowAt = t; while (nowAt != s) &#123; edges[last[nowAt]].residual -= deltaFlow; edges[last[nowAt] ^ 1].residual += deltaFlow; nowAt = edges[last[nowAt]].fr; &#125;return deltaFlow;&#125;int ISAP() &#123; memset(num, 0, sizeof(num)); memset(cur, 0, sizeof(cur)); BFS(); int flow = 0; for (int i = 1; i &lt;= totNode; i++)if (depth[i] &lt; totNode)num[depth[i]]++; int nowAt = s; while (depth[s] &lt; totNode) &#123; if (nowAt == t) &#123; flow += Augment(); nowAt = s; &#125; //Augment bool OK = false; for (int i = cur[nowAt]; i &lt; G[nowAt].size(); i++) &#123; Edge&amp; it = edges[G[nowAt][i]]; if (depth[it.to] == depth[nowAt] - 1 &amp;&amp; it.residual &gt; 0) &#123; //可行边 OK = true; last[it.to] = G[nowAt][i]; cur[nowAt] = i; nowAt = it.to; //Advance break; &#125; &#125; if (!OK) &#123; //Retreat int m = totNode - 1; for (int i = 0; i &lt; G[nowAt].size(); i++) &#123; Edge&amp; it = edges[G[nowAt][i]]; if (it.residual &gt; 0)m = std::min(m, depth[it.to]); &#125; if (--num[depth[nowAt]] == 0)break; //gap num[depth[nowAt] = m + 1]++; cur[nowAt] = 0; if (nowAt != s)nowAt = edges[last[nowAt]].fr; &#125; &#125; return flow;&#125;int main()&#123; int fr, to, cap; scanf("%d%d%d%d", &amp;totNode, &amp;totEdges, &amp;s, &amp;t); for (int i = 0; i &lt; totEdges; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;cap); edges.push_back(&#123; fr,to,cap &#125;); G[fr].push_back(edges.size() - 1); edges.push_back(&#123; to,fr,0 &#125;); G[to].push_back(edges.size() - 1); &#125;printf("%d\n", ISAP()); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】SPFA最小费用最大流]]></title>
    <url>%2F2018%2F12%2F16%2FSPFA%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 5000 + 50;struct Edge &#123; int fr, to, residual, cost;&#125;;std::vector&lt;Edge&gt;edges; std::vector&lt;int&gt; G[MAXN];int s, t, maxFlow, minCost;int last[MAXN], flow[MAXN], dis[MAXN];bool inQueue[MAXN];bool SPFA() &#123; memset(inQueue, false, sizeof(inQueue)); std::fill(dis, dis + MAXN, INT_MAX); std::queue&lt;int&gt; que; que.push(s); inQueue[s] = true; flow[s] = INT_MAX; last[s] = 0; dis[s] = 0; int nowAt; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); inQueue[nowAt] = false; for (int i = 0; i &lt; G[nowAt].size(); i++) &#123; Edge&amp; it = edges[G[nowAt][i]]; if (it.residual &gt; 0 &amp;&amp; dis[it.to] &gt; dis[nowAt] + it.cost) &#123; dis[it.to] = dis[nowAt] + it.cost; last[it.to] = G[nowAt][i]; flow[it.to] = std::min(flow[nowAt], it.residual); if (!inQueue[it.to]) &#123; inQueue[it.to] = true; que.push(it.to); &#125; &#125; &#125; &#125; if (dis[t] == INT_MAX)return false; maxFlow += flow[t]; minCost += dis[t] * flow[t]; nowAt = t; while (nowAt != s) &#123; edges[last[nowAt]].residual -= flow[t]; edges[last[nowAt] ^ 1].residual += flow[t]; nowAt = edges[last[nowAt]].fr; &#125;return true;&#125;void MCMF() &#123; maxFlow = 0; minCost = 0; while (SPFA());&#125;signed main()&#123; int fr, to, cost, flow; int totNode, totEdges; scanf("%d%d%d%d", &amp;totNode, &amp;totEdges, &amp;s, &amp;t); for (int i = 0; i &lt; totEdges; i++) &#123; scanf("%d%d%d%d", &amp;fr, &amp;to, &amp;flow, &amp;cost); G[fr].push_back(edges.size()); edges.push_back(&#123; fr,to,flow,cost &#125;); G[to].push_back(edges.size()); edges.push_back(&#123; to,fr,0,-cost &#125;); &#125; MCMF(); printf("%d %d\n", maxFlow, minCost); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1077F Pictures with Kittens]]></title>
    <url>%2F2018%2F12%2F11%2FCF1077F-Pictures-with-Kittens%2F</url>
    <content type="text"><![CDATA[这道题目的大致意思是，给定 $n$ 个数，其中第 $i$ 个为 $a_i$, 你要从这些数中选择 $x$ 个，使得它们的和最大，注意这些数中任意连续 $k$ 个数中至少应有一个被选择。 这是一道动态规划题目，定义 $D_{i,j }=$ 考虑前 $i$ 个数，选择 $j$ 个数的最大总和，那么 D_{i,j}=\max(D_{l,j-1}+a_i) \qquad i-k\leq l]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【API】二叉查找树模板]]></title>
    <url>%2F2018%2F12%2F09%2F%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990template&lt;typename type&gt;class bst &#123;private: struct Node &#123; type val; size_t siz, cnt; Node *lft, *rgt; &#125;*root = nullptr; Node* NewNode(const type &amp;val) &#123; Node* ret = (Node*)malloc(sizeof(Node)); ret-&gt;lft = ret-&gt;rgt = nullptr; ret-&gt;siz = ret-&gt;cnt = 1; ret-&gt;val = val; return ret; &#125; void Free(Node* targ) &#123; if (targ-&gt;lft != nullptr)Free(targ-&gt;lft); if (targ-&gt;rgt != nullptr)Free(targ-&gt;rgt); std::free(targ); &#125; void Insert(const type&amp; val, const size_t&amp; cnt, Node* &amp;nowAt) &#123; if (nowAt == nullptr) &#123; nowAt = NewNode(val); nowAt-&gt;cnt = cnt; return; &#125; nowAt-&gt;siz += cnt; if (nowAt-&gt;val == val) &#123; nowAt-&gt;cnt += cnt; return; &#125; Insert(val, cnt, nowAt-&gt;val &gt; val ? nowAt-&gt;lft : nowAt-&gt;rgt); &#125;public: bool IsEmpty() &#123; return root == nullptr; &#125; size_t Size() &#123; return root == nullptr ? 0 : root-&gt;siz; &#125; bst&lt;type&gt;&amp; Clear() &#123; if (root != nullptr) &#123; Free(root); root = nullptr; &#125; return *this; &#125; bst&lt;type&gt;&amp; Insert(const type &amp;val, const size_t&amp; cnt = 1) &#123; if (cnt != 0)Insert(val, cnt, root); return *this; &#125; type KthElement(const size_t &amp;kth) const &#123; Node* nowAt = root; size_t cnt = 0; while (nowAt != nullptr) &#123; if (nowAt-&gt;lft != nullptr) &#123; if ((cnt + nowAt-&gt;lft-&gt;siz) &lt; kth) cnt += nowAt-&gt;lft-&gt;siz; else &#123; nowAt = nowAt-&gt;lft; continue; &#125; &#125; if (cnt &lt; kth &amp;&amp; kth &lt;= cnt + nowAt-&gt;cnt)return nowAt-&gt;val; cnt += nowAt-&gt;cnt; nowAt = nowAt-&gt;rgt; &#125; throw 1; &#125; size_t GetPosition(const type&amp; query) const &#123; size_t cnt = 0; Node* nowAt = root; while (nowAt != nullptr) &#123; if (nowAt-&gt;val &gt; query) &#123; nowAt = nowAt-&gt;lft; continue; &#125; if (nowAt-&gt;lft != nullptr)cnt += nowAt-&gt;lft-&gt;siz; if (nowAt-&gt;val == query)return cnt + 1; cnt += nowAt-&gt;cnt; nowAt = nowAt-&gt;rgt; &#125;throw - 1; &#125; type Upper(const type &amp;lower) const &#123; bool found = false; type match; Node* nowAt = root; while (nowAt != nullptr) &#123; if (nowAt-&gt;val &gt; lower) &#123; found = true; match = nowAt-&gt;val; nowAt = nowAt-&gt;lft; &#125; else nowAt = nowAt-&gt;rgt; &#125; if (found)return match; else throw 1; &#125; type Lower(const type &amp;Upper) const &#123; bool found = false; type match; Node* nowAt = root; while (nowAt != nullptr) &#123; if (nowAt-&gt;val &lt; Upper) &#123; found = true; match = nowAt-&gt;val; nowAt = nowAt-&gt;rgt; &#125; else nowAt = nowAt-&gt;lft; &#125; if (found)return match; else throw 1; &#125; size_t Count(const type &amp;val)const &#123; Node* nowAt = root; while (nowAt != nullptr) &#123; if (nowAt-&gt;val == val)return nowAt-&gt;cnt; else nowAt = nowAt-&gt;val &gt; val ? nowAt-&gt;lft : nowAt-&gt;rgt; &#125; return 0; &#125;&#125;;bst&lt;int&gt; tr;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[放球问题]]></title>
    <url>%2F2018%2F12%2F04%2F%E6%94%BE%E7%90%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[组合数学本质上是求解决一些问题或者达成某一目的的方案数，其中 $C_n^r$ 可以形象地理解为将 $n$ 个没有区别的球放入 $r$ 个没有区别的盒子中的方案数。在实际应用中，我们通常需要加入许多限制条件，例如球和盒子有无区别，是否允许有空盒子存在。这样，可以分为若干个子问题。 记球的个数为 $n$, 盒子个数为 $m$. 默认在不允许有空盒时 $n\ge m$, 因为如果球数量少于盒子数量，那么无解。 下面分情况讨论。 球有区别，盒子有区别，允许空盒子对于每一个球，都有 $m$ 个盒子可以选择，根据乘法原理，方案总数为 $m^n$. 球有区别，盒子无区别，不允许空盒子这就相当于将 $n$ 个不同的元素分为 $m$ 个集合，可以发现恰好就是第二类斯特灵数的定义，即 $S(n,m)$. 对此，有递归公式为 S(n,k)=\begin{cases} 1&\mbox{if }n=k\mbox{ or }k=1\\ S(n-1,k-1)+k\cdot S(n-1,k)&\mbox{Otherwise} \end{cases}可以理解为，我们考虑第 $n$ 个小球的放置情况，它可以加入以前的一个集合，有 $k$ 个集合可供加入，亦可以成立一个新的集合，根据加法原理统计出答案。 球有区别，盒子有区别，不允许空盒子这种情况下，可以假定盒子没有区别，那么到这一步方案数为 $S(n,m)$, 然后对盒子进行全排列，总方案数为： P_m^mS(n,k)=m!S(n,k) 球有区别，盒子无区别，允许空盒子由于允许空盒子存在，可以假定非空盒子为 $k$ 个，那么恰巧 $k$ 个非空盒子方案数就是 $S(n,k)\quad k\leq m,k\leq n$, 然后根据加法原理，累加起来即可。 总方案数为： \sum_{k=1}^{\min(m,n)}S(n,k) 球无区别，盒子有区别，允许空盒子可以允许重复地选择 $n$ 个盒子，在选中的各个盒子中放入一个球，方案数为 $H_m^n = C_{n+m-1}^n$. 球无区别，盒子有区别，不允许空盒子因为球是没有区别的，但是不能有空盒子，所以可以先将每个盒子放一个球进去，剩下 $n-m$ 个球方案为 H_{m}^{n-m}=C_{n-1}^{n-m}=C_{n-1}^{m-1} 球无区别，盒子无区别，不允许空盒子这种情况相对较复杂，可以使用动态规划的思想。 设 $D_{i,j} = i$ 个球放入 $j$ 个盒子中的方案数。这时我们考虑多一个盒子加入时如何进行转移。 由于球和盒子都没有区别，因此不方便用常规的方法进行计数或者递推。有一种可以执行的操作是往所有的盒子中放入一个小球，当然也可以不这么做，因此： D_{i,j}=D_{i,j-1}+D_{i-j,j} 球无区别，盒子无区别，允许空盒子这与上面的情况就非常相似了，枚举一下有多少个空盒子即可，答案为： \sum_{i=1}^m D_{i,m}]]></content>
      <categories>
        <category>题集</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>递推</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斯特灵数]]></title>
    <url>%2F2018%2F12%2F04%2F%E6%96%AF%E7%89%B9%E7%81%B5%E6%95%B0%2F</url>
    <content type="text"><![CDATA[斯特灵数是由数学家 James Stirling 在18世纪提出的。 在数学中，斯特林数用于解决各种数学分析和组合数学问题，斯特林数是两组不同的数，均是18世纪由詹姆斯·斯特林引入并以其命名，以第一类斯特林数和第二类斯特林数]的称呼区分。此外，有时候也将拉赫数称为第三类斯特林数 第一类斯特灵数第一类斯特灵数记为 $s(n,k)$, 可以定义为递降阶乘展开式的各项系数。 (x)_n=\sum_{k=0}^ns(n,k)x^k其中 $|s(n,k)|$ 也可以记作 $\begin{bmatrix}n\\k\end{bmatrix}$, 代表无符号第一类斯特林数，数值等于将 $n$ 个元素排列成 $k$ 个非空圆圈的方案数。 一个比较形象的理解是，有 $n$ 个人分为 $k$ 组，每组内部按照围圆圈分组方法的数目。例如 $s(4,2)=11$: {A,B},{C,D} {A,C},{B,D} {A,D},{B,C} {A},{B,C,D} {A},{B,D,C} {B},{A,C,D} {B},{A,D,C} {C},{A,B,D} {C},{A,D,B} {D},{A,B,C} {D},{A,C,B} s(n,k)=s(n-1,k-1)+(n-1)s(n-1,k)性质： \begin{bmatrix}n\\k\end{bmatrix}=(n-1)!\\ s(n,n-1)=-C_n^2\\ (x)^{\overline n}=\sum_{k=0}^n\begin{bmatrix}n\\k\end{bmatrix}x^k\\ s(n,k)=(-1)^{n-k}\begin{bmatrix}n\\k\end{bmatrix} 第二类斯特灵数第二类斯特灵数就是 $n$ 个元素分为 $k$ 个等价类的方案数，记为 $S(n,m),\mathbb{S}_n^k$. 一个比较形象的理解是，$n$ 个人分为 $k$ 组的方案数目。例如有甲、乙、丙、丁四人，若所有人分成1组，只能所有人在同一组，因此 $S(4,1)=1$ ；若所有人分成4组，只能每人独立一组，因此 $S(4,4)=1$ ；若分成 2 组，可以是甲乙一组、丙丁一组，或甲丙一组、乙丁一组，或甲丁一组、乙丙一组，或其中三人同一组另一人独立一组，即是： {A,B},{C,D} {A,C},{B,D} {A,D},{B,C} {A},{B,C,D} {B},{A,C,D} {C},{A,B,D} {D},{A,B,C} 因此 $S(4,2)=7$. 给定 $S(n,n)=S(n,1)=1$, 那么 S(n,k)=S(n-1,k-1)+kS(n-1,k)满足： S(n,n-1)=C_n^2=\frac{n(n-1)}{2}\\ S(n,2)=2^{n-1}-1\\ S(n,k)=\frac{1}{k!}\sum_{j=1}^k (-1)^{k-j}C_k^jj^n]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucas 定理]]></title>
    <url>%2F2018%2F12%2F02%2FLucas-%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[Lucas 定理主要用于求组合数 $\mathbb{C}_n^r \mod p$ 的结果， $p$ 相对较小，而且是一个素数。 Lucas(n,r,p)=\begin{cases} 1 & \mbox{if}\quad r=0\\ cm(n\;\mbox{mod}\;p,r\;\mbox{mod}\;p)\times Lucas(n\div p,r\div p,p) & \mbox{otherwise} \end{cases}其中 cm(a,b)=\frac{a!}{(a-b)!}\times(b!)^{(p-2)}=\left(\prod_{i=a-b+1}^a i\right)\times(b!)^{(p-2)}代码如下： 12345678910111213141516171819template&lt;typename T&gt;T Fast_Pow(T n, T m, const T &amp;mod) &#123; T ans = 1; for (; m &gt; 0; m &gt;&gt;= 1, (n *= n) %= mod) if (m &amp; 1)(ans *= n) %= mod; return ans;&#125;template&lt;typename T&gt;T C(const T&amp; n, const T&amp; m, const T&amp; mod) &#123; if (m &gt; n)return 0; T s1 = 1, s2 = 1; for (int i = 0; i &lt; m; i++)(s1 *= n - i) %= mod, (s2 *= (i + 1)) %= mod; return s1 * Fast_Pow(s2, mod - 2, mod) % mod;&#125;template&lt;typename type&gt;type Lucas(const type&amp; n, const type&amp; r, const type&amp; mod) &#123; return (r == 0) ? 1 : (C(n%mod, r%mod, mod)*Lucas(n / mod, r / mod, mod) % mod);&#125; 在特殊情况下，如果需要频繁地调用 Lucas 函数，那么将阶乘和阶乘逆元打表将会加快速度。 1234567891011121314151617181920212223const int MAXN = 1e6;long long Pr[MAXN];template&lt;typename T&gt;T Fast_Pow(T n, T m, const T &amp;mod) &#123; T ans = 1; for (; m &gt; 0; m &gt;&gt;= 1, (n *= n) %= mod) if (m &amp; 1)(ans *= n) %= mod; return ans;&#125;template&lt;typename T&gt;T C(const T&amp; n, const T&amp; m, const T&amp; mod) &#123; if (m &gt; n)return 0; //T s1 = 1, s2 = 1; //for (int i = 0; i &lt; m; i++)(s1 *= n - i) %= mod, (s2 *= (i + 1)) %= mod; //return s1 * Fast_Pow(s2, mod - 2, mod) % mod; return Pr[n] * Fast_Pow(Pr[m], mod - 2, mod) % mod*Fast_Pow(Pr[n - m], mod - 2, mod) % mod;&#125;template&lt;typename type&gt;type Lucas(const type&amp; n, const type&amp; r, const type&amp; mod) &#123; return (r == 0) ? 1 : (C(n%mod, r%mod, mod)*Lucas(n / mod, r / mod, mod) % mod);&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列与组合]]></title>
    <url>%2F2018%2F11%2F29%2F%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[排列组合就是按照一定规则排列一些元素，区别在于组合是相对于一个集合而言，而排列则需要考虑顺序。 通常情况下，记 $\mathbb{ C}_n^m$ 代表 $n$ 个元素中选择 $m$ 个不同元素的方案数。 $\mathbb{P}_n^m$ 代表 $n$ 个元素中选择 $m$ 个元素进行排列的方案数。有些时候，我们需要求得满足特定条件的排列组合数，可能会用到容斥原理为主的计数原理。 组合从 $n$ 个元素的集合 $S$ 中无序地选择 $r$ 个不同元素，叫做 $S$ 的一个 $r$ 组合。所有不同组合的个数叫做组合数，记为 $\mathbb{C}_n^r$. 满足： \mathbb{C}_n^r=\frac{\mathbb{P}_n^r}{r!}\\ \mathbb{C}_n^r=\mathbb{C}_n^{n-r}\\ \mathbb{C}_n^r=\mathbb{C}_{n-1}^r+\mathbb{C}_{n-1}^{r-1}\\ \sum_{i=0}^n \mathbb{C}_n^i=2^n\\ \mathbb{C}_n^r=\frac{n!}{(n-r)!r!}特别地，记 $\mathbb{H}_n^r$ 代表从 $n$ 个元素的集合 $S$ 中无序地选择 $r$ 个元素（可以相同）的方案数。 \mathbb{H}_n^r=\mathbb{C}_{n+r-1}^r 排列在排列问题中，需要考虑元素的顺序，最基本的 $\mathbb{P}_n^r$ 代表 $n$ 个元素中选择 $r$ 个互异元素进行排列的总方案数，在实际应用中根据问题的不同可以延伸出多种不同的排列。 选排列即为 $\mathbb{P}_n^r$. 满足： \mathbb{P}_n^r=\prod_{i=n-r+1}^n i=\frac{n!}{(n-r)!}\\ \mathbb{P}_n^n = n!错位排列有一个集合 $D_n = \{1,2,\cdots,n\}$ , 如果 $(a_1,a_2,\cdots,a_n)$ 为 $D_n$ 的一个全排列，而且 $\forall i\in\{1,2,3,\cdots,n\}$ ,都有 $a_i\not= i$, 那么 $(a_1,a_2,\cdots,a_n)$ 为 $D_n$ 的一个错位排列，总的方案数记为 $\mathbb{D}_n$. \mathbb{D}_n=n!\cdot\left(\sum_{i=0}^n\frac{(-1)^i}{i!}\right)圆排列从 $n$ 个元素中选出 $r$ 个元素，不分首尾地围成一个圆圈的排列叫做圆排列，其排列方案数为 $\frac{\mathbb{P}_n^r}{r}$ . 如果 $r=n$, 则有 $(n-1)!$ 种。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mickey-snow is back]]></title>
    <url>%2F2018%2F11%2F28%2FMickey-snow-is-back%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Untagged</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】NOI2002 银河英雄传说]]></title>
    <url>%2F2018%2F11%2F05%2FNOI2002-%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[题目在这里. 直接带权并查集，记 $fa_i$ 为 $i$ 的父亲， $up_i$ 代表 $i$ 上方有多少个结点，不包括 $i$. $siz_i$ 仅当 $i$ 为根节点是有效，代表这整个子树的节点个数，包括根节点。在合并和求集合(路径压缩)的同时就可以同步维护这两个数组。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define itn intchar ReadChar() &#123; char it; do it = getchar(); while (it != 'M'&amp;&amp; it != 'C'); return it;&#125;constexpr auto MAXN = 30500;int fa[MAXN], up[MAXN], siz[MAXN];std::pair&lt;int, int&gt; FindTop(const int nowAt) &#123; if (fa[nowAt] == nowAt)return std::make_pair(nowAt, up[nowAt]); auto pr = FindTop(fa[nowAt]); return std::make_pair((fa[nowAt] = pr.first), (up[nowAt] += pr.second));&#125;itn main()&#123; std::fill(siz, siz + MAXN, 1); for (int i = 0; i &lt; MAXN; i++)fa[i] = i; int totOrder, fr, to, val; scanf("%d", &amp;totOrder); while (totOrder--) if (ReadChar() == 'M') &#123; scanf("%d%d", &amp;fr, &amp;to); auto a = FindTop(fr), b = FindTop(to); assert(a.first != b.first); fa[a.first] = b.first; up[a.first] += siz[b.first]; siz[b.first] += siz[a.first]; &#125; else &#123; scanf("%d%d", &amp;fr, &amp;to); auto a = FindTop(fr), b = FindTop(to); if (a.first != b.first) &#123; puts("-1"); continue; &#125; if (fr == to) &#123; puts("0"); continue; &#125; else printf("%d\n", (int)abs(up[fr] - up[to]) - 1); &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG1726 上白泽慧音]]></title>
    <url>%2F2018%2F11%2F03%2FLG1726-%E4%B8%8A%E7%99%BD%E6%B3%BD%E6%85%A7%E9%9F%B3%2F</url>
    <content type="text"><![CDATA[题目在这里。 回顾一下求解有向图的强连通分量的模板。 借助 Tarjan 算法这个问题可以在一次深度优先搜索结束之后解决。我们按照某一顺序深度优先搜索各个结点，搜索出来的就是一颗搜索树，如果我们碰到了一个新的结点，就用它的 low 更新，如果碰到的是一个正在栈中的结点，就用它的 dfn 更新，如果是另外一个连通分量中的结点，也就是访问过而且不在栈中，那么它的 low 和 dfn 都无法更新，可以直接忽略掉它。 考虑完所有的儿子之后，如果当前结点的 low 就是自己的 dfn，那么就会产生一个新的强连通分量，从栈中取出相应的元素即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 7000;std::vector&lt;int&gt; G[MAXN], stk[MAXN];std::stack&lt;int&gt; S;bool inStack[MAXN], vis[MAXN]; int low[MAXN], dfn[MAXN], dfs_Clock, cntStk;void Tagan(const int &amp;nowAt) &#123; vis[nowAt] = true; low[nowAt] = dfn[nowAt] = ++dfs_Clock; S.push(nowAt); inStack[nowAt] = true; for (const auto &amp;it : G[nowAt]) if (!dfn[it]) &#123; Tagan(it); low[nowAt] = std::min(low[nowAt], low[it]); &#125; else if (inStack[it])low[nowAt] = std::min(low[nowAt], dfn[it]); if (low[nowAt] == dfn[nowAt]) &#123; stk[cntStk].clear(); while (S.top() != nowAt) &#123; inStack[S.top()] = false; stk[cntStk].push_back(S.top()); S.pop(); &#125; inStack[nowAt] = false; stk[cntStk++].push_back(nowAt); S.pop(); &#125;&#125;int main()&#123; int totCity, totRoad, fr, to, type; scanf("%d%d", &amp;totCity, &amp;totRoad); for (int i = 0; i &lt; totRoad; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;type); assert(type == 1 || type == 2); G[--fr].push_back(--to); if (type == 2)G[to].push_back(fr); &#125; memset(vis, false, sizeof(vis)); memset(inStack, false, sizeof(inStack)); for (int i = 0; i &lt; totCity; i++)if (!vis[i]) Tagan(i); int maxSize = 0; std::vector&lt; std::vector&lt;int&gt; &gt; arr; for (int i = 0; i &lt; cntStk; i++) if (stk[i].size() &gt;= maxSize) &#123; if (stk[i].size() &gt; maxSize) &#123; maxSize = stk[i].size(); std::vector&lt; std::vector&lt;int&gt; &gt; T; &#123;std::swap(arr, T); &#125; &#125; std::sort(stk[i].begin(), stk[i].end()); arr.push_back(stk[i]); &#125; std::sort(arr.begin(), arr.end()); printf("%d\n", arr.begin()-&gt;size()); for (const auto &amp;it : *arr.begin()) printf("%d ", it + 1); putchar('\n'); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG1993 小K的农场]]></title>
    <url>%2F2018%2F11%2F03%2FLG1993-%E5%B0%8FK%E7%9A%84%E5%86%9C%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[题目在这里. 差分约束系统是一种利用图论中判定负环的方法求解多元不等式组有无可行解的一种算法。 假定有关于 $a,b​$ 的二元不等式组，形如 \begin{matrix}\begin{cases} a_{x_1}-b_{y_1}>c_{z_1}\\ \quad\;\;\vdots\\ a_{x_i}-b_{y_i}>c_{z_i}\\ \quad\;\;\vdots\\ a_{x_n}-b_{y_n}>c_{z_n} \end{cases}\end{matrix}$c$ 是常量，我们需要判断这个不等式组是否有解。方法可以通过建模转换为一个图论问题。假定有一个数组 $dis_i$ 代表 $i$ 这个结点最大是多少。每一个 $a_t$ 或者 $b_u$ 都代表像这样的一个结点。那么前面每一个不等式都代表 $a_t$ 到 $b_u$ 距离至少是 $c_v$, 可以当作 $a$ 到 $b$ 有一条长度为 $c$ 的边，我们可以看看这条边能不能更新 $dis_b$. 这个过程等同于求单源最短路。随便假定某一个变量值为 0，然后使用类似于 SPFA 的算法求单源最短路。如果发现了负环，说明有一个结点可以无穷小，这很明显是矛盾的。 在本题中，三个条件可以转换为 a-b>c\\ a-b]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】USACO06NOV Corn Fields]]></title>
    <url>%2F2018%2F11%2F03%2FUSACO06NOV-Corn-Fields%2F</url>
    <content type="text"><![CDATA[显而易见的状态压缩动态规划。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;bool Check(int ___________) &#123; while (___________ &gt; 0) &#123; while ((___________ &amp; 1) == 0) ___________ &gt;&gt;= 1; if ((___________ &amp; 2) == 2)return false; else ___________ &gt;&gt;= 2; &#125;return true;&#125;int main()&#123; constexpr auto _ = (long long)1e8; constexpr auto __ = 12; int ___, ____, x; int _____[__ + 1] = &#123;&#125;; scanf("%d%d", &amp;___, &amp;____); for (int i = 1; i &lt;= ___; i++) for (int j = ____ - 1; j &gt;= 0; j--) &#123; scanf("%d", &amp;x); assert(x == 0 || x == 1); _____[i] |= (x &lt;&lt; j); &#125; long long D[2][1 &lt;&lt; __] = &#123;&#125;; int ________ = 0, _________ = 1; **D = 1; for (int ______ = 1; ______ &lt;= ___; ______++) &#123; std::swap(________, _________); memset(D[________], 0, sizeof(D[________])); for (int ___________ = ((1 &lt;&lt; ____)-1)&amp;_____[______]; ___________ &gt;= 0; ___________ = (___________ - 1)&amp;_____[______]) &#123; for (int ____________ = ((1 &lt;&lt; ____)-1)&amp;_____[______ - 1]; ____________ &gt;= 0; ____________ = (____________ - 1)&amp;_____[______ - 1]) &#123; if ((!(___________&amp;____________)) &amp;&amp; Check(___________) &amp;&amp; Check (____________)) D[________][___________] = (D[________][___________] + D[_________][____________]) % _; if (____________ == 0)break; &#125; if (___________ == 0)break; &#125; &#125; long long _______ = 0; for (int ___________ = ((1 &lt;&lt; ____) - 1)&amp;_____[___]; ___________ &gt;= 0; ___________ = (___________ - 1)&amp;_____[___]) &#123; _______ = (_______ + D[________][___________]) % _; if (___________ == 0)break; &#125; printf("%lld\n", _______); &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树API S.S.]]></title>
    <url>%2F2018%2F11%2F03%2F%E7%BA%BF%E6%AE%B5%E6%A0%91API-S.S%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;bits/stdc++.h&gt;long long mod;class SegTree &#123;private: struct Node &#123; int fr, to; long long val, add, times; Node *lft, *rgt; &#125;*root = nullptr; Node* NewNode() &#123; Node* ret = (Node*)malloc(sizeof(Node)); ret-&gt;lft = ret-&gt;rgt = nullptr; ret-&gt;add = ret-&gt;val = 0; ret-&gt;times = 1; return ret; &#125; void Push_Down(Node *targ) &#123; if (targ-&gt;lft != nullptr) &#123; targ-&gt;lft-&gt;val = (targ-&gt;lft-&gt;val*targ-&gt;times%mod + ((targ-&gt;lft-&gt;to - targ-&gt;lft-&gt;fr + 1)*targ-&gt;add)) % mod; targ-&gt;lft-&gt;add = (targ-&gt;lft-&gt;add*targ-&gt;times%mod + targ-&gt;add) % mod; targ-&gt;lft-&gt;times = targ-&gt;lft-&gt;times*targ-&gt;times%mod; &#125; if (targ-&gt;rgt != nullptr) &#123; targ-&gt;rgt-&gt;val = (targ-&gt;rgt-&gt;val*targ-&gt;times%mod + ((targ-&gt;rgt-&gt;to - targ-&gt;rgt-&gt;fr + 1)*targ-&gt;add)) % mod; targ-&gt;rgt-&gt;add = (targ-&gt;rgt-&gt;add*targ-&gt;times%mod + targ-&gt;add) % mod; targ-&gt;rgt-&gt;times = targ-&gt;rgt-&gt;times*targ-&gt;times%mod; &#125; targ-&gt;times = 1; targ-&gt;add = 0; &#125; void Update(Node *targ) &#123; targ-&gt;val = (targ-&gt;lft-&gt;val + targ-&gt;rgt-&gt;val) % mod; &#125; void Free(Node *targ) &#123; if (targ-&gt;lft != nullptr)Free(targ-&gt;lft); if (targ-&gt;rgt != nullptr)Free(targ-&gt;rgt); free(targ); &#125; void Add(const int &amp;fr, const int &amp;to, const long long &amp;val, Node* nowAt) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;to &lt; fr || to &lt; nowAt-&gt;fr)return; if (nowAt-&gt;times != 1 || nowAt-&gt;add != 0)Push_Down(nowAt); if (fr &lt;= nowAt-&gt;fr&amp;&amp;nowAt-&gt;to &lt;= to) &#123; nowAt-&gt;val = (((nowAt-&gt;to - nowAt-&gt;fr + 1)*val) % mod + nowAt-&gt;val) % mod; nowAt-&gt;add = val; &#125; else &#123; Add(fr, to, val, nowAt-&gt;lft); Add(fr, to, val, nowAt-&gt;rgt); Update(nowAt); &#125; &#125; void Times(const int &amp;fr, const int &amp;to, const long long &amp;val, Node* nowAt) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;to &lt; fr || to &lt; nowAt-&gt;fr)return; if (nowAt-&gt;times != 1 || nowAt-&gt;add != 0)Push_Down(nowAt); if (fr &lt;= nowAt-&gt;fr&amp;&amp;nowAt-&gt;to &lt;= to) &#123; nowAt-&gt;val = (nowAt-&gt;val*val) % mod; nowAt-&gt;times = val; //nowAt-&gt;add = (nowAt-&gt;add*val) % mod; &#125; else &#123; Times(fr, to, val, nowAt-&gt;lft); Times(fr, to, val, nowAt-&gt;rgt); Update(nowAt); &#125; &#125; void Query(const int &amp;fr, const int &amp;to, long long &amp;ans, Node* nowAt) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;to &lt; fr || to &lt; nowAt-&gt;fr)return; if (nowAt-&gt;times != 1 || nowAt-&gt;add != 0)Push_Down(nowAt); if (fr &lt;= nowAt-&gt;fr&amp;&amp;nowAt-&gt;to &lt;= to) ans = (ans + nowAt-&gt;val) % mod; else &#123; Query(fr, to, ans, nowAt-&gt;lft); Query(fr, to, ans, nowAt-&gt;rgt); &#125; &#125;public: SegTree&amp; Clear() &#123; if (root != nullptr)Free(root); root = nullptr; return *this; &#125; SegTree&amp; Build(const int &amp;size, long long *readStream) &#123; Node *a, *b, *t; std::queue&lt;Node*&gt; que, add; for (int i = 0; i &lt; size; i++) &#123; a = NewNode(); a-&gt;fr = a-&gt;to = i; a-&gt;val = *readStream++ %mod; que.push(a); &#125; for (; que.size() &gt;= 2; std::swap(add, que)) &#123; while (que.size() &gt;= 2) &#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = NewNode(); t-&gt;fr = a-&gt;fr; t-&gt;to = b-&gt;to; t-&gt;val = (a-&gt;val + b-&gt;val) % mod; t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if (!que.empty()) &#123; add.push(que.front()); que.pop(); &#125; &#125; root = que.front(); return *this; &#125; SegTree&amp; Add(const int &amp;fr, const int &amp;to, const long long &amp;val) &#123; Add(fr, to, val%mod, root); return *this; &#125; SegTree&amp; Times(const int &amp;fr, const int &amp;to, const long long &amp;val) &#123; Times(fr, to, val%mod, root); return *this; &#125; long long Query(const int &amp;fr, const int &amp;to) &#123; long long ans = 0; Query(fr, to, ans, root); return ans % mod; &#125;&#125;;SegTree str;int main()&#123; int totNums, totOptn, opt, fr, to;long long val; long long num[100050] = &#123;&#125;; scanf("%d%d%lld", &amp;totNums, &amp;totOptn, &amp;mod); for (int i = 0; i &lt; totNums; i++)scanf("%lld", num + i); str.Clear().Build(totNums, num); while (totOptn--) &#123; scanf("%d%d%d", &amp;opt, &amp;fr, &amp;to); --fr; --to; switch (opt) &#123; case 1: scanf("%lld", &amp;val); str.Times(fr, to, val); break; case 2: scanf("%lld", &amp;val); str.Add(fr, to, val); break; case 3: printf("%lld\n", str.Query(fr, to)); break; default: puts("UKE"); assert(false); break; &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】SPFA 判定负环]]></title>
    <url>%2F2018%2F10%2F30%2FSPFA-%E5%88%A4%E5%AE%9A%E8%B4%9F%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[基于 BFS 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;constexpr auto YES = "YE5";constexpr auto NO = "N0";constexpr auto MAXN = 2050;constexpr auto MAXM = 3000;struct Direction &#123; int to, val; &#125;;std::vector&lt;Direction&gt; G[MAXN];bool vis[MAXN], inQueue[MAXN];int dis[MAXN], cnt[MAXN];bool SPFA(const int &amp;begin, const int &amp;totNode) &#123; memset(inQueue, false, sizeof(inQueue)); memset(cnt, 0, sizeof(cnt)); memset(dis, 0x7f, sizeof(dis)); std::queue&lt;int&gt; que; que.push(begin); inQueue[begin] = true; cnt[begin] = 1; vis[begin] = true; dis[begin] = 0; int nowAt; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); inQueue[nowAt] = false; for (const auto &amp;it : G[nowAt]) if (dis[it.to] &gt; dis[nowAt] + it.val) &#123; dis[it.to] = dis[nowAt] + it.val; if ((cnt[it.to] = cnt[nowAt] + 1) &gt; totNode) return true; if (!inQueue[it.to]) &#123; inQueue[it.to] = true; que.push(it.to); &#125; &#125; &#125;return false;&#125;int main()&#123; int totNode, totLink, totCases; int fr, to, val; bool flag; scanf("%d", &amp;totCases); while (totCases--) &#123; scanf("%d%d", &amp;totNode, &amp;totLink); for (int i = 0; i &lt; totNode; i++)G[i].clear(); for (int i = 0; i &lt; totLink; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;val); --fr; --to; G[fr].push_back(&#123; to,val &#125;); if (val &gt;= 0)G[to].push_back(&#123; fr,val &#125;); &#125; memset(vis, false, sizeof(vis)); flag = false; for (int i = 0; i &lt; totNode; i++) if (!vis[i] &amp;&amp; SPFA(i, totNode)) &#123; flag = true; break; &#125; puts(flag ? YES : NO); &#125; //system("pause"); return 0;&#125; 基于 DFS 实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;constexpr auto YES = "YE5";constexpr auto NO = "N0";constexpr auto MAXN = 2050;constexpr auto MAXM = 3000;struct Node &#123; int to, val; &#125;; std::vector&lt;Node&gt; G[MAXN];int dis[MAXN]; bool vis[MAXN], flag, via[MAXN];void SPFA(const int &amp;nowAt) &#123; vis[nowAt] = true; via[nowAt] = true; for (const auto &amp;it : G[nowAt]) if (flag)return; else if (dis[it.to] &gt; dis[nowAt] + it.val) &#123; if (vis[it.to]) &#123; flag = true; return; &#125; dis[it.to] = dis[nowAt] + it.val; SPFA(it.to); &#125; vis[nowAt] = false;&#125;int main()&#123; int totCases, totNode, totEdge; int fr, to, val; scanf("%d", &amp;totCases); while (totCases--) &#123; scanf("%d%d", &amp;totNode, &amp;totEdge); for (int i = 0; i &lt; totNode; i++)G[i].clear(); for (int i = 0; i &lt; totEdge; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;val); --fr; --to; G[fr].push_back(&#123; to,val &#125;); if (val &gt;= 0)G[to].push_back(&#123; fr,val &#125;); &#125; flag = false; memset(vis, false, sizeof(vis)); memset(via, false, sizeof(via)); memset(dis, 0x7f, sizeof(dis)); for (int i = 0; i &lt; totNode; i++) if (!via[i]) &#123; dis[i] = 0; SPFA(i); if (flag)break; &#125; puts(flag ? YES : NO); &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】Violet 蒲公英]]></title>
    <url>%2F2018%2F10%2F29%2FLG4168-Violet-%E8%92%B2%E5%85%AC%E8%8B%B1%2F</url>
    <content type="text"><![CDATA[题目在这里 大致意思是，给定 $n$ 个数， $m$ 次询问，每一次询问你需要求出一个区间 $[l,r]$ 中的众数。算法强制在线。 这道题目每一个询问不是直接给你的，而是给定两个参数，你要根据上一个询问的答案算出这个区间，所以离线算法很不好弄，否则就可以直接莫队水过。 接下来我们来考虑一下正解，由于线段树等算法不能够维护这种不符合区间加法的信息。但是可以发现，如果询问的区间中有一段区间 $[L,R]\quad l\leq L&lt;R\leq r$, 那么区间 $[l,r]$ 的中位数有可能是 区间 $[L,R]$ 的众数 区间 $[l,L)$ 或者区间 $(R,r]$ 中的某一个数，这两边的数让大区间内的一个数数量最终压过大区间的众数。 如果我们能够对于所有询问，找到一个尽可能大的“大区间”，那么就可以极大降低时间复杂度。如果我们弄一个预处理，加上分块的思想，$ans_{i,j}$ 代表合并 $i-j$ 中所有的块之后的众数，那么预处理出 $ans$ 的时空复杂度为 $O(T^2)$. 然后，另外一个问题是如何加速计算任意一个数 $x$ 在区间 $[l,r]$ 中的出现次数。我们可以对于每一个数开一个 STL 的 vector, 其中有序地存储 $x$ 各次出现的位置，接下来我们只需要在这个数组中两次二分，即可得到答案。 总结一下上述的优化方法。首先我们利用分块去掉了大量不必要的枚举，大区间内只用判断一下一个数能否成为答案，剩下的局部暴力也可以承受。而利用数组保存每个数每次出现的位置，可以优化计算 $x$ 的出现次数。 由于本题序列中的数字可能很大，所以需要离散化处理一下，完成这些之后，总的时间复杂度为 O\left(N\log N+T^2\log N+\frac{NM}{T}\log N\right)可见 $T$ 取值不同复杂度会受到很大影响，$T=\sqrt N$ 是一个不错的选择，虽然 $\sqrt[3] N$ 貌似更好，但是相差应该不大。 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = (int)4e4 + 50;constexpr auto MAXM = (int)5e5 + 50;constexpr auto MAXB = 250;//离散化std::map&lt;int, int&gt; val;int rel[MAXN];//分块int Find_BLK(const int &amp;position, const int &amp;MAXSIZE, const int &amp;SIZE) &#123; if (position &gt;= MAXSIZE)return -1; return ceil(position / SIZE);&#125;#define BEGIN(k) ((k)*Size)#define END(k) std::min(((((k)+1)*Size)-1),totNums-1)int ans[MAXB][MAXB];int num[MAXN];std::vector&lt;int&gt; que[MAXN];int Lower_Bound(int begin, int end, const int &amp;val, const int &amp;x) &#123; int mid; while (begin &lt; end) &#123; mid = (begin + end) &gt;&gt; 1; if (que[x][mid] &gt;= val)end = mid; else begin = mid + 1; &#125; return begin;&#125;int Upper_Bound(int begin, int end, const int &amp;val, const int &amp;x) &#123; int mid; while (begin &lt; end) &#123; mid = begin + ((end - begin) &gt;&gt; 1) + 1; if (que[x][mid] &lt;= val)begin = mid; else end = mid - 1; &#125; return begin;&#125;int Count(const int &amp;x, const int &amp;begin, const int &amp;end) &#123; return (Upper_Bound(0, que[x].size() - 1, end, x) - Lower_Bound(0, que[x].size() - 1, begin, x)) + 1;&#125;int main()&#123; int totNums, totQuery, Size, dif_Clock = 0, totBLK; //Read &amp; 离散化 scanf("%d%d", &amp;totNums, &amp;totQuery); for (int i = 0; i &lt; totNums; i++) &#123; scanf("%d", num + i); if (!val.count(num[i])) &#123; val[num[i]] = ++dif_Clock; rel[dif_Clock] = num[i]; &#125; que[val[num[i]]].push_back(i); &#125; //预处理 for (int i = 1; i &lt;= dif_Clock; i++) std::sort(que[i].begin(), que[i].end()); for (int i = 0; i &lt; totNums; i++)num[i] = val[num[i]]; //分块 Size = sqrt(totNums); totBLK = ceil(totNums / Size); int renderNext, target, ans = 0, numNext; int begin, end; for (begin = 0; begin &lt; totBLK; begin++) &#123; int appearTimes[MAXN] = &#123;&#125;; renderNext = BEGIN(begin); for (end = begin; end &lt; totBLK; end++) &#123; for (target = END(end); renderNext &lt;= target; renderNext++) &#123; numNext = num[renderNext]; ++appearTimes[numNext]; if (appearTimes[ans] &lt; appearTimes[numNext] || (appearTimes[ans] == appearTimes[numNext] &amp;&amp; rel[numNext] &lt; rel[ans]) ) ans = numNext; &#125; ::ans[begin][end] = ans; &#125; &#125; int fr, to, mid, x = 0, blkBegin, blkEnd; int answer, answerTime, cnt; while (totQuery--) &#123; scanf("%d%d", &amp;begin, &amp;end); begin = (begin - 1 + x) % totNums; end = (end - 1 + x) % totNums; if (begin &gt; end)std::swap(begin, end); fr = 0; to = totBLK - 1; while (fr &lt; to) &#123; mid = (fr + to) &gt;&gt; 1; if (BEGIN(mid) &lt;= begin &amp;&amp; begin &lt;= END(mid)) &#123; fr = mid; break; &#125; if (begin &lt; BEGIN(mid))to = mid - 1; else fr = mid + 1; &#125;blkBegin = fr; fr = 0; to = totBLK - 1; while (fr &lt; to) &#123; mid = (fr + to) &gt;&gt; 1; if (BEGIN(mid) &lt;= end &amp;&amp; end &lt;= END(mid)) &#123; fr = mid; break; &#125; if (end &lt; BEGIN(mid))to = mid - 1; else fr = mid + 1; &#125;blkEnd = fr; answer = 0; answerTime = INT_MIN; if (blkBegin == blkEnd) &#123; for (int i = begin; i &lt;= end; i++) &#123; cnt = Count(num[i], begin, end); if (cnt &gt; answerTime || (cnt == answerTime &amp;&amp; rel[num[i]] &lt; rel[answer])) &#123; answerTime = cnt; answer = num[i]; &#125; &#125; &#125; else &#123; ++blkBegin; --blkEnd; answerTime = 0; if (blkBegin &lt;= blkEnd) &#123; answer = ::ans[blkBegin][blkEnd]; answerTime = Count(answer, begin, end); &#125; for (int i = begin; i &lt; BEGIN(blkBegin); i++) &#123; cnt = Count(num[i], begin, end); if (cnt &gt; answerTime || (cnt == answerTime &amp;&amp; rel[num[i]] &lt; rel[answer])) &#123; answerTime = cnt; answer = num[i]; &#125; &#125; for (int i = END(blkEnd) + 1; i &lt;= end; i++) &#123; cnt = Count(num[i], begin, end); if (cnt &gt; answerTime || (cnt == answerTime &amp;&amp; rel[num[i]] &lt; rel[answer])) &#123; answerTime = cnt; answer = num[i]; &#125; &#125; &#125; printf("%d\n", (x = rel[answer])); &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>排序</tag>
        <tag>分块</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aho-Corasick自动机 API S.S.]]></title>
    <url>%2F2018%2F10%2F27%2FAho-Corasick%E8%87%AA%E5%8A%A8%E6%9C%BA-API-S.S%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class AhoCorasickAutomaton_S_S_ &#123;private: size_t size; struct Node &#123; Node *ch[26]; Node* fail; int endHere; &#125;*root = nullptr; void Free(Node* targ) &#123; for (int i = 0; i &lt; 26; i++)if (targ-&gt;ch[i] != nullptr)Free(targ-&gt;ch[i]); free(targ); &#125; Node* NewNode() &#123; Node* ret = (Node*)malloc(sizeof(Node)); memset(ret-&gt;ch, NULL, sizeof(ret-&gt;ch)); ret-&gt;fail = nullptr; ret-&gt;endHere = 0; return ret; &#125;public: AhoCorasickAutomaton_S_S_&amp; Cls() &#123; if (root != nullptr) &#123; Free(root); root = nullptr; &#125; root = NewNode(); size = 0; return *this; &#125; size_t Size() &#123; return size; &#125; //Insert String it AhoCorasickAutomaton_S_S_&amp; Insert(char *it) &#123; Node* nowAt = root; for (; *it != '\0'; ++it) &#123; if (nowAt-&gt;ch[*it - 'a'] == nullptr)nowAt-&gt;ch[*it - 'a'] = NewNode(); nowAt = nowAt-&gt;ch[*it - 'a']; &#125;nowAt-&gt;endHere++; ++size; return *this; &#125; AhoCorasickAutomaton_S_S_&amp; Insert(const std::string &amp;it) &#123; Node* nowAt = root; for (const auto &amp;iit : it) &#123; if (nowAt-&gt;ch[iit - 'a'] == nullptr)nowAt-&gt;ch[iit - 'a'] = NewNode(); nowAt = nowAt-&gt;ch[iit - 'a']; &#125;nowAt-&gt;endHere++; ++size; return *this; &#125; AhoCorasickAutomaton_S_S_&amp; Build() &#123; std::queue&lt;Node*&gt; que; for (int i = 0; i &lt; 26; i++) if (root-&gt;ch[i] != nullptr) &#123; que.push(root-&gt;ch[i]); root-&gt;ch[i]-&gt;fail = root; &#125; Node *nowAt, *ext; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); for (int i = 0; i &lt; 26; i++) if (nowAt-&gt;ch[i] != nullptr) &#123; for (ext = nowAt-&gt;fail; ext != nullptr; ext = ext-&gt;fail) if (ext-&gt;ch[i] != nullptr) &#123; nowAt-&gt;ch[i]-&gt;fail = ext-&gt;ch[i]; break; &#125; if (ext == nullptr)nowAt-&gt;ch[i]-&gt;fail = root; que.push(nowAt-&gt;ch[i]); &#125; &#125; return *this; &#125; //Query size_t Count(char *it) &#123; size_t cnt = 0; Node *nowAt, *ext; for (nowAt = root; *it != '\0'; ++it) &#123; while (nowAt-&gt;ch[*it - 'a'] == nullptr &amp;&amp; nowAt != root)nowAt = nowAt-&gt;fail; if (nowAt-&gt;ch[*it - 'a'] != nullptr)nowAt = nowAt-&gt;ch[*it - 'a']; for (ext = nowAt; ext != root; ext = ext-&gt;fail) if (ext-&gt;endHere &gt;= 0) &#123; cnt += ext-&gt;endHere; ext-&gt;endHere = -1; &#125; else break; &#125; return cnt; &#125;&#125;;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>自动机</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG2709 小B的询问]]></title>
    <url>%2F2018%2F10%2F27%2FLG2709-%E5%B0%8FB%E7%9A%84%E8%AF%A2%E9%97%AE%2F</url>
    <content type="text"><![CDATA[题目在这里. 这道题目的询问区间信息正好就是很基础的莫队算法模板。离线处理每条询问，总时间复杂度为 $O(N\sqrt N)​$. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 50050;struct Query &#123; int fr, to, ID, sub; long long ans; bool operator &lt; (const Query &amp;comp)const &#123; return this-&gt;ID &lt; comp.ID; &#125; bool operator () (const Query &amp;a, const Query &amp;comp)const &#123; return a.sub == comp.sub ? a.to &lt; comp.to : a.sub &lt; comp.sub; &#125;&#125;;int num[MAXN], aprTimes[MAXN];std::vector&lt;Query&gt; que;int main()&#123; int totNums, totQuery, maxNum; Query init; scanf("%d%d%d", &amp;totNums, &amp;totQuery, &amp;maxNum); for (int i = 0; i &lt; totNums; i++)scanf("%d", num + i); for (int i = 0; i &lt; totQuery; i++) &#123; scanf("%d%d", &amp;init.fr, &amp;init.to); --init.fr; --init.to; init.sub = sqrt(init.fr); init.ID = i; que.push_back(init); &#125;std::sort(que.begin(), que.end(), Query()); int nowSub = INT_MIN, l, r; long long ans; for (auto &amp;it : que) &#123; if (nowSub != it.sub) &#123; memset(aprTimes, 0, sizeof(aprTimes)); nowSub = it.sub; l = it.fr; r = it.to; ans = 0; for (int i = l; i &lt;= r; ++i) ans += (aprTimes[num[i]]++ &lt;&lt; 1) + 1; &#125; else &#123; while (r &lt; it.to)ans += (aprTimes[num[++r]]++ &lt;&lt; 1) + 1; while (r &gt; it.to)ans += 1 - (aprTimes[num[r--]]-- &lt;&lt; 1); while (l &lt; it.fr)ans += 1 - (aprTimes[num[l++]]-- &lt;&lt; 1); while (l &gt; it.fr)ans += (aprTimes[num[--l]]++ &lt;&lt; 1) + 1; &#125; it.ans = ans; &#125; std::sort(que.begin(), que.end()); for (const auto &amp;it : que) printf("%lld\n", it.ans); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1073D Berland Fair]]></title>
    <url>%2F2018%2F10%2F26%2FCF1073D-Berland-Fair%2F</url>
    <content type="text"><![CDATA[题目在这里. 这道题表面上好像很难的样子。由于他到达一个地方能花钱就必须花，因此我们很难确定 $t$ 单位钱币可以买到多少糖果，这个结果甚至都不是单调的。但事实上，直接暴力模拟就可以了，完全不用担心会超时。每一次模拟完之后 $t$ 的规模都会至少缩减一半，因为会有 $t=t\mod \Delta t$. 这样算下来，时间复杂度为 $O(N\log T)$, 代码如下: 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;int main()&#123; int totNums, min = INT_MAX, val[(int)2e5 + 50] = &#123;&#125;; long long tot$, cnt = 0, dta$ = 0, dtaCnt; scanf("%d%lld", &amp;totNums, &amp;tot$); for (int i = 0; i &lt; totNums; i++) &#123; scanf("%d", val + i); min = std::min(min, val[i]); &#125; while (tot$ &gt;= min) &#123; dta$ = tot$; dtaCnt = 0; for (int i = 0; i &lt; totNums; i++) if (val[i] &lt;= dta$) &#123; dta$ -= val[i]; ++dtaCnt; &#125; dta$ = tot$ - dta$; cnt += (tot$ / dta$)*dtaCnt; tot$ %= dta$; &#125; printf("%lld\n", cnt); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>暴力/枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】JSOI2008 最大数]]></title>
    <url>%2F2018%2F10%2F24%2FJSOI2008-%E6%9C%80%E5%A4%A7%E6%95%B0%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;long long mod;class SegTree &#123;private: struct Node &#123; int fr, to; long long max; Node* lft, *rgt; &#125;*root; Node* NewNode() &#123; Node* ret = (Node*)malloc(sizeof(Node)); ret-&gt;lft = ret-&gt;rgt = nullptr; return ret; &#125; void Update(Node* targ) &#123; targ-&gt;max = std::max(targ-&gt;lft-&gt;max, targ-&gt;rgt-&gt;max); &#125; void Add(const int &amp;pos, const long long &amp;val, Node* nowAt) &#123; if (nowAt == nullptr)return; if (pos &lt; nowAt-&gt;fr || nowAt-&gt;to &lt; pos)return; if (pos == nowAt-&gt;fr&amp;&amp;pos == nowAt-&gt;to)nowAt-&gt;max = val; else &#123; Add(pos, val, nowAt-&gt;lft); Add(pos, val, nowAt-&gt;rgt); Update(nowAt); &#125; &#125; void Query(const int &amp;fr, const int &amp;to, long long &amp;ans, Node* nowAt) &#123; if (nowAt == nullptr)return; if (to &lt; nowAt-&gt;fr || nowAt-&gt;to &lt; fr)return; if (fr &lt;= nowAt-&gt;fr&amp;&amp;nowAt-&gt;to &lt;= to)ans = std::max(ans, nowAt-&gt;max); else &#123; Query(fr, to, ans, nowAt-&gt;lft); Query(fr, to, ans, nowAt-&gt;rgt); &#125; &#125;public: SegTree&amp; Cls() &#123; root = nullptr; return *this; &#125; SegTree&amp; Build(const size_t &amp;size) &#123; Node *a, *b, *t; std::queue&lt;Node*&gt;que, add; for (int i = 0; i &lt; size; i++) &#123; a = NewNode(); a-&gt;max = 0; a-&gt;fr = a-&gt;to = i; que.push(a); &#125; for (; que.size() &gt;= 2; std::swap(que, add)) &#123; while (que.size() &gt;= 2) &#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = NewNode(); t-&gt;lft = a; t-&gt;rgt = b; t-&gt;max = 0; t-&gt;fr = a-&gt;fr; t-&gt;to = b-&gt;to; add.push(t); &#125; if (!que.empty()) &#123; add.push(que.front()); que.pop(); &#125; &#125;root = que.front(); return *this; &#125; void Add(const int pos, const long long val) &#123; Add(pos, val%mod, root); &#125; long long Query(const int &amp;fr, const int &amp;to) &#123; long long ans = INT64_MIN; Query(fr, to, ans, root); return ans; &#125;&#125;;SegTree tr;char ReadChar();int main()&#123; int totOptn, Range = 0; char opt; long long ans = 0, n; scanf("%d%lld", &amp;totOptn, &amp;mod); tr.Cls().Build(totOptn); while (totOptn--) &#123; opt = ReadChar(); if (opt == 'A') &#123; scanf("%lld", &amp;n); tr.Add(Range++, n + ans); &#125; else &#123; scanf("%lld", &amp;n); printf("%lld\n", (ans = tr.Query(Range - n, Range - 1))); &#125; &#125;// system("pause"); return 0;&#125;char ReadChar() &#123; char ret; do ret = getchar(); while (ret != 'A'&amp;&amp;ret != 'Q'); return ret;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SHOI2009 会场预约]]></title>
    <url>%2F2018%2F10%2F24%2FSHOI2009-%E4%BC%9A%E5%9C%BA%E9%A2%84%E7%BA%A6%2F</url>
    <content type="text"><![CDATA[题目在这里. 这道题目的大致意思是，给定 $n$ 个格子上面可以涂色，一开始它们都没有颜色。现在有两种操作，第一种是给一个区间染色，在这之前你要将这个区间内所有出现了的颜色覆盖的所有格子全部抹去颜色，并记录抹掉了多少种不同的颜色。第二种是所有格子中不同颜色的数量。每次染色的颜色互不相同。（有更改） 这是一道线段树好题。在一般情况下，线段树是不能够维护类似于区间数字集合的大小这样不满足区间加法的信息的，但是在本题中，我们可以稍加修改，记录一些额外的数据，达到这种效果。 首先，线段树上每一个结点保存以下信息： 不同颜色数量 颜色编号 不同颜色数量的标记 其中颜色编号这条信息表示区间颜色的编号，这仅当这个区间全部是同一种颜色时才有意义，如果不是这样，它将等于一个负数。 要查询区间内出现的颜色很简单，直接向下推进，如果遇到某一个结点颜色编号有明确信息，直接抹去颜色，返回。设定颜色也是类似的方法。 重点是区间加法。这里区间加法可以用来抹去颜色时为区间减去 1，或者涂色时为区间加上 1. 由于我们维护的信息非常特殊，需要在所有有交集的区间处加一，包含区间打上标记，并且不执行 Update 函数。 123456789void Add(const int &amp;fr, const int &amp;to,const int &amp;val, Node* nowAt = root) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;to &lt; fr || to &lt; nowAt-&gt;fr)return; nowAt-&gt;cnt += val; if (nowAt-&gt;mark != 0)PushDown(nowAt); if (fr &lt;= nowAt-&gt;fr&amp;&amp;nowAt-&gt;to &lt;= to) &#123; nowAt-&gt;mark += val; &#125; else &#123; Add(fr, to, val, nowAt-&gt;lft); Add(fr, to, val, nowAt-&gt;rgt); &#125;&#125; 然后，开一个数组保存每种颜色的起始和终止，删除也只用在另外一个布尔数组上面打上标记即可。 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 200050;int begin[MAXN], end[MAXN], cntErase;bool exist[MAXN];//线段树struct Node &#123; int fr, to, val, mark, cnt; Node *lft, *rgt;&#125;*root = nullptr;Node* NewNode() &#123; Node* ret = (Node*)malloc(sizeof(Node)); ret-&gt;lft = ret-&gt;rgt = nullptr; ret-&gt;val = ret-&gt;mark = ret-&gt;cnt = 0; return ret;&#125;void Update(Node* targ) &#123; if (targ == nullptr || (targ-&gt;lft == nullptr&amp;&amp;targ-&gt;rgt == nullptr))return; if (targ-&gt;lft-&gt;val == targ-&gt;rgt-&gt;val)targ-&gt;val = targ-&gt;lft-&gt;val; else if (targ-&gt;lft-&gt;val != 0 || targ-&gt;rgt-&gt;val != 0)targ-&gt;val = -1; else targ-&gt;val = 0; //targ-&gt;cnt = targ-&gt;lft-&gt;cnt + targ-&gt;rgt-&gt;cnt;&#125;void PushDown(Node* targ) &#123; if (targ-&gt;lft != nullptr) &#123; targ-&gt;lft-&gt;cnt += targ-&gt;mark; if(targ-&gt;val&gt;0)targ-&gt;lft-&gt;val = targ-&gt;val; &#125; if (targ-&gt;rgt != nullptr) &#123; targ-&gt;rgt-&gt;cnt += targ-&gt;mark; if (targ-&gt;val &gt; 0)targ-&gt;rgt-&gt;val = targ-&gt;val; &#125; targ-&gt;mark = 0;&#125;void Build(const size_t size) &#123; Node *a, *b, *t; std::queue&lt;Node*&gt; que, add; for (size_t i = 0; i &lt; size; i++) &#123; a = NewNode(); a-&gt;fr = a-&gt;to = i; que.push(a); &#125; for (; que.size() &gt;= 2; std::swap(que, add)) &#123; while (que.size() &gt;= 2) &#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = NewNode(); t-&gt;fr = a-&gt;fr; t-&gt;to = b-&gt;to; t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if (!que.empty()) &#123; add.push(que.front()); que.pop(); &#125; &#125;root = que.front();&#125;void Add(const int &amp;fr, const int &amp;to,const int &amp;val, Node* nowAt = root) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;to &lt; fr || to &lt; nowAt-&gt;fr)return; nowAt-&gt;cnt += val; if (nowAt-&gt;mark != 0)PushDown(nowAt); if (fr &lt;= nowAt-&gt;fr&amp;&amp;nowAt-&gt;to &lt;= to) &#123; nowAt-&gt;mark += val; &#125; else &#123; Add(fr, to, val, nowAt-&gt;lft); Add(fr, to, val, nowAt-&gt;rgt); &#125;&#125;void Erase(const int &amp;target) &#123; if (!exist[target])return; exist[target] = false; ++cntErase; Add(begin[target], end[target], -1);&#125;void Empty(const int &amp;fr, const int &amp;to, Node* nowAt = root) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;to &lt; fr || to &lt; nowAt-&gt;fr || nowAt-&gt;val == 0)return; PushDown(nowAt); if (fr &lt;= nowAt-&gt;fr&amp;&amp;nowAt-&gt;to &lt;= to &amp;&amp; nowAt-&gt;val &gt; 0) &#123; Erase(nowAt-&gt;val); nowAt-&gt;val = 0; return; &#125; else &#123; Empty(fr, to, nowAt-&gt;lft); Empty(fr, to, nowAt-&gt;rgt); Update(nowAt); &#125;&#125;#define Query() (root-&gt;cnt)void Set(const int &amp;fr, const int &amp;to, const int &amp;ID, Node* nowAt = root) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;to &lt; fr || to &lt; nowAt-&gt;fr)return; if (nowAt-&gt;mark != 0)PushDown(nowAt); if (fr &lt;= nowAt-&gt;fr&amp;&amp;nowAt-&gt;to &lt;= to &amp;&amp; nowAt-&gt;val == 0) &#123; nowAt-&gt;val = ID; return; &#125; else &#123; Set(fr, to, ID, nowAt-&gt;lft); Set(fr, to, ID, nowAt-&gt;rgt); Update(nowAt); &#125;&#125;bool ReadChar();int main()&#123; memset(exist, true, sizeof(exist)); Build(100001); int totOptn, fr, to, cntMeeting = 0; scanf("%d", &amp;totOptn); while (totOptn--) if (ReadChar()) &#123; scanf("%d%d", &amp;fr, &amp;to); begin[++cntMeeting] = fr; end[cntMeeting] = to; cntErase = 0; Empty(fr, to); Add(fr, to, 1); Set(fr, to, cntMeeting); printf("%d\n", cntErase); &#125; else printf("%d\n", Query()); //system("pause"); return 0;&#125;bool ReadChar() &#123; char it; do it = getchar(); while (it != 'A'&amp;&amp;it != 'B'); return it == 'A';&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】USACO08NOV Mixed Up Cows]]></title>
    <url>%2F2018%2F10%2F24%2FUSACO08NOV-Mixed-Up-Cows%2F</url>
    <content type="text"><![CDATA[题目在这里. 定义 $f_{S,i}$ 代表前面的队列集合为 $S$, 其中最后一个加入的元素编号为 $i$, 转移方程如下： f_{S,i}+\!\!=f_{T,j}\qquad i\not=j其中 $T=S-i$, $i\in S,\,j\in T$. 总时间复杂度为 $O(N\times2^N)$, 代码如下: 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define abs(a) (((a)&gt;0)?(a):(-(a)))long long D[1 &lt;&lt; 16][16];int main()&#123; int totCow, K, ID[16], T; std::cin &gt;&gt; totCow &gt;&gt; K; for (int i = 0; i &lt; totCow; i++)std::cin &gt;&gt; ID[i]; for (int i = 0; i &lt; totCow; i++)D[1 &lt;&lt; i][i] = 1; for (int S = 0; S &lt; (1 &lt;&lt; totCow); S++) for (int i = 0; i &lt; totCow; i++) &#123; if(!(S&amp;(1&lt;&lt;i)))continue; T = (S&amp;(~(1 &lt;&lt; i))); for (int j = 0; j &lt; totCow; j++) if ((abs(ID[j] - ID[i]) &gt; K) &amp;&amp; (T&amp;(1 &lt;&lt; j))) D[S][i] += D[T][j]; &#125; long long sum = 0; T = (1 &lt;&lt; totCow) - 1; for (int i = 0; i &lt; totCow; i++) sum += D[T][i]; std::cout &lt;&lt; sum &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】树链剖分]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[模板题. 基本的树链剖分是一种支持树上在线修改和查询的结构，包括简单路径修改和查询，子树修改和查询。具体说，我们为每一个结点编号，放入一颗线段树中进行维护。 在编号之前，我们先求出每一个结点的 重边 ,指这个结点连接它子树大小最大的儿子的那条边，并处理出一些基本的信息。编号时使用深度优先搜索遍历整棵树，由于编号依赖于重边的信息，所以我们需要两次深度优先搜索完成整个过程。在第一次深度优先搜索时，先求出这些信息： 深度 父节点 重边 子树大小 利用这些，在第二次深度优先搜索时计算： 编号 完成这些之后，同一条链上的结点编号是连续的，一棵子树所有节点编号也是一段连续的区间，利用这些性质，套用线段树之后，可以高效地查询、修改。时间复杂度为 $O(N\log^2 N)$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include&lt;bits/stdc++.h&gt;int mod;//线段树class SegTree &#123;private: struct Node &#123; int fr, to, val, mark; Node *lft, *rgt; &#125;*root = nullptr; Node* NewNode() &#123; Node* ret = (Node*)malloc(sizeof(Node)); ret-&gt;lft = ret-&gt;rgt = nullptr; ret-&gt;mark = 0; return ret; &#125; void Free(Node* targ) &#123; if (targ-&gt;lft != nullptr)Free(targ-&gt;lft); if (targ-&gt;rgt != nullptr)Free(targ-&gt;rgt); free(targ); &#125; void Push_Down(Node* targ) &#123; if (targ-&gt;lft != nullptr) &#123; targ-&gt;lft-&gt;mark += targ-&gt;mark; targ-&gt;lft-&gt;mark %= mod; targ-&gt;lft-&gt;val += (targ-&gt;lft-&gt;to - targ-&gt;lft-&gt;fr + 1)*targ-&gt;mark %mod; &#125; if (targ-&gt;rgt != nullptr) &#123; targ-&gt;rgt-&gt;mark += targ-&gt;mark; targ-&gt;rgt-&gt;mark %= mod; targ-&gt;rgt-&gt;val += (targ-&gt;rgt-&gt;to - targ-&gt;rgt-&gt;fr + 1)*targ-&gt;mark %mod; &#125; targ-&gt;mark = 0; &#125; void Add(const int &amp;fr, const int &amp;to, const int &amp;val, Node* nowAt) &#123; if (nowAt == nullptr)return; if (fr &gt; nowAt-&gt;to || to &lt; nowAt-&gt;fr)return; if (nowAt-&gt;mark != 0)Push_Down(nowAt); if (fr &lt;= nowAt-&gt;fr&amp;&amp;nowAt-&gt;to &lt;= to) &#123; nowAt-&gt;mark += val; nowAt-&gt;val += (nowAt-&gt;to - nowAt-&gt;fr + 1)*val %mod; nowAt-&gt;mark %= mod; return; &#125; else &#123; Add(fr, to, val, nowAt-&gt;lft); Add(fr, to, val, nowAt-&gt;rgt); nowAt-&gt;val = (nowAt-&gt;lft-&gt;val + nowAt-&gt;rgt-&gt;val) % mod; &#125; &#125; void Query(const int &amp;fr, const int &amp;to, int &amp;cnt, Node* nowAt) &#123; if (nowAt == nullptr)return; if (fr &gt; nowAt-&gt;to || to &lt; nowAt-&gt;fr)return; if (nowAt-&gt;mark != 0)Push_Down(nowAt); if (fr &lt;= nowAt-&gt;fr&amp;&amp;nowAt-&gt;to &lt;= to) &#123; cnt = (cnt + nowAt-&gt;val)%mod; return; &#125; else &#123; Query(fr, to, cnt, nowAt-&gt;lft); Query(fr, to, cnt, nowAt-&gt;rgt); &#125; &#125;public: SegTree&amp; Cls(const int &amp;mov) &#123; if (root != nullptr)Free(root); return *this; &#125; SegTree&amp; Build(const size_t size, int* readStream) &#123; Node *a, *b, *t; std::queue&lt;Node*&gt; que, add; for (int i = 0; i &lt; size; i++) &#123; a = NewNode(); a-&gt;fr = a-&gt;to = i; a-&gt;val = *readStream++; que.push(a); &#125; for (; que.size() &gt; 1; std::swap(que, add)) &#123; while (que.size() &gt; 1) &#123; a = que.front(); que.pop(); b = que.front(); que.pop(); t = NewNode(); t-&gt;fr = a-&gt;fr; t-&gt;to = b-&gt;to; t-&gt;val = (a-&gt;val + b-&gt;val) % mod; t-&gt;lft = a; t-&gt;rgt = b; add.push(t); &#125; if (!que.empty()) &#123; add.push(que.front()); que.pop(); &#125; &#125;root = que.front(); return *this; &#125; void Add(const int &amp;fr, const int &amp;to, const int &amp;val) &#123; Add((fr &lt;= to ? fr : to), (fr &lt;= to ? to : fr), val, root); &#125; int Query(const int &amp;fr, const int &amp;to) &#123; int ans = 0; Query((fr &lt;= to ? fr : to), (fr &lt;= to ? to : fr), ans, root); return ans % mod; &#125;&#125;;SegTree segTr;constexpr auto MAXN = 100050;std::vector&lt;int&gt; G[MAXN];int valOrig[MAXN], rootID;//树链剖分int depth[MAXN], fa[MAXN], siz[MAXN], inmp[MAXN], top[MAXN], Index[MAXN], dfs_Clock, val[MAXN];bool vis[MAXN];//预处理void Dfs1(const int nowAt = rootID, const int &amp;fa = -1) &#123; //第一遍dfs求出基本信息 vis[nowAt] = true; depth[nowAt] = fa == -1 ? 0 : depth[fa] + 1; ::fa[nowAt] = fa; siz[nowAt] = 1; inmp[nowAt] = 100049; for (const auto &amp;it : G[nowAt]) if (!vis[it]) &#123; Dfs1(it, nowAt); siz[nowAt] += siz[it]; if (siz[it] &gt; siz[inmp[nowAt]]) inmp[nowAt] = it; &#125;&#125;void Dfs2(const int nowAt = rootID) &#123;//第二遍dfs求出top，编号 vis[nowAt] = true; Index[nowAt] = dfs_Clock++; if (fa[nowAt] &lt; 0)top[nowAt] = nowAt; else top[nowAt] = inmp[fa[nowAt]] == nowAt ? top[fa[nowAt]] : nowAt; if (inmp[nowAt] &gt;= 0 &amp;&amp; inmp[nowAt] != 100049)Dfs2(inmp[nowAt]); for (const auto &amp;it : G[nowAt]) if ((!vis[it]) &amp;&amp; it != inmp[nowAt]) Dfs2(it);&#125;//修改void Add(int fr, int to, const int &amp;val) &#123; while (top[fr] != top[to]) &#123; if (depth[top[to]] &gt; depth[top[fr]])std::swap(fr, to); segTr.Add(Index[top[fr]], Index[fr], val); fr = fa[top[fr]]; &#125; segTr.Add(Index[fr], Index[to], val);&#125;void Add(const int &amp;root, const int &amp;val) &#123; segTr.Add(Index[root], Index[root] + siz[root] - 1, val);&#125;//查询int Query(int fr, int to) &#123; int sum = 0; while (top[fr] != top[to]) &#123; if (depth[top[to]] &gt; depth[top[fr]])std::swap(fr, to); sum += segTr.Query(Index[top[fr]], Index[fr]); sum %= mod; fr = fa[top[fr]]; &#125; return (sum + segTr.Query(Index[fr], Index[to])) % mod;&#125;int Query(const int &amp;root) &#123; return segTr.Query(Index[root], Index[root] + siz[root] - 1) % mod;&#125;int main()&#123; memset(inmp, -1, sizeof(inmp)); int totNode, totOpt, opt; int fr, to, val; scanf("%d%d%d%d", &amp;totNode, &amp;totOpt, &amp;rootID, &amp;mod); --rootID; for (int i = 0; i &lt; totNode; i++)scanf("%d", valOrig + i); for (int i = 1; i &lt; totNode; i++) &#123; scanf("%d%d", &amp;fr, &amp;to); --fr; --to; G[fr].push_back(to); G[to].push_back(fr); &#125; memset(vis, false, sizeof(vis)); Dfs1(); memset(vis, false, sizeof(vis)); Dfs2(); for (int i = 0; i &lt; totNode; i++)::val[Index[i]] = valOrig[i]; segTr.Build(totNode, ::val); while (totOpt--) &#123; scanf("%d", &amp;opt); switch (opt) &#123; case 1: scanf("%d%d%d", &amp;fr, &amp;to, &amp;val); Add(fr - 1, to - 1, val); break; case 2: scanf("%d%d", &amp;fr, &amp;to); printf("%d\n", Query(fr - 1, to - 1)); break; case 3: scanf("%d%d", &amp;fr, &amp;val); Add(fr - 1, val); break; case 4: scanf("%d", &amp;fr); printf("%d\n", Query(fr - 1)); break; default: puts("UKE"); assert(false); break; &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡特兰数]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[卡特兰数(Catalan Number)，是一种经常出现在计数问题中的数列。它的几个递推&amp;组合公式如下： f(n)=\sum_{i=0}^{n-1} f(i)\times f(n-1-i) f(n)=\frac{f(n-1)\times(4n-2)}{n+1} f(n)=\frac{\mathbb{C}_{2n}^n}{n+1} f(n)=\mathbb{C}_{2n}^n-\mathbb{C}_{2n}^{n-1}]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】NOI2009 诗人小G]]></title>
    <url>%2F2018%2F10%2F21%2FNOI2009-%E8%AF%97%E4%BA%BA%E5%B0%8FG%2F</url>
    <content type="text"><![CDATA[题目在这里. 我们先考虑如何求出最小的总不谐调程度。按照这个方向考虑，这道题目的大致意思是，给定 $n$ 个数，将它们分割，总不协调程度就是 $\sum |a_i-L|^p$. 记 $f_i$ 代表渲染完成前 $i$ 个句子的最小不协调程度。答案就是 $f_n$. 转移方程如下： f_i=\min\left(f_j+\left(\sum_{k=j+1}^i a_k+i-j-1\quad-L\right)^p\right)去掉 $\min$ 函数，使用前缀和优化 sum 部分，转移方程如下： f_i=f_j+\left|sum_i-sum_j+i-j-1-L\right|^p将这个过程用如下函数代替 123456#define SPACEBETWEEN(i,j) (j-i-1)long double Cult(const int &amp;from, const int &amp;to) &#123; // (from, to] long double x = sum[to] - sum[from] + SPACEBETWEEN(from, to) - statLen; return (FastPow((x &gt; 0 ? x : -x), p));&#125; 转移方程为 f_i=Cult(j,i)+f_j这里 $Cult$ 与 $i,\,j$ 都有关系，所以使用单调队列和斜率优化是很不靠谱的，经过观察可以发现，$Cult$ 满足四边形不等式，因此 $f$ 函数具有单调性。 证明： \forall jv即证 \forall u>v\qquad |v|^p+|v+a_{i+1}+1|^p\ge |u|^p+|u+a_{i+1}+1|^p令 $c\in\mathbb{R}$ , 定义函数 g(x)=|x|^p-|x+c|^p上式可以化为 g(v)\ge g(u)之前已经提到过， $v&lt;u$, 所以如果将 $g$ 的函数图象画在一个笛卡尔平面直角坐标系中，那么 $u$ 和 $v$ 就对应着两个横坐标，$v$ 在 $u$ 的左侧，而这两个横坐标对应着的纵坐标，总是左边大于右边。 这说明一个非常关键的问题：函数 $g$ 单调递减。 即证 g(x)=|x|^p-|x+c|^p单调递减。 接下来，分6种情况： $1^\circ \quad 2\not|p\quad x\in[-c,0]$ : g(x)=-x^p-(x+c)^p对 $g$ 求导得 g^\prime(x)=-px^{p-1}-p(x+c)^{p-1}\\ \because 2|(p-1)\quad p\in\mathbb{R}^+\\ \therefore px^{p-1}+p(x+c)^{p-1}>0\\ \therefore g^\prime(x)0\quad 2|p\quad x+c]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1066E Binary Numbers AND Sum]]></title>
    <url>%2F2018%2F10%2F20%2FCF1066E-Binary-Numbers-AND-Sum%2F</url>
    <content type="text"><![CDATA[题目在这里. 这道题目的大致意思是，给定两个使用二进制表示的正整数 $a,\,b$, 你需要求出 $\sum_{i=0}^{b_{Len}} ((b&gt;&gt;i)\&amp;a)$. 还是将 $a,\,b$ 用二进制表示，现在我们单独地看 $b$ 中的每一个二进制位。如果第 $i$ 位是 1，那么它对答案的贡献就是 \sum_{i=\max(0,\;a_{len}-b_{len}+1)}^{a_{len}} a_i\times 2^{a_{len}-i-1}简单地说，就是将每一个 $b$ 中的 1 一次次向右移动，一次次按位与运算，将答案加起来即可。使用快速幂和前缀和优化之后，时间复杂度为 $O(N\log N)$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;template&lt;typename T&gt;T FastPow(T a, T b, T mod) &#123; T sum = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1)sum = sum * a%mod; a = a * a%mod; &#125; return sum;&#125;constexpr auto MAXN = 200050;constexpr auto mod = 998244353LL;int num[MAXN] = &#123;&#125;;bool GetChar() &#123; char it; do it = getchar(); while (it != '0'&amp;&amp;it != '1'); return it - '0';&#125;int main()&#123; long long ans = 0; int lenA, lenB; scanf("%d%d", &amp;lenA, &amp;lenB); for (int i = 0; i &lt; lenA; i++)num[i] = GetChar(); for (int i = lenA - 1; i &gt;= 0; i--)if (num[i])num[i] = FastPow&lt;long long&gt;(2, lenA - i - 1, mod); for (int i = lenA - 2; i &gt;= 0; i--)num[i] = (num[i] + num[i + 1]) % mod; for (int i = 0; i &lt; lenB; i++) if (GetChar()) &#123; ans += num[std::max(0, lenA - lenB + i)]; ans %= mod; &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SCOI2005 骑士精神]]></title>
    <url>%2F2018%2F10%2F20%2FSCOI2005-%E9%AA%91%E5%A3%AB%E7%B2%BE%E7%A5%9E%2F</url>
    <content type="text"><![CDATA[题目在这里. 能这么快A掉这题的我真是码力暴强！ 这道题没有什么技巧，直接爆搜。其中用到了迭代加深和 IDA* 优化。首先，我们会得到一个初始状态 $S$, 从这个状态开始搜索。搜索时，为搜索树的深度定一个上限，如果在这个上限内得到了答案，直接输出即可，反之加深这个上限，注意上限不超过 15. 达到了某一个状态，从这个状态至多扩展出来 8 个状态，将这 8 个状态按照没有复原的棋子数量进行排序，优先从没有复原数量较少的开始搜索，可以更快地逼近答案。如果在某一时刻，搜索树深度预测会超过限制，直接剪枝。 所以，设计估价函数是这题的关键，它的好坏决定了效率的高低。假定我们位于某一个状态 $S$, 再次状态之下有 $k$ 个位置放着的是不应该放的东西（这里假定空位置放着一个特殊的棋子）。接着模拟一下此后的移动过程。由于每一次移动都是一个骑士从一个位置跳到的另外一个位置，所以每一步 $k$ 最多减少 1. 事实上有可能某一时刻空位也在它应该在的位置，但是下一步它又会被移走，除非这就是最终状态。总之，如果当前步数 $+k-1&gt;$ 上限，那么直接剪枝。 加上上述一个优化和一个剪枝之后，时间复杂度大大降低。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;constexpr short Target[5][5] = &#123; &#123;true,true,true,true,true&#125;, &#123;false,true,true,true,true&#125;, &#123;false,false,-1,true,true&#125;, &#123;false,false,false,false,true&#125;, &#123;false,false,false,false,false&#125;&#125;;constexpr short nextY[] = &#123; 2,2,1,1,-1,-1,-2,-2 &#125;;constexpr short nextX[] = &#123; -1,1,-2,2,-2,2,-1,1 &#125;;class Node &#123;private: inline short GetChar() &#123; char it; do it = getchar(); while (it != '0'&amp;&amp;it != '1'&amp;&amp;it != '*'); return it == '*' ? -1 : (it == '0' ? 0 : 1); &#125;public: bool operator () (const Node &amp;a, const Node &amp;comp)const &#123; return a.cnt &lt; comp.cnt; &#125; short map[5][5]; short cnt, y, x; Node&amp; Clear() &#123; cnt = 0; y = x = -1; return *this; &#125; Node&amp; Init() &#123; for (int i = 0; i &lt; 5; i++) for (int j = 0; j &lt; 5; j++) this-&gt;map[i][j] = GetChar(); return *this; &#125; Node&amp; Cult() &#123; for (int i = 0; i &lt; 5; i++) for (int j = 0; j &lt; 5; j++) &#123; if (this-&gt;map[i][j] == -1) &#123; y = i; x = j; &#125; if (this-&gt;map[i][j] != Target[i][j])cnt++; &#125; return *this; &#125; short Count(const short y, const short x, const short cy, const short cx) &#123; short Delta = 0; if (this-&gt;map[y][x] == Target[y][x])++Delta; if (this-&gt;map[cy][cx] == Target[cy][cx])++Delta; if (this-&gt;map[cy][cx] == Target[y][x])--Delta; if (this-&gt;map[y][x] == Target[cy][cx])--Delta; return Delta; &#125; Node Render(const short &amp;situ) &#123; Node ret = *this; short nxtX = x + nextX[situ], nxtY = y + nextY[situ]; if (nxtX &lt; 0 || nxtY &lt; 0 || nxtX &gt;= 5 || nxtY &gt;= 5) &#123; ret.cnt = INT16_MAX; return ret; &#125; ret.cnt += this-&gt;Count(y, x, nxtY, nxtX); std::swap(ret.map[nxtY][nxtX], ret.map[y][x]); ret.x = nxtX; ret.y = nxtY; return ret; &#125;&#125;;bool Dfs(const short &amp;stepUsed, const short &amp;maxStep, Node &amp;nowAt) &#123; if (nowAt.cnt &lt;= 0)return true; if (stepUsed + (nowAt.cnt - 1) &gt; maxStep)return false; std::vector&lt;Node&gt; arr; for (int i = 0; i &lt; 8; i++)arr.push_back(nowAt.Render(i)); std::sort(arr.begin(), arr.end(), Node()); for (auto &amp;it : arr) if (Dfs(stepUsed + 1, maxStep, it))return true; return false;&#125;int main()&#123; int totCases, stepCounter; Node begin; std::cin &gt;&gt; totCases; while (totCases--) &#123; begin.Clear().Init().Cult(); for (stepCounter = 0; stepCounter &lt;= 15; stepCounter++) if (Dfs(0, stepCounter, begin)) &#123; std::cout &lt;&lt; stepCounter &lt;&lt; std::endl; break; &#125; if (stepCounter &gt; 15)puts("-1"); &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力/枚举</tag>
        <tag>排序</tag>
        <tag>搜索</tag>
        <tag>迭代加深搜索</tag>
        <tag>启发式搜索</tag>
        <tag>IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列通项公式]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[斐波那契数列, 是一种使用递归方法定义的数列 f(n)=\begin{cases} 0\qquad\qquad\qquad\qquad\qquad n=0\\ 1\qquad\qquad\qquad\qquad\qquad n=1\\ f(n-1)+f(n-2)\qquad \text{else} \end{cases} 使用待定系数法，可以求得斐波那契数列的通项公式。 设 $r,s$ 使得 \begin{cases} -rs=1\\ r+s=1 \end{cases}解得 \begin{cases} s=\frac{1+\sqrt 5}{2}\\ r=\frac{1-\sqrt 5}{2} \end{cases}这样， \because f(n)=(r+s)f(n-1)-rsf(n-2)\\ \therefore f(n)-rf(n-1)=s[f(n-1)-rf(n-2)]\\ f(n-1)-rf(n-2)=s[f(n-2)-rf(n-3)]\\ \cdots\\ f(3)-rf(2)=s[f(2)-rf(1)]\\ \therefore f(n)=rf(n-1)=s^{n-2}[f(2)-f(1)]\\ f(n)=s^{n-1}+rf(n-1)\\ \because f(n)=s^{n-1}+rf(n-1)\\ \therefore f(n)=s^{n-1}+rs^{n-2}+r^2f(n-2)\\ \cdots\\ f(n)=s^{n-1}+rs^{n-2}+r^2s^{n-3}+\cdots+r^{n-1}可以发现，这是一个以 $s^{n-1}$ 为首项，$r^{n-1}$ 为末项，$\frac{r}{s}$ 为公比的等比数列。直接使用等比数列求和公式，得到 f(n)=\frac{\sqrt 5}{5}\left[\left(\frac{1+\sqrt 5}{2}\right)^n-\left(\frac{1-\sqrt 5}{2}\right)^n\right]利用这个公式，可以求解斐波那契数列的任意一项。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp2016 蚯蚓]]></title>
    <url>%2F2018%2F10%2F18%2F%E8%9A%AF%E8%9A%93%2F</url>
    <content type="text"><![CDATA[题目在这里. 首先，我们将某一时刻的所有蚯蚓分为三类：未被裁剪的，裁剪后得到的较长的，裁剪后得到的较短的，注意在这里裁剪后得到的数组中的蚯蚓长度有可能是经过了多次裁剪。开三个数组维护。可以发现，如果我们在一开始就将未被裁剪的所有蚯蚓进行排序，之后按照每一次选择一个最长的蚯蚓进行裁剪，得到的放在裁剪后的两个数组中，这样进行下去两个数组中的元素是单调递减的。因此，我们可以使用三个指针，指向三个数组中的下一个元素，每一次在三个元素中选择一个最大的，记录一个变量维护当前时间即可。直接模拟，在必要时输出答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define MAXN 7000500long long orig[MAXN], big[MAXN], small[MAXN];int main()&#123; long long totNums, totTime, addLen, times, divides, gap; scanf("%lld%lld%lld%lld%lld%lld", &amp;totNums, &amp;totTime, &amp;addLen, &amp;times, &amp;divides, &amp;gap); for (int i = 0; i &lt; totNums; i++)scanf("%lld", orig + i); std::sort(orig, orig + totNums, [](const long long &amp;a, const long long &amp;comp) &#123;return a &gt; comp; &#125;); double q = (double)times / divides; auto org = orig, aBegin = big, bBegin = small, aEnd = big, bEnd = small; long long a, b, c, targ, deltaLen = 0; for (int nowTime = 0; nowTime &lt; totTime; nowTime++) &#123; //Compare a = ((org - orig) &gt;= totNums) ? INT64_MIN : *org + deltaLen; b = aBegin &gt;= aEnd ? INT64_MIN : *aBegin + deltaLen; c = bBegin &gt;= bEnd ? INT64_MIN : *bBegin + deltaLen; if (a &gt;= b &amp;&amp; a &gt;= c) &#123; targ = a; org++; &#125; else if (b &gt;= a &amp;&amp; b &gt;= c) &#123; targ = b; aBegin++; &#125; else &#123; targ = c; bBegin++; &#125; a = targ * q; b = targ - a; *aEnd++ = a - deltaLen - addLen; *bEnd++ = b - deltaLen - addLen; if ((nowTime + 1) % gap == 0)printf("%lld ", targ); deltaLen += addLen; &#125;putchar('\n'); const auto size = totNums + totTime; deltaLen = totTime * addLen; for (int rank = 1; rank &lt;= size; rank++) &#123; //Compare a = ((org - orig) &gt;= totNums) ? INT64_MIN : *org + deltaLen; b = aBegin &gt;= aEnd ? INT64_MIN : *aBegin + deltaLen; c = bBegin &gt;= bEnd ? INT64_MIN : *bBegin + deltaLen; if (a &gt;= b &amp;&amp; a &gt;= c) &#123; targ = a; org++; &#125; else if (b &gt;= a &amp;&amp; b &gt;= c) &#123; targ = b; aBegin++; &#125; else &#123; targ = c; bBegin++; &#125; if (rank%gap == 0)printf("%lld ", targ); &#125;putchar('\n'); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CRT 中国剩余定理]]></title>
    <url>%2F2018%2F10%2F17%2FCRT-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[中国剩余定理可以用于求解满足特殊条件的同余方程组。 有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？ ——[孙子算经](卷上) 这一题便描述了这样的一个同余方程组： \begin{matrix}\begin{cases} x\equiv 2\mod 3\\ x\equiv 3\mod 5\\ x\equiv 2\mod 7 \end{cases}\end{matrix}利用中国剩余定理，以及扩展欧几里得算法，这样的方程组可以快速地求解。 我们将这个问题一般化，求解的方程组为： \begin{matrix}\begin{cases} x\equiv a_1\mod q_1\\ x\equiv a_2\mod q_2\\ \qquad\vdots\\ x\equiv a_n\mod q_n \end{cases}\end{matrix}同余方程组能够使用 CRT 求解的前提是，这些模数两两互素，即 $\forall i,j(i\not=j)$ 满足 $\gcd(a_i,a_j)=1$. 以原题为例，我们先求解这样的一个特殊的方程组： \begin{matrix}\begin{cases} x\equiv 1\mod 3\\ x\equiv 0\mod 5\\ x\equiv 0\mod 7 \end{cases}\end{matrix}由于 $x$ 是 7 和 5 的倍数，所以这个方程可以转换为 $35y\equiv 1 \mod 3$. 利用扩展欧几里得算法，解得 $y\equiv 2\mod 3$. 由于在原方程中 $x\equiv 2\mod 3$, 所以将 $y\times 2$, 得到 $x\equiv 70\mod 105$. 这样，将 $x$ 乘上 $k$ 倍的 105，也就是这些模数的最小公倍数 LCM，也会依然满足方程组的第一项。使用类似的方法，求得对于剩下两个方程组的 $y$ 值 \begin{matrix} \begin{cases} x\equiv 0\mod 3\\ x\equiv 1\mod 5\\ x\equiv 0\mod 7 \end{cases}\\\\ \begin{cases} x\equiv 0\mod 3\\ x\equiv 0\mod 5\\ x\equiv 1\mod 7 \end{cases} \end{matrix}然后将结果相加，模上最小公倍数，即为原同余方程组的一个解。 2\times 70+3\times 21+2\times 15\equiv 23\mod 105解得 $x=23$. 一般情况下，我们求解 $n$ 个特殊的方程组：（$1\leq i\leq n$） \begin{matrix}\begin{cases} x\equiv 0\mod m_1\\ \qquad\vdots\\ x\equiv 0\mod m_{i-1}\\ x\equiv 1\mod m_i\\ x\equiv 0\mod m_{i+1}\\ \qquad\vdots\\ x\equiv 0\mod m_n \end{cases}\end{matrix}然后根据题目条件，将每一个 $y$ 乘上 $a_i$, 相加模去最小公倍数即为一组解。 代码如下： 12345678910111213141516171819template&lt;typename type, typename _Answer_Type&gt;type Extended_GCD(const type a, const type b, _Answer_Type &amp;x, _Answer_Type &amp;y)&#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; _Answer_Type ret = Extended_GCD(b, a%b, x, y), tmp = x; x = y; y = tmp - a / b * y; return ret;&#125;template&lt;typename type&gt;type China(type W[], type B[], const int &amp;k) &#123; type x, y, a = 0, m, n = 1; for (int i = 0; i &lt; k; i++)n *= W[i]; for (int i = 0; i &lt; k; i++) &#123; m = n / W[i]; Extended_GCD(W[i], m, x, y); a = (a + y * m*B[i]) % n; &#125; return a &gt; 0 ? a : a + n;&#125; 依赖于扩展欧几里得算法模板。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】POJ1006 Biorhythms]]></title>
    <url>%2F2018%2F10%2F17%2FPOJ1006-Biorhythms%2F</url>
    <content type="text"><![CDATA[题目在这里. 大致意思是说，人的体力，情感和智力三个生理周期天数分别为 23，28 和 33 天，一个周期后的一天会达到一个峰值，现在给定三个日期，分别为体力，情感和智力出现峰值的那一天，然后再给定一个天数，问过多少天后体力，情感和智力同时达到峰值。 假定这一天是 $S$, 体力，情感和智力达到峰值的那一天分别为 $a_1,a_2,a_3$, 那么 S=a_1+T_1k=a_2+T_2k=a_3+T_3k这样，可以得到一个同余方程组： \begin{matrix}\begin{cases} S\equiv a_1 \mod T_1\\ S\equiv a_2\mod T_2\\ S\equiv a_3\mod T_3 \end{cases}\end{matrix}直接利用中国剩余定理，对这个方程进行求解，即可得到答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstdlib&gt;const short MAXN = 3;typedef long long ll;ll a[MAXN] = &#123; 23,28,33 &#125;, b[MAXN];template&lt;typename type, typename _Answer_Type&gt;type Extended_GCD(const type a, const type b, _Answer_Type &amp;x, _Answer_Type &amp;y)&#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; _Answer_Type ret = Extended_GCD(b, a%b, x, y), tmp = x; x = y; y = tmp - a / b * y; return ret;&#125;template&lt;typename type&gt;type China(type W[], type B[], const int &amp;k) &#123; type x, y, a = 0, m, n = 1; for (int i = 0; i &lt; k; i++)n *= W[i]; for (int i = 0; i &lt; k; i++) &#123; m = n / W[i]; Extended_GCD(W[i], m, x, y); a = (a + y * m*B[i]) % n; &#125; return a &gt; 0 ? a : a + n;&#125;int main()&#123; int a, b, c, startDay, ans, cnt = 0; const int lcm = 21252; while (scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;startDay) == 4 &amp;&amp; a != -1 &amp;&amp; b != -1 &amp;&amp; c != -1 &amp;&amp; startDay != -1) &#123; *::b = a; ::b[1] = b; ::b[2] = c; ans = (China(::a, ::b, MAXN) - startDay + lcm) % lcm; printf("Case %d: the next triple peak occurs in %d days.\n", ++cnt, ans); &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】POJ1845 Sumdiv]]></title>
    <url>%2F2018%2F10%2F16%2FPOJ1845-Sumdiv%2F</url>
    <content type="text"><![CDATA[题目在这里. 大致意思是说，求 $A^B$ 的所有约数之和，模 9901. 首先，我们对任何一个整数 $A$ 唯一分解。得到 A=p_1^{k_1}\times p_2^{k_2}\times\cdots\times p_n^{k_n}=\prod_{i=1}^{n} p_i^{k_i}其中所有的 $p_i$ 均为质数，而且假定 $p_i&lt;p_{i+1}$. 这样，$A$ 的所有约数和即为 S=\prod_{i=1}^n \sum_{j=0}^{k_i} p_i^j 在本题中，我们先对 $A$, 唯一分解，得到一个形如前面提到的式子，稍作变形推导出 $A^B$ 分解后得到 A=p_1^{k_1\times B}\times p_2^{k_2\times B}\times\cdots\times p_n^{k_n\times B}=\prod_{i=1}^{n} p_i^{k_i\times B}$A^B$ 约数之和为 S=\prod_{i=1}^n \sum_{j=0}^{k_i\times B} p_i^j因此，我们只需要求出许多个等比数列，然后相加他们即可 在这里算等比数列之和可以折半硬算，先推导一下式子。单个等比数列形如这样： 1+p+p^2+\cdots +p^n=\sum_{i=0}^n p^i在这里，如果 $1|n$, 那么这个数列一共有偶数项，则 \sum_{i=0}^n p^i\;=\;(1+p^{n\div 2+1})+p(1+p^{n\div 2+1})+\cdots +p^{n\div 2-1}(1+p^{n\div 2+1})+p^{n\div2}\;=\;(1+p^{n\div 2+1})\sum_{i=0}^{n\div 2-1}p^i\;+p^{n\div2}这样，我们每一次可以将 $n$ 的规模缩小一半，再乘上 $p^{n\div 2}$. 而如果 $n\not| 1$, 那么方法也是类似的 \sum_{i=0}^n p^i\;=\;(1+p^{n\div 2+1})\sum_{i=0}^{n\div2-1}p^i\;+p^{n\div2}这里的幂运算可以使用快速幂，时间复杂度为 $O(\log N)$. 利用之前推导出的公式，加上快速幂优化，硬解代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;constexpr auto mod = 9901;long int a, b;long long n[10001], p[10001];template&lt;typename T&gt;T Prid(T a, T b) &#123; T sum = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1)sum = sum * a%mod; a = a * a%mod; &#125; return sum;&#125;template&lt;typename T&gt;T Get_Sum(T p, T n) &#123; if (n == 0)return 1; if (n &amp; 1)return (Get_Sum(p, (n &gt;&gt; 1))*(1 + Prid(p, (n &gt;&gt; 1) + 1))) % mod; else return (Get_Sum(p, (n &gt;&gt; 1) - 1)*(1 + Prid(p, (n &gt;&gt; 1) + 1)) + Prid(p, (n &gt;&gt; 1))) % mod;&#125;int main()&#123; std::cin &gt;&gt; a &gt;&gt; b; unsigned int nowAt = 0; for (int i = 2; i*i &lt;= a; i += (i == 2 ? 1 : 2)) if (a%i == 0) &#123; p[nowAt] = i; n[nowAt] = 0; while (a%i == 0) &#123; ++n[nowAt]; a /= i; &#125; ++nowAt; &#125; if (a != 1) &#123; p[nowAt] = a; n[nowAt++] = 1; &#125; long long ans = 1; for (int i = 0; i &lt; nowAt; i++) ans = (ans*Get_Sum(p[i], n[i] * b)) % mod; std::cout &lt;&lt; ans &lt;&lt; std::endl; //system("pause"); return 0;&#125; 第二种方法是利用等比数列求和公式，即 S_n=\begin{cases} \frac{a_1-a_1q^n}{1-q}\qquad q\not= 1\\ na_1\qquad q=1 \end{cases}这里 $S$ 代表总和，$a_1$ 为首项，$a_n$ 为末项，$q$ 为比值，$n$ 为项数。由于这里 $q$ 不可能为 1, 而且 $a_1=1$, 所以代入数据得 S=\prod_{i=1}^n\frac{q^{k_i}-1}{q-1}求出 $q-1$ 的逆元之后，可以直接求解。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;const long long mod = 9901;long long a, b;long long n[10001], p[10001];template&lt;typename T&gt;T FastPow(T aa, T bb, T mod) &#123; T sum = 1; for (; bb &gt; 0; bb &gt;&gt;= 1) &#123; if (bb &amp; 1)sum = sum * aa%mod; aa = aa * aa%mod; &#125; return sum;&#125;template&lt;typename type, typename _Answer_Type&gt;type Extended_GCD(const type a, const type b, _Answer_Type &amp;x, _Answer_Type &amp;y)&#123; if (!b) &#123; x = 1; y = 0; return a; &#125; type ret = Extended_GCD(b, a%b, x, y), tmp = x; x = y; y = tmp - a / b * y; return ret;&#125;template&lt;typename T&gt;T Mim(const T &amp;query, const T &amp;MOD) &#123; T a, b; Extended_GCD(query, MOD, a, b); return (a%MOD + MOD) % MOD;&#125;long long Get_Sum(const int &amp;pos) &#123; long long mimVal = Mim(p[pos] - 1, mod), ki = n[pos] * b + 1; return (((FastPow(p[pos], ki, mod) - 1 + mod) % mod*mimVal) % mod);&#125;int main()&#123; std::cin &gt;&gt; a &gt;&gt; b; unsigned int nowAt = 0; for (int i = 2; i*i &lt;= a; i += (i == 2 ? 1 : 2)) if (a%i == 0) &#123; p[nowAt] = i; n[nowAt] = 0; while (a%i == 0) &#123; ++n[nowAt]; a /= i; &#125; ++nowAt; &#125; if (a &gt; 1) &#123; p[nowAt] = a; n[nowAt++] = 1; &#125; long long ans = 1; for (int i = 0; i &lt; nowAt; i++) ans = (ans*Get_Sum(i)) % mod; std::cout &lt;&lt; ans &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘法逆元]]></title>
    <url>%2F2018%2F10%2F16%2F%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[概念如果 $ax\equiv 1\mod{b}$, 而且 $a,b$ 互质，那么 $x$ 为 $a$ 的逆元，记作 $x=a^{-1}$. 如果是在全体实数集合意义下的计算，那么 $a^{-1}=\frac{1}{a}$. 将正整数集合 $N$ 中所有数分别取模 $p$, 记剩下的集合为 $N_p$, 那么如果在 $N_p$ 的意义下进行除法计算，就需要使用到逆元以避开除法很有可能得到的小数。 求解方法扩展欧几里得法根据定义，我们可以得到 ax+by=1如果 $a$ 有逆元，那么这个方程一定有解，使用扩展欧几里得算法可以很快得出。 1234567891011121314template&lt;typename type, typename _Answer_Type&gt;type Extended_GCD(const type a, const type b, _Answer_Type &amp;x, _Answer_Type &amp;y)&#123; if (!b) &#123; x = 1; y = 0; return a; &#125; auto ret = Extended_GCD(b, a%b, x, y), tmp = x; x = y; y = tmp - a / b * y; return ret;&#125;template&lt;typename T&gt;T Mim(const T &amp;query, const T &amp;MOD) &#123; T a, b; Extended_GCD(query, MOD, a, b); return (a%MOD + MOD) % MOD;&#125; 线性算法上述方法主要用于求单个整数的逆元，而如果需要求得 $1\cdots n$ 的逆元，则需要使用此线性算法。算法的原理非常简单，就是使用一个我们已经知道了的逆元求出我们希望知道的下一个。 首先，我们有 1^{-1}\equiv 1\mod p假定 $p=ki+r,\quad r&lt;i,\,1&lt;i&lt;p$, 那么 $ki+r\equiv 0\mod p$. 而且有 r=p\%i\\ k=\lfloor\frac{p}{i}\rfloor将原式两边同时乘上 $i^{-1}\times r^{-1}$, 得到 kr^{-1}+i^{-1}\equiv0\mod p\\ \therefore i^{-1}\equiv-kr^{-1}\mod p\\ \therefore i^{-1}\equiv -\lfloor\frac{p}{i}\rfloor \times p\%i\mod p因此，$a_i=-(p/i)\times a_{p\%i}$. 12345678910template&lt;typename T&gt;std::vector&lt;T&gt; Get_MiM(const unsigned int size, const T p) &#123; std::vector&lt;T&gt; ans&#123; 0,1 &#125;; for (unsigned int i = 2; i &lt;= size; i++)&#123; ans.push_back(-(p / i)*ans[p%i]); ans[ans.size()-1]=(ans[ans.size()-1]%p+p)%p; &#125; return ans;&#125; 费马小定理假如 $p$ 是质数，且 $\gcd(a,p)=1$ ，那么 $a^{p−1}\equiv 1 \pmod p$. 因为 $a^{p-1}\equiv 1\pmod p$, 所以 $a\times a^{p-2} \equiv 1\pmod p$, 即 $a^{-1}=a^{p-2}$. 只有在 $p$ 为素数的前提下才可使用。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂模板]]></title>
    <url>%2F2018%2F10%2F16%2F%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[123456789template&lt;typename T&gt;T FastPow(T a, T b, T mod) &#123; T sum = 1; for (; b &gt; 0; b &gt;&gt;= 1) &#123; if (b &amp; 1)sum = sum * a%mod; a = a * a%mod; &#125; return sum;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG1290 欧几里德的游戏]]></title>
    <url>%2F2018%2F10%2F15%2FLG1290-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目在这里. 我们记两个数分别为 $a,\,b$, 假定其中较大的一个始终是 $a$. 那么在轮流删减过程中 $a$ 将会不断地减小，直到它不能更小。我们假定每一次 $a,b$ 发生变化(也就是最大数改变) 即为一个阶段的结束。 那么如果当前这个阶段只有一种状态，即 $\lfloor a\div b\rfloor ==1$, 那么当前玩家只能有一种选择，而如果玩家面临一个$\lfloor a\div b\rfloor &gt;1$ 的局面，那么它可以根据情况而定，选择自己取到哪个阶段的第一状态，而面临最后一个阶段的第一状态的玩家必胜。所以，问题转换为了，谁能够取到某一个阶段使得$\lfloor a\div b\rfloor &gt;1$ . 而前面如果有很多连续阶段状态都是 $\lfloor a\div b\rfloor ==1$, 那么只有一种选择，而一旦不是这样了，那么胜负已分。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;int main()&#123; int totCases;bool winner; long long a,b,temp; std::cin&gt;&gt;totCases; while(totCases--) &#123; scanf("%lld%lld",&amp;a,&amp;b);winner = true; if(a&lt;b)std::swap(a,b); while(a/b==1 &amp;&amp; a%b!=0)&#123; temp = a%b; a=b;b=temp; winner = !winner; &#125; puts(winner?"Stan wins":"Ollie wins"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG1516 青蛙的约会]]></title>
    <url>%2F2018%2F10%2F15%2FLG1516-%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[题目在这里. 依题意，记跳跃时间为 $t$ 秒 x+tm\equiv y+tn\mod{l}整理得 x+tm+kl=y+tn\\ x+tm-y-tn+kl=0\\ t(m-n)+kl=y-x而这是一个关于 $t,k$ 的二元同于方程，套用扩展欧几里得算法的模板即可解决。 代码如下: 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;template&lt;typename type, typename _Answer_Type&gt;type Extended_GCD(type a, type b, _Answer_Type &amp;x, _Answer_Type &amp;y)&#123; if(b==0)&#123;x=1; y=0; return a;&#125; const auto ret = Extended_GCD(b,a%b,x,y), tmp = x; x = y; y = tmp - a / b * y; return ret;&#125;int main()&#123; long long len,startA,startB,jumpA,jumpB,t,q,gcd,a,c; std::cin&gt;&gt;startA&gt;&gt;startB&gt;&gt;jumpA&gt;&gt;jumpB&gt;&gt;len; a=jumpB-jumpA;c=startA-startB; if(a&lt;0)&#123;a=-a;c=-c;&#125; gcd = Extended_GCD(a,len,t,q); if(c%gcd!=0)puts("Impossible"); else std::cout&lt;&lt;((c/gcd*t%(len/gcd)+(len/gcd))%(len/gcd))&lt;&lt;std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】扩展欧几里得算法]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[利用 扩展欧几里得算法(Extended Euclidean algorithm) 可以求解整数集合内的二元同余方程。 ax+by=c\\ a,b,c,x,y \in Z 约数约数的定义是如果两个数满足 $a|b$ ，则 $a$ 是 $b$ 的一个约数。如果 $a|b,\,a|c$ ,那么 $a$ 就是 $b$ 和 $c$ 的公约数，而最大的一个 $a$ 称为 $c$ 和 $b$ 的最大公约数，记作 $\gcd(b,\,c)$. 计算方法计算两个数的最大公约数 $\gcd(a,\,b)$ 的原理是： \gcd(a,\,b)=\gcd(a,\,a-b)因此， \gcd(a,b)=\begin{cases} a&\mbox{if }b=0\\ \gcd(b,a\%b)&\mbox{else} \end{cases}实现辗转相除法1234template&lt;typename type&gt;type GCD(const type a,const type b) &#123; return b == 0 ? a : GCD(b, a%b);&#125; 二进制算法1234567891011121314template&lt;typename T&gt;T GCD(const T x, const T y) &#123; if (x == 0 || y == 0)return x == 0 ? x : y; int i, j; for (i = 0; (x &amp; 1) == 0; i++)x &gt;&gt;= 1; for (j = 0; (y &amp; 1) == 0; j++)y &gt;&gt;= 1; if (j &lt; i)i = j; while (true) &#123; if (x &lt; y) &#123; x ^= y; y ^= x; x ^= y; &#125; if ((x -= y) == 0)return y &lt;&lt; i; while ((x &amp; 1) == 0)x &gt;&gt;= 1; &#125;&#125; 使用二进制算法常数会更小。 扩展欧几里得和线性同余方程前面提到的关于 $x,y$ 的方程 ax+by=c有整数解的充分必要条件是 $\gcd(a,b)|c$. 如果我们正确地求出了 $ax+by=\gcd(a,b)$ 的一组解 $x,y$, 那么将 $x,y$ 乘上 $c\div \gcd(a,b)$ 即为方程 $ax+by=c$ 的一组解。而其它解中的 $x$ 可以表示为 $x_0\times t\frac{c}{\gcd(a,\,b)}$. 其中 $t\in Z$. 考虑如何求解方程 ax+by=\gcd(a,b)变换过程如下： \because \gcd(a,b)=\gcd(b,a\%b)\\ \therefore xb+y(a\%b)=xb+y(a-\lfloor\frac{a}{b}\rfloor b)=ay+b(x-\lfloor\frac{a}{b}\rfloor y)记此时的 $y$ 为 $x_0$, $x-\lfloor\frac{a}{b}\rfloor y$ 为 $y_0$. 如果我们一直递归下去，$a,b$ 都在不断地变小，边界为当 $b=0$ 时，如果上述情况满足这一条件，那么 $x_0=1,y_0=0$. 现在我们可以按照如下式子，在递归回去的途中一步步使用 $x_0,y_0$ 计算 $x,y$. x=y_0\\ y=x_0-\lfloor\frac{a}{b}\rfloor y_0一步步推到上来，就得到原方程的解了，代码如下： 12345678template&lt;typename type, typename _Answer_Type&gt;type Extended_GCD(const type a, const type b, _Answer_Type &amp;x, _Answer_Type &amp;y)&#123; if(!b)&#123;x=1; y=0; return a;&#125; auto ret = Extended_GCD(b,a%b,x,y), tmp = x; x = y; y = tmp - a / b * y; return ret;&#125; 通常情况下，题目要求我们求得一组解，使得它的 $x$ 是一个正整数，而且在所有解中最小。这个时候我们任意求出一个 $x$, 然后记 $t=c\div \gcd(a,b)$. x_1=(x\%t+t)\%t$x_1$ 即为所求最小正整数解。模板代码如下： 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;template&lt;typename type, typename _Answer_Type&gt;type Extended_GCD(type a, type b, _Answer_Type &amp;x, _Answer_Type &amp;y)&#123; if(!b)&#123;x=1; y=0; return a;&#125; auto ret = Extended_GCD(b,a%b,x,y), tmp = x; x = y; y = tmp - a / b * y; return ret;&#125;int main()&#123; int a,b,x = 0,y = 0; std::cin&gt;&gt;a&gt;&gt;b; auto res=Extended_GCD(a,b,x,y), t=b/res; x = (x%t+t)%t; y = (res-x*a)/b; printf("GCD(%d, %d) = %d\tx = %d\ty = %d\n",a,b,res,x,y); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】USACO13OPEN Photo]]></title>
    <url>%2F2018%2F10%2F14%2FUSACO13OPEN-Photo%2F</url>
    <content type="text"><![CDATA[题目在这里. 这道题的做法非常巧妙。题目大致是说有 $n$ 头牛排成一排，编号从 1 到 $n$. 现在给定 $m$ 个区间 [$l,r$], 已知 $\forall[l,r]$ 中正好有一头斑点奶牛，求最多有多少头斑点奶牛。 考虑动态规划，记 $f_i$ 代表只考虑前 $i$ 头奶牛，而且假定 $i$ 就是一头斑点奶牛，此时最多有多少斑点奶牛，一般情况下 $f_i \in N$, 特别地，如果此时无论如何都无法满足题意，$f_i=-1$. 那么满足什么条件的状态能够转移到 $f_i$ 呢？我们列举一下限制条件： $\forall[l,r]$ 中有至少一头斑点奶牛。 $\forall[l,r]$ 中有至多一头斑点奶牛。 可以发现，满足以下条件的状态 $f_j$ 不能 转移到 $f_i$. $j$ 与 $i$ 位于同一个区间内，即存在 $l\leq j&lt;i\leq r$, 造成一个区间两头斑点奶牛。 $j$ 与 $i$ 中间夹着一个区间，即存在 $j&lt;l\leq r&lt;i$, 造成一个区间没有斑点奶牛。 综上，我们可以总结出以下两点转移到 $i$ 的条件： 右端点为所有包括它的区间的最大左端点-1 左端点为所有不包括它的区间的最小左端点 接着，我们可以发现这样的区间在扫动的过程中是逐渐往右移动的，就像是一个滑动窗口，窗口中的数值就是以及计算过了的 $f_j$. 而我们希望求出其中最大的一个，如果使用单调队列优化，那么整个算法时间复杂度可以降到 $O(N)$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;template&lt;typename T, const bool Comp&gt;class Queue &#123;private: struct Node &#123; T val; int pos; &#125;; std::deque&lt;Node&gt; que; void Pop_Head(const int &amp;last) &#123; while ((!que.empty()) &amp;&amp; (que.front().pos &lt; last)) que.pop_front(); &#125;public: bool isEmpty() &#123; return que.empty(); &#125; void Clear() &#123; std::deque&lt;Node&gt; t; std::swap(t, que); &#125; void Enqueue(const T &amp;val, const int &amp;pos) &#123; while ((!que.empty()) &amp;&amp; (que.back().val == val ? que.back().pos &lt; pos : ((que.back().val &gt; val) ^ Comp))) que.pop_back(); que.push_back(&#123; val,pos &#125;); &#125; Queue&amp; Empty(const int &amp;pos) &#123; Pop_Head(pos); return *this; &#125; T Front(const int &amp;pos = INT_MIN) &#123; if (pos != INT_MIN) Pop_Head(pos); return que.front().val; &#125; T Dequeue(const int &amp;pos = INT_MIN) &#123; auto it = this-&gt;Front(pos); que.pop_front(); return it; &#125;&#125;;Queue&lt;int, true&gt; que;constexpr auto MAXN = 200050;int L[MAXN], R[MAXN], D[MAXN];int main()&#123; int totNums, totArea, fr, to, nowAt; scanf("%d%d", &amp;totNums, &amp;totArea); for (int i = 1; i &lt;= totNums + 1; i++) &#123; R[i] = i - 1; /*L[i] = -1;*/ &#125; for (int i = 0; i &lt; totArea; i++) &#123; scanf("%d%d", &amp;fr, &amp;to); R[to] = std::min(R[to], fr - 1); //每个区间至少一个 L[to + 1] = std::max(L[to + 1], fr); //每个区间至多一个 &#125; //渲染区间 for (int i = 2; i &lt;= totNums + 1; i++)L[i] = std::max(L[i], L[i - 1]); for (int i = totNums; i &gt; 0; i--)R[i] = std::min(R[i], R[i + 1]); nowAt = 0; memset(D, 0, sizeof(D)); for (int i = 1; i &lt;= totNums + 1; i++) &#123; for (; nowAt &lt;= R[i] &amp;&amp; nowAt &lt;= totNums; nowAt++) if (D[nowAt] != -1) que.Enqueue(D[nowAt], nowAt); D[i] = que.Empty(L[i]).isEmpty() ? -1 : que.Front(L[i]) + 1; &#125; printf("%d\n", std::max(D[totNums + 1] - 1, -1)); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
        <tag>数据结构优化动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】POJ3292 Semi-prime H-numbers]]></title>
    <url>%2F2018%2F10%2F13%2FPOJ3292-Semi-prime-H-numbers%2F</url>
    <content type="text"><![CDATA[题目在这里. 大致意思是，一个集合 $H$ 满足 $\forall a\in N$, $4a+1\in H$. 在 $H$ 集合中的一个数为 H-素数 的条件是在 $H$ 集合中只有这个数和 1 能够将其整除。特别地，1 不是 H-素数。两个不同的H-素数的乘积是一个 H-合成数 。求出不大于 $n$ 的 H-合成数 的个数。 这题说了这么多新定义，实质上就是找到所有的 H-素数，然后两两相乘，最后打个表 $f_i = f_{i-1}+isHComposite_i$. 这样 $f_i$ 就是不大于 $i$ 的 H-合成数 的个数。 筛素数与在整数集合中的做法几乎一样只用特别注意一下筛的时候只考虑 H-数 即可。 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#define MAXN 1000002bool isPrime[MAXN];int prime[MAXN], cnt = 0;unsigned int Sum[MAXN];int main()&#123; memset(isPrime, true, sizeof(isPrime)); for (int i = 5; i &lt;= MAXN; i += 4) if (isPrime[i]) &#123; prime[cnt++] = i; for (int j = i * 5; j &lt;= MAXN; j += (i &lt;&lt; 2)) isPrime[j] = false; &#125; memset(isPrime, false, sizeof(isPrime)); for (int i = 0; i &lt; cnt; i++) for (int j = i; j &lt; cnt &amp;&amp; (long long)prime[i] * (long long)prime[j] &lt;= MAXN; j++) isPrime[prime[i] * prime[j]] = true; for (int i = 1; i &lt;= MAXN; i++) Sum[i] = Sum[i - 1] + isPrime[i]; int n; while (scanf("%d", &amp;n) == 1 &amp;&amp; n) printf("%d %d\n", n, Sum[n]); //system("pause"); return NULL;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>素数判定/筛法</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SCOI2005 最大子矩阵]]></title>
    <url>%2F2018%2F10%2F13%2FSCOI2005-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目在这里. 这题其实只用把状态表示，方程和转移的条件想清楚就很简单了，可以发现这题 $m\leq 2$, 所以肯定是很好状压的，如果使用一个二进制数表示当前行的状态，那么就可以方便地动规。但是，这么做是错的。原因很简单，这么做状态表示一行不超过 4 个，而且 $n$ 也不算太大，这不就是一道水题吗，怎么可能有这么简单？具体说，这样的状态表示是存在漏洞的，因为我们很可能选择两个矩形，而它们恰巧长成这样： 在这种条件下，原先的做法就被叉掉了。我们需要在此基础之上，再添加一点什么，也就是一行选择两个，但是两个分别在不同的矩形中的那种情况。定义 $f_{i,k,S}$ 其中 $i$ 表示当前行，$k$ 表示选择了多少个矩阵，而 $S$ 为状态。 当 $S=0$ 时，空出这一行。 当 $S=1$ 时，选择左边的元素。 当 $S=2$ 时，选择右边的元素。 当 $S=3$ 时，同时选择这一行的两个元素，使得他们在同一矩形中。 当 $S=4$ 时，同时选择这一行的两个元素，使得他们在不同矩形中。 如果当前行左边元素为 $l$ ，右边为 $r$. 转移方程和相应的条件如下 (在这里 $k\ge 1$)： f_{i,k,0} = \max(f_{i-1,k-1,0/1/2/3/4})\\ f_{i,k,1}=\max(f_{i-1,k-1,0/1/2/3/4},f_{i-1,k,1},f_{i-1,k,4})+l\\ f_{i,k,2}=\max(f_{i-1,k-1,0/1/2/3/4},f_{i-1,k,2},f_{i-1,k,4})+r\\ f_{i,k,3}=\max(f_{i-1,k-1,0/1/2/3/4},f_{i-1,k,3})+r+l\\ f_{i,k,4}=\max(f_{i-1,k-2,0/1/2/3/4},f_{i-1,k,4},f_{i-1,k-1,1/2}) \qquad | \qquad k\ge 2时间复杂度为 $O(NK)$. 使用滚动数组之后空间可以优化到 $O(K)$, 接近 $O(1)$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define maxc(a,b,c) std::max(a,std::max(b,c))#define maxb(a,b,c,d) std::max(std::max(a,b),std::max(c,d))#define maxa(a,b,c,d,e) std::max(std::max(a,b),std::max(c,std::max(d,e)))#define ALLLAST(p) std::max(std::max(D[last][k-p][0],D[last][k-p][1]),std::max(D[last][k-p][2],std::max(D[last][k-p][3],D[last][k-p][4])))int main()&#123; int totLine, totList, l, r = 0, totMatrix; scanf("%d%d%d", &amp;totLine, &amp;totList, &amp;totMatrix); int D[2][11][5], now = 0, last = 1; memset(D, -0x7f, sizeof(D)); for (int i = 0; i &lt; 5; i++) D[now][0][i] = 0; for (int i = 0; i &lt; totLine; i++) &#123; scanf("%d", &amp;l); if (totList &gt; 1)scanf("%d", &amp;r); std::swap(now, last); memset(D[now], -0x7f, sizeof(D[now])); **D[now] = 0; for (int k = 1; k &lt;= totMatrix; k++) &#123; *D[now][k] = ALLLAST(0); D[now][k][1] = maxc(D[last][k][1], ALLLAST(1), D[last][k][4]) + l; D[now][k][2] = maxc(D[last][k][2], ALLLAST(1), D[last][k][4]) + r; D[now][k][3] = std::max(D[last][k][3], ALLLAST(1)) + r + l; if (k &gt;= 2) &#123; D[now][k][4] = maxc(D[last][k - 1][1], D[last][k - 1][2], D[last][k][4]); D[now][k][4] = std::max(D[now][k][4], ALLLAST(2)); D[now][k][4] += r + l; &#125; &#125; &#125; printf("%d\n", maxa(D[now][totMatrix][0], D[now][totMatrix][1], D[now][totMatrix][2], D[now][totMatrix][3], D[now][totMatrix][4])); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>动态规划</tag>
        <tag>状态压缩动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SDOI2009 HH的项链]]></title>
    <url>%2F2018%2F10%2F13%2FSDOI2009-HH%E7%9A%84%E9%A1%B9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[题目在这里. 大致意思是给定一个长度为 $n$ 的数组，其中第 $i$ 个数为 $a_i$, 一共有 $m$ 组询问，每次询问一个区间 [$l,r$] 内有多少个不同的数。 这题在线的话会发现很不好做，所以我们试一下离线。由于这题数组中可能的数值不超过 1000001 个，所以可以用莫队。记 $appear_i$ 为数字 $i$ 的出现次数，那么如果我们已经正确地求得了区间 [$l.r$] 内不同数字的个数 $cnt$，那么我们很容易就可以将其扩展到 [$l.r+1$] 和 [$l+1.r$]. 如果我们需要加入一个新数 $t$ , 只需要执行 1cnt += appear[t]++ == 0 ? 1 : 0; 即可搞定。而删除一个数 $t$ 则为 1cnt -= --appear[t] == 0 ? 1 : 0; 时间复杂度都是 $O(1)$, 所以分块之后总时间复杂度为 $O(N\sqrt N)$. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define MAXN 500050int num[MAXN], cnt[MAXN];struct Question &#123; int fr, to, sub, ID; bool operator () (const Question &amp;a, const Question &amp;comp)const &#123; return a.sub == comp.sub ? a.to &lt; comp.to : a.sub &lt; comp.sub; &#125; bool operator &lt; (const Question &amp;comp)const &#123; return this-&gt;ID &lt; comp.ID; &#125;&#125;que[MAXN];int main()&#123; int totNums, totQuery, now = 0,l ,r; scanf("%d", &amp;totNums); for (int i = 0; i &lt; totNums; i++)scanf("%d", num + i); scanf("%d", &amp;totQuery); if (totQuery == 0)return totQuery; for (int i = 0; i &lt; totQuery; i++) &#123; scanf("%d%d", &amp;que[i].fr, &amp;que[i].to); que[i].ID = i; que[i].fr--; que[i].to--; que[i].sub = std::sqrt(que[i].fr); &#125;std::sort(que, que + totQuery, Question()); int nowSub = INT_MIN; for (int i = 0; i &lt; totQuery; i++) &#123; if (nowSub != que[i].sub) &#123; nowSub = que[i].sub; now = 0; memset(cnt, 0, sizeof(cnt)); l = que[i].fr; r = que[i].to; for (int j = que[i].fr; j &lt;= que[i].to; ++j) if (cnt[num[j]]++ == 0)now++; &#125; else &#123; while (r &gt; que[i].to) if (--cnt[num[r--]] == 0)--now; while (r &lt; que[i].to) if (cnt[num[++r]]++ == 0)++now; while (l &gt; que[i].fr) if (cnt[num[--l]]++ == 0)++now; while (l &lt; que[i].fr) if (--cnt[num[l++]] == 0)--now; &#125; que[i].sub = now; &#125; std::sort(que, que + totQuery); for (int i = 0; i &lt; totQuery; i++) printf("%d\n", que[i].sub); //system("pause"); return 0;&#125; 这个方法是正确的，但是却 TLE 了。 所以我们不得不另寻出路。如果使用前缀和，那么假定我们知道位置 $j$ 之前每个数出现的次数，知道 $i-1$ 之前每个数出现的个数，那么将这两个数组相减，再看看有哪些元素依旧不是 0. 就可以得出询问区间 [$i,j$] 的答案。虽然这么做时间复杂度依然难以接受，但是这是一个很好的思路。 我们定义 $apr_i$ 为位置 $i$ 及以前的所有数中有多少个不同的数。记 $appear_i$ 为数字 $i$ 出现的位置，如果目前为止没有出现，那么 $appear_i=-1$. 如果 $appear_{num_{i}} = -1$ ,那么直接 $apr_j+=1\quad j\ge i$. 如果 $appear_{num_{i}} \neq -1$ , 那么 $i$ 在此之前出现过，而无论它是在哪里出现的，询问区间 [$i,j$] 的答案都依然包括 $i$. 所以我们直定它此前没有出现过$apr_j-=1\quad j\ge appear_{num_i}$ 然后 $apr_j+=1\quad j\ge i$. 这样我们就得到了一个正确而且可以快速计算的前缀和，如果在上面套上树状数组，可以平衡修改和查询的操作。 将所有的询问区间离线，然后按照右端点排序，从前往后扫一遍即可。总时间复杂度为 $O(N\log N)$. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;constexpr auto MAXN = 500005;constexpr auto MAXM = 1000005;struct Query &#123; int fr, to, ID, ans; bool operator () (const Query &amp;a, const Query &amp;comp)const &#123; return a.to &lt; comp.to; &#125; bool operator &lt; (const Query &amp;comp)const &#123; return ID &lt; comp.ID; &#125;&#125;ask[MAXN];int arr[MAXN], totNums, appear[MAXM], color[MAXN];template&lt;typename T&gt;T lowBit(T val) &#123; return val &amp; (-val); &#125;void Edit(int pos, const int &amp;delta) &#123; for (; pos &lt;= totNums; pos += lowBit(pos)) arr[pos] += delta;&#125;int query(int pos) &#123; int sum = 0; for (; pos &gt; 0; pos -= lowBit(pos)) sum += arr[pos]; return sum;&#125;int main()&#123; memset(appear, -1, sizeof(appear)); int totQuery, nowAt = 1; scanf("%d", &amp;totNums); for (int i = 0; i &lt; totNums; i++)scanf("%d", color + i + 1); scanf("%d", &amp;totQuery); for (int i = 0; i &lt; totQuery; i++) &#123; ask[i].ID = i; scanf("%d%d", &amp;ask[i].fr, &amp;ask[i].to); &#125; std::sort(ask, ask + totQuery, Query()); for (int i = 0; i &lt; totQuery; i++) &#123; for (; nowAt &lt;= ask[i].to; ++nowAt) &#123; if (appear[color[nowAt]] != -1) Edit(appear[color[nowAt]], -1); Edit((appear[color[nowAt]] = nowAt), 1); &#125; ask[i].ans = query(ask[i].to) - query(ask[i].fr - 1); &#125; std::sort(ask, ask + totQuery); for (int i = 0; i &lt; totQuery; i++) printf("%d\n", ask[i].ans); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>前缀和</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[替罪羊树API]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91API%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165template&lt;typename type&gt;class ScapegoatBST &#123;protected:#define alpha 0.72 type Error;private: struct Node &#123; type val; size_t cnt, size; Node *lft, *rgt; bool Rebuild() &#123; if (lft == nullptr&amp;&amp;rgt == nullptr)return false; if (lft != nullptr&amp;&amp;rgt == nullptr)return this-&gt;lft-&gt;size &gt; (double)this-&gt;size*alpha; if (lft == nullptr&amp;&amp;rgt != nullptr)return this-&gt;rgt-&gt;size &gt; this-&gt;size*alpha; else return this-&gt;lft-&gt;size &gt; (double)this-&gt;size*alpha || this-&gt;rgt-&gt;size &gt; this-&gt;size*alpha; &#125; Node&amp; Refresh() &#123; this-&gt;size = (lft == nullptr ? 0 : lft-&gt;size) + (rgt == nullptr ? 0 : rgt-&gt;size) + this-&gt;cnt; return *this; &#125; &#125;*root = nullptr; std::vector&lt;Node*&gt; que; Node* newNode() &#123; Node* creat = (Node*)malloc(sizeof(Node)); creat-&gt;cnt = creat-&gt;size = 1; creat-&gt;lft = creat-&gt;rgt = nullptr; return creat; &#125; void Free(Node* targ) &#123; if (targ-&gt;lft != nullptr)Free(targ-&gt;lft); if (targ-&gt;rgt != nullptr)Free(targ-&gt;rgt); free(targ); &#125; //重构函数 void Dfs(Node* nowAt) &#123; if (nowAt-&gt;lft != nullptr)Dfs(nowAt-&gt;lft); if (nowAt-&gt;cnt != 0)que.push_back(nowAt); if (nowAt-&gt;rgt != nullptr)Dfs(nowAt-&gt;rgt); if (nowAt-&gt;cnt == 0)free(nowAt); &#125; Node* Build(const size_t fr, const size_t to) &#123; if (fr &gt;= to)return nullptr; int mid = (fr + to) &gt;&gt; 1; Node* rt = que[mid]; rt-&gt;lft = Build(fr, mid); rt-&gt;rgt = Build(mid + 1, to); rt-&gt;Refresh(); return rt; &#125; void Rebuild(Node* &amp;rt) &#123; Dfs(rt); rt = Build(0, que.size()); &#125; //控制函数 void Insert(Node* &amp;nowAt, const type &amp;val) &#123; if (nowAt == nullptr) &#123; nowAt = newNode(); nowAt-&gt;val = val; return; &#125; else if (nowAt-&gt;val == val) &#123; ++nowAt-&gt;size; ++nowAt-&gt;cnt; return; &#125; else &#123; ++nowAt-&gt;size; if (val &gt; nowAt-&gt;val)Insert(nowAt-&gt;rgt, val); else Insert(nowAt-&gt;lft, val); if (nowAt-&gt;Rebuild()) &#123; &#123;std::vector&lt;Node*&gt; T; std::swap(T, que); &#125; Rebuild(nowAt); &#125; &#125; &#125;//插入 size_t Delete(Node* &amp;nowAt, const type &amp;val, const size_t &amp;delNums) &#123; if (nowAt == nullptr)return 0; if (nowAt-&gt;val == val) &#123; if (nowAt-&gt;cnt &gt;= delNums) &#123; nowAt-&gt;size -= delNums; nowAt-&gt;cnt -= delNums; return delNums; &#125; else &#123; int cnt = std::min(nowAt-&gt;cnt, delNums); nowAt-&gt;cnt -= cnt; nowAt-&gt;size -= cnt; return cnt; &#125; &#125; int minusNums = (nowAt-&gt;val &lt; val)? Delete(nowAt-&gt;rgt, val, delNums): Delete(nowAt-&gt;lft, val, delNums); nowAt-&gt;size -= minusNums; return minusNums; &#125;//删除 //查询函数 type Kth_Element(Node* nowAt, size_t rank) &#123; while (nowAt != nullptr) &#123; if ((nowAt-&gt;lft == nullptr ? 0 : nowAt-&gt;lft-&gt;size) &lt; rank&amp;&amp;rank &lt;= (nowAt-&gt;lft == nullptr ? 0 : nowAt-&gt;lft-&gt;size) + nowAt-&gt;cnt) return nowAt-&gt;cnt ? nowAt-&gt;val : Error; if ((nowAt-&gt;lft == nullptr ? 0 : nowAt-&gt;lft-&gt;size) &gt;= rank)nowAt = nowAt-&gt;lft; else &#123; rank -= (nowAt-&gt;lft == nullptr ? 0 : nowAt-&gt;lft-&gt;size) + nowAt-&gt;cnt; nowAt = nowAt-&gt;rgt; &#125; &#125;return Error; &#125; //析构函数 void Order(std::vector&lt;type&gt; &amp;a, const Node* nowAt) &#123; if (nowAt == nullptr)return; Order(a, nowAt-&gt;lft); if (nowAt-&gt;cnt &gt; 0)a.push_back(nowAt-&gt;val); Order(a, nowAt-&gt;rgt); &#125;public: Node* Root() &#123; return root; &#125; bool IsEmpty() &#123; return root == nullptr; &#125; void Destroy() &#123; if (root != nullptr)Free(root); root = nullptr; &#125; size_t Size() &#123; return IsEmpty() ? 0 : root-&gt;size; &#125; void EnMultiSet(const type &amp;val) &#123; Insert(root, val); &#125; size_t DeMultiSet(const type &amp;val) &#123; return Delete(root, val, 1); &#125; size_t Destroy(const type &amp;val) &#123; return Delete(root, val, UINT32_MAX); &#125; type Kth_Element(const size_t &amp;rank) &#123; return Kth_Element(root, rank); &#125; size_t GetPosistion(const type &amp;val) &#123; size_t ans = 1; Node* nowAt = root; while (nowAt != nullptr) &#123; if (nowAt-&gt;val &gt;= val)nowAt = nowAt-&gt;lft; else &#123; ans += (nowAt-&gt;lft == nullptr ? 0 : nowAt-&gt;lft-&gt;size) + nowAt-&gt;cnt; nowAt = nowAt-&gt;rgt; &#125; &#125;return ans; &#125; size_t Count(const type &amp;val) &#123; Node* nowAt = root; while (nowAt != nullptr) &#123; if (nowAt-&gt;val == val)return nowAt-&gt;cnt; nowAt = nowAt-&gt;val &gt; val ? nowAt-&gt;lft : nowAt-&gt;rgt; &#125;return 0; &#125; type Lower(const type &amp;val) &#123; return Kth_Element(GetPosistion(val) - 1); &#125; type Upper(const type &amp;val) &#123; return Kth_Element(GetPosistion(val + 1)); &#125; std::vector&lt;type&gt; ToVector() &#123; std::vector&lt;type&gt; a; Order(a, root); return a; &#125; void Rebuild() &#123; Rebuild(root); &#125;&#125;;ScapegoatBST&lt;int&gt; bst;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG1415 拆分数列]]></title>
    <url>%2F2018%2F10%2F10%2FLG1415-%E6%8B%86%E5%88%86%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目在这里. 可以看到，这题要求我们分割之后的各个数字满足以下几个条件。 先要满足最后一个数最小 如果有多组解，则使得第一个数尽量大；如果仍有多组解，则使得第二个数尽量大，依次类推…… 因此，我们一个个地考虑，需要 DP 两次，每一次分别求出一个条件满足时的相关信息，再综合它们，得出答案。 第一次 DP 求出最后一个数最小可能是多少。 设 $f(x) = \text{只考虑前 }x\text{ 个数，此时最后一个数最大可能的值}$. 特别地，$f(0)=0$. 得出的方程为 f(i)=\text{ToInt}(j,i) \qquad j]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>高精</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG3912 素数个数]]></title>
    <url>%2F2018%2F10%2F10%2FLG3912-%E7%B4%A0%E6%95%B0%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这道题看上去就很简单，但是要用到一些技巧。首先，我们考虑线性筛法，由于空间限制很不好写，接着我们来优化埃氏筛法。首先每一个合数根据唯一分解定理都可以分成若干质数的乘积，所以我们只用质数来筛，而且，枚举到 $\sqrt{n}$ 的时候就可以停止，因为往上不会再产生新的合数。 时间复杂度为 $O(\sqrt N)$ ,代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;bool vis[100000001];int main()&#123; //freopen("primenum.in", "r", stdin); //freopen("primenum.out", "w", stdout); int n, cnt, i, j; scanf("%d", &amp;n); cnt = n - 1; for (i = 2; i*i &lt;= n; ++i) &#123; if (!vis[i]) for (j = (i &lt;&lt; 1); j &lt;= n; j += i) if (!vis[j]) &#123; vis[j] = true; --cnt; &#125; &#125; printf("%d\n", cnt); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>素数判定/筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】HAOI2007 理想的正方形]]></title>
    <url>%2F2018%2F10%2F09%2FHAOI2007-%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题目大致意思是给定一个二维数字矩阵，求出一个大小为 $n\times n$ 的正方形使得其中所有数字的最大值减去最小值尽可能小。求这个最小的最大最小值之差。 首先，我们将一个正方形放入这个矩阵中，随后将其右移。与单调队列不同的是，它每移动一格，进入它的是 $n$ 个数，从队头排出的过时数据则是前面 $n$ 列 $n$ 个数中在队列中的那一部分。可以发现，如果一个数 $a$ 与另外一个数字 $b$ 处在同一列而且 $a&lt;b$ ,那么 $a$ 永远无法成为最大值。将这个问题转换一下，就变成了每一次往里面加入 $n$ 个数中最小的那一个，这样一来，就成为了一个一维的单调队列。 然而，这一步预处理也是可以使用单调队列优化，假定 $val_{i,j}$ 代表 $(i,j)$ 这个点以及它往下 $n-1$ 个点中最大的一个，那么就可以用一个单调队列沿着这一列往下扫，每一步都求一次最大值。整个预处理就是 $O(N)$. 有了这个预处理，再横向用优先队列扫一遍，最小值采用同样的方法。可以发现，每个数入队出队不超过 4 次，所以时间复杂度为 $O(N^2)$. 使用了单调队列的 API，代码看上去就更加直观： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define MAXN 1001#define MAXM 101template&lt;typename T,const bool Comp&gt;class Queue &#123; //单调队列protected: int maxSize;private: struct Node &#123; T val; int pos; &#125;; std::deque&lt;Node&gt; que; void Pop_Head(const int &amp;nowAt) &#123; while ((!que.empty()) &amp;&amp; (que.front().pos &lt;= nowAt - maxSize)) que.pop_front(); &#125;public: bool isEmpty() &#123; return que.empty(); &#125; void Clear() &#123; std::deque&lt;Node&gt; t; std::swap(t, que); &#125; void Resize(const size_t &amp;size) &#123; maxSize = size; &#125; void Enqueue(const T &amp;val, const int &amp;pos) &#123; Pop_Head(pos); while ((!que.empty()) &amp;&amp; (que.back().val == val ? que.back().pos &gt;= pos : ((que.back().val &gt; val)^Comp))) que.pop_back(); que.push_back(&#123; val,pos &#125;); &#125; T Front(const int &amp;pos = INT_MIN) &#123; if (pos != INT_MIN) Pop_Head(pos); return que.front().val; &#125; T Dequeue(const int &amp;pos = INT_MIN) &#123; auto it = this-&gt;Front(pos); que.pop_front(); return it; &#125;&#125;;Queue&lt;int, true&gt; a; //bigQueue&lt;int, false&gt;b; //smallint val[MAXN][MAXN], min[MAXN][MAXN], max[MAXN][MAXN];int main()&#123; memset(min, 0x7f, sizeof(min)); memset(max, -0x7f, sizeof(max)); int totLine, totList, size; scanf("%d%d%d", &amp;totLine, &amp;totList, &amp;size); a.Resize(size); b.Resize(size); for (int i = 0; i &lt; totLine; i++) for (int j = 0; j &lt; totList; j++) scanf("%d", val[i] + j); for (int nowList = 0; nowList &lt; totList; nowList++) &#123; a.Clear(); b.Clear(); for (int i = 0; i &lt; size - 1; i++) &#123; b.Enqueue(val[i][nowList], i); a.Enqueue(val[i][nowList], i); &#125; for (int i = size - 1; i &lt; totLine; i++) &#123; b.Enqueue(val[i][nowList], i); a.Enqueue(val[i][nowList], i); min[i + 1 - size][nowList] = b.Front(i); max[i + 1 - size][nowList] = a.Front(i); &#125; &#125; int _min = INT_MAX; for (int nowLine = 0; nowLine &lt;= totLine - size; nowLine++) &#123; a.Clear(); b.Clear(); for (int j = 0; j &lt; size - 1; j++) &#123; a.Enqueue(max[nowLine][j], j); b.Enqueue(min[nowLine][j], j); &#125; for (int j = size - 1; j &lt; totList; j++) &#123; a.Enqueue(max[nowLine][j], j); b.Enqueue(min[nowLine][j], j); _min = std::min(_min, a.Front(j) - b.Front(j)); &#125; &#125; std::cout &lt;&lt; _min &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调队列 API]]></title>
    <url>%2F2018%2F10%2F08%2F%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-API%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738template&lt;typename T,const bool Comp&gt;class Queue &#123;protected: int maxSize;private: struct Node &#123; T val; int pos; &#125;; std::deque&lt;Node&gt; que; void Pop_Head(const int &amp;nowAt) &#123; while ((!que.empty()) &amp;&amp; (que.front().pos &lt;= nowAt - maxSize)) que.pop_front(); &#125;public: bool isEmpty() &#123; return que.empty(); &#125; void Clear() &#123; std::deque&lt;Node&gt; t; std::swap(t, que); &#125; void Resize(const size_t &amp;size) &#123; maxSize = size; &#125; void Enqueue(const T &amp;val, const int &amp;pos) &#123; Pop_Head(pos); while ((!que.empty()) &amp;&amp; (que.back().val == val ? que.back().pos &gt;= pos : ((que.back().val &gt; val)^Comp))) que.pop_back(); que.push_back(&#123; val,pos &#125;); &#125; T Front(const int &amp;pos = INT_MIN) &#123; if (pos != INT_MIN) Pop_Head(pos); return que.front().val; &#125; T Dequeue(const int &amp;pos = INT_MIN) &#123; auto it = this-&gt;Front(pos); que.pop_front(); return it; &#125;&#125;;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 CF1060C Maximum Subrectangle]]></title>
    <url>%2F2018%2F10%2F05%2FCF1060C-Maximum-Subrectangle%2F</url>
    <content type="text"><![CDATA[题目在这里。这是一道很有意思的题。 题目大致意思是给定两个数组 $a,\,b$, 下标从 1 到 $n$，我们需要求出在一个二维矩阵 $c_{i,j} = a_i\times b_j$ 中面积最大的矩形，使得矩形中所有数字之和不超过 $x$. 输出的内容是这个矩阵的面积大小。 首先，我们可以看到，这个矩阵并不是事先已知的，而是通过 $a,\,b$ 两个数组计算得到，所以我们可以根据这个特点，推一下式子。假定我们选择一个矩形，它的两个端点分别为 $(x_1,\,y_1),\;(x_2,\,y_2)$. 那么所有元素之和可以表示为 \sum_{i=x_1}^{x_2}\!\sum_{j=y_1}^{y_2} c_{i,j}= \sum_{i=x_1}^{x_2}\!\sum_{j=y_1}^{y_2}a_i\!\times\!b_j = \sum_{i=x_1}^{x_2}a_i\,\times\,\sum_{j=y_1}^{y_2}b_j这就代表，任意选择一个矩形，其中所有数字之和都对应着 $a$ 中一段连续的数字之和乘上 $b$ 中一段连续的数字之和，得到的面积就是这两段连续数字的长度的乘积。 换句话说，我们需要在 $a$ 中找到一段长度为 $len_a$ 的序列，并在 $b$ 中找到一段长度为 $len_b$ 的序列，使得这两个序列中的数字之和的乘积不超过 $x$ 的情况下 $len_a\times len_b$ 尽可能大。 由于我们并不关心这样的一段到底长成什么样，只想让它尽可能小，所以可以先预处理出所有可能的值，假定 $T_i$ 为 $a$ 中长度为 $i$ 的一段的最小值， $S_i$ 为 $b$ 中长度为 $i$ 的一段的最小值，那么只用将两个数组扫一遍，就可以得出结果。 无论是预处理，还是最后计算答案，时间复杂度都是 $O(N^2)$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define MAXN 2001int A[MAXN], B[MAXN];std::vector&lt;int&gt; lenA, lenB;int main()&#123; int lenA, lenB, x, cnt, pos, _min; //Read scanf("%d%d", &amp;lenA, &amp;lenB); for (int i = 0; i &lt; lenA; i++)scanf("%d", A + i); for (int i = 0; i &lt; lenB; i++)scanf("%d", B + i); scanf("%d", &amp;x); //预处理 for (int len = 1; len &lt;= lenA; len++) &#123; cnt = 0; for (pos = 0; pos &lt; len; pos++)cnt += A[pos]; _min = cnt; for (; pos &lt; lenA; pos++) &#123; cnt -= A[pos - len]; cnt += A[pos]; _min = std::min(_min, cnt); &#125; ::lenA.push_back(_min); //printf("ArrayA len=%d, minVal=%d\n", len, ::lenA.back()); &#125;/*putchar('\n');*/ for (int len = 1; len &lt;= lenB; len++) &#123; cnt = 0; for (pos = 0; pos &lt; len; pos++)cnt += B[pos]; _min = cnt; for (; pos &lt; lenB; pos++) &#123; cnt -= B[pos - len]; cnt += B[pos]; _min = std::min(_min, cnt); &#125; ::lenB.push_back(_min); //printf("ArrayB len=%d, minVal=%d\n", len, ::lenB.back()); &#125; int _max = 0; for (int a = 0; a &lt; ::lenA.size(); a++) for (int b = 0; b &lt; ::lenB.size(); b++) if ((long long)::lenA[a] * (long long)::lenB[b] &lt;= (long long)x) _max = std::max(_max, a*b + a + b + 1); std::cout &lt;&lt; _max &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力/枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解除网络连接]]></title>
    <url>%2F2018%2F10%2F05%2F%E8%A7%A3%E9%99%A4%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[这里我们将讨论如何解除一个设备的互联网无线连接。 工具为了达到这个目的，我们需要事先准备好一些东西。 电脑配置不用太高，笔记本式和桌面式的都可以。但是为了流畅的运行起码要有 2G 内存，15G 可用的磁盘容量，而且有至少一个可以使用的 USB 接口。 操作系统操作系统上，推荐使用 Kali Linux. 如果你的主操作系统不是它，只用开启任何一款主流的虚拟机软件，下载并安装上即可。记得在配置时，打开虚拟机的 USB 接口连接，至少给虚拟机分配 1G 内存，10G 磁盘容量。 在下面的讨论中，我将使用 Windows10 作为主系统，在虚拟机中运行 Kali. 网卡为了发送和接收数据包，必须要有一个网卡，大多数笔记本电脑都配备了内置的网卡，但是它们大多数都不太好用。市面上有非常多的品牌和型号，判断它们是否好用的重要途径是看里面的芯片，推荐使用 RTL8812AU 这款芯片的网卡，它不仅能够完美地执行我们接下来的所有操作，而且兼容 2.4千兆赫 和 5 千兆赫两种不同频率的信号。 想要查看自己的网卡是否能够正常工作，只需要将它插入 USB 接口，在 Kali 中输入如下指令 1iwconfig 可以清楚地看到，中间的那个就是我的网卡，不仅如此，我们还知道了它的名字：wlan0. 对于你而言可能是什么别的，但是这个名字不重要，记得在以后使用时用它的名字就可以了。 注意即使你有一款好网卡，虚拟机配置无误，Kali 也可以检测到它的存在，运行了上述指令也可能得不到期待的结果，这很有可能是由于某些网卡在 Kali 上运行并不免驱，下载相应的驱动应该可以解决问题。 Terminator这是一款可选的软件，并不必须，但是有了它操作将会方便许多，如果你经常使用 Kali ,这也是非常有用的软件之一。其实 Terminator 与系统自带的 Terminal 本质上一样，都是给我们执行指令用的，唯一的区别就是 Terminator 可以方便地创建多个窗口，便于我们同一时刻执行不同的指令。 要安装它，在系统自带的 Terminal 上执行以下指令即可： 1apt-get install terminator 原理所有的工具准备完成之后，就可以开始操作了。 目前的无线网络，大多数都使用相似的原理，接入点将数据包发布到空中，终端将它们捕获，这样，就实现了互相的通信。我们经常可以看到，有的时候有多台设备同时连接同样的网络，甚至在一个房间里有很多接入点和很多终端，它们同时接发数据包，却没有互相产生影响。这背后的道理是，每一个数据包在发送时都会有一个发送和接收的“地址”，就像我们发邮件一样，有发件人和收件人，而这个地址则被称为 MAC 地址，由于设备与设备之间的 MAC 地址不一样，它们发出或者接收数据包也不会互相干扰。 如果你正在使用一款 Windows 系列的操作系统，可以 Win+R 输入 cmd 调出命令提示符，输入 1ipconfig /all 找到 物理地址 这一栏，查看自己的 MAC 地址。 如果将外部网卡接入了 Kali，可以用 1ifconfig wlan0 查看，这里 ifconfig 是指令名字，wlan0 是我的网卡名字，之前说过，你的可能是什么别的，改成对应的名字即可。 一般来讲，每一个网卡在出厂的时候就会被赋予一个特定的 MAC 地址，我们可以将自己的网卡拆下来看看，这个 MAC 地址一般是不会变动的，但是，如果你有一款好用的网卡，它是可以改动的。连接上自己的网卡，在 Kali 中使用 macchanger 这个工具即可。 123ifconfig wlan0 downmacchanger -r wlan0ifconfig wlan0 up 这里分三步，首先让自己的网卡断开，然后改 MAC 地址，再激活。可以看见，我们的 MAC 地址由 32:D2:35:9E:D6:8B 变成了 D2:2D:9D:88:B1:1F. 这里 12macchanger -rmacchanger --random 即为随机 MAC 地址，当然，macchanger 还有其他的用法，可以使用 1macchanger --help 查看。当然，这种获取帮助的方法不仅限于 macchanger 这个指令，任何指令我们都可以在后面加上 —help 来看看它的使用方法。 目前，我们已经知道了一些有关网络运作的知识，而且会改 MAC 地址了。前面提到过，MAC 地址可以让不同的设备同时工作而不互相干扰，同理，我们可以通过更改自己的 MAC 地址来制造一些干扰。 具体说，我们首先捕获空中的数据包，从而发现附近的接入点和终端，进一步地，确定目标的 MAC 地址和为它工作的接入点的 MAC 地址，它们现在正在正常通信。然后将自己机器的 MAC 地址改成跟目标一样，用这个 MAC 地址向接入点发送取消连接的信息，接入点会认为目标想要取消连接，然后再将自己的 MAC 地址改得跟接入点一样，告诉目标你已经丢掉了连接。这个时候，目标会认为自己已经丢失了网络连接，所以原本打算发送的数据会停止发送，由于目标并不是真心想要断开连接，所以大部分操作系统都会自动地尝试重新连接，然后再发送数据包。这个时候我们只需要重复上述的步骤，就可以让目标虽然处在信号范围之内，但是无论如何也无法正常与接入点通信。 操作首先，这里我打开了另外一台电脑，它现在可以正常地工作，并且连上了互联网。 我们的目标是，在不干预目标机器的情况下，断开它与网络的连接。 要做到这一点，首先先打开 Kali Linux, 接上网卡，跟以前一样，用 1iwconfig 看看是否能够正常工作。 之前提到过，网卡有一个 MAC 地址，它只会接收发送到这个 MAC 地址的数据，其它的它不会去管它们，事实上，我们的网卡也是这么想的，可以看到上面模式那一栏写着 Managed. 这样，我们是无从得知接入点和目标的 MAC 地址的，首先要将网卡调成与之对应的 Monitor 模式，方法与我们之前修改 MAC 地址非常相似。 123ifconfig wlan0 downiwconfig wlan0 mode monitorifconfig wlan0 up 输入 1iwconfig wlan0 可以看到，此时模式已经变成了 Monitor. 这种模式下，网卡开始对所有的数据包感兴趣，无论它是从哪个 MAC 发送到哪里。 下一步，也是非常重要的一步，我们要使用一个叫做 airodump-ng 的工具捕捉附近所有的数据包，锁定目标。 1airodump-ng wlan0 这里 airodump-ng 是一个指令，wlan0 是我的网卡名字。按下回车。 找到一个目标网络之后，Ctrl+C 终止操作。这里以我自家网络 Mickey-snow 为例。终止操作的原因是因为我们现在正在获取所有的数据包，它们来自各个不同的接入点，现在我们的目标是 Mickey-snow, 所以可以只关注 Mickey-snow 的数据包。可以看到，我们现在获取了不少信息，简单解释一下，这里 BSSID 就是接入点的 MAC 地址，#Data 是我们获得的有用的数据包的个数，CH 是接入点所在的频道，ENC 是网络加密模式，一般分为 WEP 和 WPA/WPA2. 要想让网卡专注于特定的网络，只需要告诉它两个信息：BSSID 和 Channel. 1airodump-ng --channel 11 --bssid 0C:4B:54:2A:90:B3 wlan0 airodump-ng 是指令名字，—channel 描述频道，—bssid 描述 MAC，最后在附上网卡名字，按下回车。 在你那里由于你的目标跟我的不同，所以可能会使用不同的频道，不同的 BSSID, 不同的加密方式，但是这些都不重要，它们对我们接下来做的事情不会产生影响，只用在执行指令时按照自己获得的信息进行相应的替换即可。 获得的信息分为两栏，上面跟之前一样，是接入点的信息，重点是下面这一栏，可以看到，我们已经发现了一个目标，他的 MAC 地址写在了 STATION 那一栏，是 7C:11:BE:A9:BD:87. 现在我们就可以开始发起攻击了，这时我们需要使用另外一个工具 aireplay-ng 1aireplay-ng --deauth 100000 -a 0C:4B:54:2A:90:B3 -c 7C:11:BE:A9:BD:87 wlan0 还是一样，aireplay-ng 是指令名字，—deauth 是数据包数量，这里设成很大一个值，Access Point(-a) 是接入点地址，Client(-c) 是目标地址，wlan0 是网卡名字。按下回车。 顺便一提，如果这时不想中断 airodump-ng. 可以在之前提到的 Terminator 中右键，选择 Split 分割一下窗口，就可以一边运行其它指令，同时观察结果了。 如果出现了类似下面的情况，说明已经发动了攻击，不过有的时候它可能会失败，这时有发生，多试几次即可。 回到目标电脑，发现断掉了网络连接，虽然还在信号范围之内，但是已经无法访问互联网。 这样，我们成功地解除掉了目标设备与互联网的连接，而且整个过程不用联网。 顺便一提，再回到之前的指令部分： 1aireplay-ng --deauth 100000 -a 0C:4B:54:2A:90:B3 -c 7C:11:BE:A9:BD:87 wlan0 如果这个时候我们不给出目标的 BSSID 1aireplay-ng --deauth 100000 -a 0C:4B:54:2A:90:B3 wlan0 可以断掉所有接入目标接入点的设备与互联网的连接，类似地，也可以不写接入点 BSSID, 针对目标终端进行攻击。 注意事项为了保证以上步骤顺利进行，确保你有一个好用的网卡。判断网卡好坏最重要的不是品牌，而是芯片，即便是很好的牌子，它的某些型号的芯片也并不好用。 不要用这种方法给他人制造麻烦。]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Untagged</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】 CF1051D Bicolorings]]></title>
    <url>%2F2018%2F10%2F04%2FCF1051D-Bicolorings%2F</url>
    <content type="text"><![CDATA[一道 CF 状压 DP 水题。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;int main()&#123; int totLists, totComponents; scanf("%d%d", &amp;totLists, &amp;totComponents); int D[2][1 &lt;&lt; 2][2001] = &#123;&#125;, now = 0, last = 1, diff; D[now][1][2] = D[now][1 &lt;&lt; 1][2] = D[now][(1 &lt;&lt; 2) - 1][1] = D[now][0][1] = 1; for (int i = 1; i &lt; totLists; i++) &#123; std::swap(now, last); memset(D[now], 0, sizeof(D[now])); for (int S = 0; S &lt; (1 &lt;&lt; 2); S++) for (int k = 1; k &lt;= std::min((i &lt; 30 ? (1 &lt;&lt; (i + 1)) : INT_MAX), totComponents); k++) for (int T = 0; T &lt; (1 &lt;&lt; 2); T++) &#123; diff = 2; if (((S &amp; 1) == (T &amp; 1)) || (((S &amp; 2) == (T &amp; 2)) &amp;&amp; (S == 0 || S == 3)))diff--; if (((S &amp; 2) == (T &amp; 2)) || (((S &amp; 1) == (T &amp; 1)) &amp;&amp; (S == 0 || S == 3)))diff--; if ((S == 0 || S == 3) &amp;&amp; (T == 0 || T == 3) &amp;&amp; (S != T))diff = 1; if (k &lt;= diff)continue; D[now][S][k] += D[last][T][k - diff]; D[now][S][k] %= 998244353; &#125; &#125; int cnt = 0; for (int i = 0; i &lt; (1 &lt;&lt; 2); i++) cnt = (cnt + D[now][i][totComponents]) % 998244353; printf("%d\n", cnt); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】AHOI2009 中国象棋]]></title>
    <url>%2F2018%2F10%2F02%2FAHOI2009-%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[题目在这里. 这是一道有点毒瘤的计数题。大致意思是在一个大小为 $n\times m$ 的棋盘上放任意数量个中国象棋中的炮，使得他们不能互相攻击，求出方案数。 记 $f_{i,j,k}$ 为前 $i$ 行，其中 $j$ 列放置两个炮，$k$ 列放置一个炮的方案数。假定我们现在处于某一个状态，需要在一行上面放置数个炮来转移，可见这一行最多只能放 2 个炮，在此基础之上，一共有 6 种可能： 不在这一行放置。没有附加条件。 在这一行一个没有炮的列放置一个炮。需要有至少一个空列。 在这一行两个没有炮的列放置两个炮。需要有至少两个空列。 在这一行一个只有一个炮的列放置一个炮。需要有至少一个有一个炮的列。 在这一行两个只有一个炮的列放置两个炮。需要有至少两个有一个炮的列。 在这一行一个只有一个炮的列放置一个炮，并在一个没有炮的列放置一个炮。需要有至少一个有一个炮的列和至少一个空列。 明确了这些转移和它们的条件，方程和程序就很好写了，但是，还是需要注意下细节。对应的转移方程和条件分别如下： f_{i+1,j,k}\;+\!\!=\;f_{i,j,k}\\ f_{i+1,j,k+1}\;+\!\!=\;f_{i,j,k}\times(m-j-k)\qquad | \quad m-j-k\ge1\\ f_{i+1,j,k+2}\;+\!\!=\;f_{i,j,k}\times(m-j-k)\times(m-j-k-1)\div2\qquad | \quad m-j-k\ge2\\ f_{i+1,j+1,k-1}\;+\!\!=\;f_{i,j,k}\times k\qquad | \quad k\ge1\\ f_{i+1,j+2,k-2}\;+\!\!=\;f_{i,j,k}\times k\times (k-1)\div2\qquad | \quad k\ge2\\ f_{i+1,j+1,k}\;+\!\!=\;f_{i,j,k}\times k\times (m-j-k)\qquad | \quad k\ge1,\; m-j-k\ge1这样，总时间复杂度为 $O(6NM^2)$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define Cult(x) (((x)*((x)-1))&gt;&gt;1)long long D[101][101][101];int main()&#123; const long long mod = 9999973; int totLine, totList; std::cin &gt;&gt; totLine &gt;&gt; totList; assert(totLine &lt;= 100 &amp;&amp; totList &lt;= 100); ***D = 1; for (int i = 0; i &lt; totLine; i++) for (int j = 0; j &lt;= totList; j++) for (int k = 0; k + j &lt;= totList; k++) if (D[i][j][k] &gt; 0) &#123; const auto &amp;it = D[i][j][k]; D[i + 1][j][k] = (D[i + 1][j][k] + it) % mod; if (totList - j - k &gt;= 1)D[i + 1][j][k + 1] = (D[i + 1][j][k + 1] + it * (totList - j - k)) % mod; if (totList - j - k &gt;= 2)D[i + 1][j][k + 2] = (D[i + 1][j][k + 2] + it * Cult(totList - j - k)) % mod; if (k &gt;= 1)D[i + 1][j + 1][k - 1] = (D[i + 1][j + 1][k - 1] + it * k) % mod; if (k &gt;= 2)D[i + 1][j + 2][k - 2] = (D[i + 1][j + 2][k - 2] + it * Cult(k)) % mod; if (k &gt;= 1 &amp;&amp; totList - j - k &gt;= 1)D[i + 1][j + 1][k] = (D[i + 1][j + 1][k] + it * k*(totList - j - k)) % mod; &#125; long long cnt = 0; for (int i = 0; i &lt;= totList; i++) for (int j = 0; j + i &lt;= totList; j++) cnt = (cnt + D[totLine][i][j]) % mod; std::cout &lt;&lt; cnt &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>递推</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1041C Coffee Break]]></title>
    <url>%2F2018%2F10%2F02%2FCF1041C-Coffee-Break%2F</url>
    <content type="text"><![CDATA[题目在这里. 大致意思是说，一个名为 Recently Monocarp 的人得到了一份工作，每天工作 $m$ 小时，这 $m$ 小时从 1 至 $m$，他希望在某些天的 $n$ 个特定时刻休息，其中第 $i$ 个休息时间为 $a_i$, 这意味着他需要在某一天第 $a_i$ 个小时休息，这一天可以是任意一天，但是同一天内任何两次休息时间中间的间隔必须大于一个常数 $d$. 现在 Recently Monocarp 希望有休息的天数尽可能少，你需要求出这个最少天数，并给出一种可行的方案。 这道题看上去说了一堆条件很复杂的样子，但实际上就是一个贪心，当前时刻如果还能够一次休息就选择最近的那个时间点休息，然后再将当前时间加上最大间隔时间，同时判断一下这一天是不是结束了，用一个 set 维护一下，总时间复杂度为 $O(N\log N)$. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define MAXN 200500struct moment &#123; int ID, time; bool operator &lt; (const moment &amp;comp)const &#123; return time == comp.time ? ID &lt; comp.ID : time &lt; comp.time; &#125;&#125;;std::set&lt;moment&gt; S;int ans[MAXN];int main()&#123; int totTime, dayLen, minGap, t; scanf("%d%d%d", &amp;totTime, &amp;dayLen, &amp;minGap); ++minGap; for (int i = 0; i &lt; totTime; i++) &#123; scanf("%d", &amp;t); S.insert(&#123; i,t &#125;); &#125; int nowTime = 1, nowDay = 1; while (!S.empty()) &#123; const auto it = S.lower_bound(&#123; -1,nowTime &#125;); if (it == S.end()) &#123; nowDay++; nowTime = 1; continue; &#125; else &#123; nowTime = it-&gt;time + minGap; ans[it-&gt;ID] = nowDay; S.erase(*it); &#125; &#125; printf("%d\n", nowDay); for (int i = 0; i &lt; totTime; i++) printf("%d ", ans[i]); putchar('\n'); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>暴力/枚举</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】ZJOI2005 午餐]]></title>
    <url>%2F2018%2F10%2F02%2FZJOI2005-%E5%8D%88%E9%A4%90%2F</url>
    <content type="text"><![CDATA[题目在这里. 大致意思是有 $n$ 个人需要去食堂打饭并吃饭，第 $i$ 个人打饭时间为 $a_i$, 吃饭时间为 $b_i$, 食堂只有两个窗口，我们需要算出这些人全部吃完饭最少花费多长时间。 这是一道很有意思的动态规划题目，但是在此之前，我们需要先将所有的人排个序，让吃饭慢的排在前面，理由如下: 假定有两个人打饭吃饭时间分别为 $a,b,a^\prime,b^\prime$，而且 $b&lt;b^\prime$. 那么很容易得出让分别让两个人排在前面所需的总时间： a+a^\prime +\max(b-a^\prime,\,b^\prime)\\ a^\prime+a+\max(b^\prime-a,b)很明显，$\max(b-a^\prime,\,b^\prime) = b^\prime$. 而无论 $\max(b^\prime-a,b)$ 的最终结果是什么，都不可能比 $b^\prime$ 更大，因此让第一个人排在前面不可能让答案更优，吃饭所需时间越长的人应该越靠前。 不仅如此，无论我们怎么分配这些人，每一个窗口处的打饭顺序也应该是符合这个条件的。 我们假设两个窗口分别为 1 和 2. 记 $f_{i,j}$ 代表前 $i$ 个人 吃完 饭，而且所有在 1 窗口打饭的人 打饭花费 的总时间为 $j$ 的情况下，最少花费的时间。由于已经排好序，所以这个顺序一定是最优的。 转移方程如下： f_{i,j} = \min(\max(f_{i-1,j-a_i},\,j+b_i),\;\max(f_{i-1,j},\,\sum_{k=0}^i a_k\,-j+b_i))大致意思是将第 $i$ 个人放在 1 窗口和 2 窗口都可以算出一个确定的时间，然后在这两个时间中选择一个最短的即可。但是，有些情况下可能会 $j&lt;a_i$ ,这代表不能将 $i$ 放在 1 窗口，这种情况下强制放在 2 窗口即可。 此外，还可以使用前缀和优化时间，滚动数组优化空间。 这么做时间复杂度为 $O(N^3)$. 空间复杂度为 $O(N^2)$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define sqrN 50000#define MAXN 200struct Node &#123; int get, set; bool operator () (const Node a, const Node comp)const &#123; return a.set &gt; comp.set; &#125;&#125;;std::vector&lt;Node&gt; arr;int sum[MAXN], D[2][sqrN];int main()&#123; int totPeo, a, b; //Read scanf("%d", &amp;totPeo); if (totPeo &lt;= 0) &#123; puts("0"); return 0; &#125; assert(totPeo &lt;= 200); for (int i = 0; i &lt; totPeo; i++) &#123; scanf("%d%d", &amp;a, &amp;b); arr.push_back(&#123; a,b &#125;); &#125;std::sort(arr.begin(), arr.end(), Node()); *sum = arr.begin()-&gt;get; for (int i = 1; i &lt; totPeo; i++) sum[i] = sum[i - 1] + arr[i].get; //Dp int now = 0, last = 1; memset(D, 0x7f, sizeof(D)); **D = 0; for (int i = 0; i &lt; totPeo; i++) &#123; std::swap(now, last); memset(D[now], 0x7f, sizeof(D[now])); for (int j = 0; j &lt;= sum[i]; j++) D[now][j] = std::min((j &lt; arr[i].get ? INT_MAX : std::max(D[last][j - arr[i].get], j + arr[i].set)), std::max(D[last][j], sum[i] - j + arr[i].set)); &#125; int ans = INT_MAX; for (int i = 0; i &lt;= sum[totPeo - 1]; i++) ans = std::min(ans, D[now][i]); std::cout &lt;&lt; ans &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悬线法]]></title>
    <url>%2F2018%2F10%2F01%2F%E6%82%AC%E7%BA%BF%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概念悬线法是一种动态规划的思路。所谓悬线就是一条竖着的线，这条线的两个端点都在边界或者一个障碍点前，对于每一条确定下来的悬线，我们都可以求出一个确定的最大矩阵保证这条悬线在矩阵中。随后，我们左右移动这条悬线，可以得出数个不同得到最大矩阵，从而求出全局的极大矩阵。 思想悬线法需要我们预处理出三个二维数组： $left_{i,j},\space right_{i,h},\space up_{i,j}$ 分别代表在点 $(i,j)$ 这里向左，右，上方扩展直到碰到障碍点，其中 $left_{i,j},\space right_{i,h}$ 的数值为障碍点前一个点的横坐标，而 $up_{i,j}$ 代表在不碰到或者经过障碍点的情况下最多扩展多少步。 首先，我们需要先预处理出 $left$ 和 $right$. 12345678for (int i = 0; i &lt; totLine; i++) for (int j = 1; j &lt; totList; j++) if (true) lt[i][j] = lt[i][j - 1];for (int i = 0; i &lt; totLine; i++) for (int j = totList - 2; j &gt;= 0; j--) if (true) rt[i][j] = rt[i][j + 1]; 通常情况下，我们都有一个判定障碍点的方法，甚至有时候不存在确定的障碍点，而是只有两个点之间能否兼容，这些可以在 if 的条件下得到体现。 在正式 DP 时，当我们到达某一个点 $(i,j)$, 首先向上扩展 $t$ 格，并更新 $left_{i,j},\space right_{i,h}$ 为扩展之后最大矩形的左右边界。这样悬线和最大矩阵都已确定，接下来根据需要统计答案即可。 12345678910for (int i = 0; i &lt; totLine; i++) for (int j = 0; j &lt; totList; j++) if (map[i][j]) &#123; if (i != 0 &amp;&amp; true) &#123; up[i][j] = up[i - 1][j] + 1; lt[i][j] = std::max(lt[i][j], lt[i - 1][j]); rt[i][j] = std::min(rt[i][j], rt[i - 1][j]); &#125; // ans &#125; 很容易发现，这么做是正确的。因为对于每一个点，我们都求出了它对应的悬线，得出了关于这条悬线的最大矩阵，也就是说，所有可能成为答案的矩阵都已经被考虑过了。 题集LG4147. USACO Big Barn. ZJOI2007棋盘制作. LG1387. LG1681.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】LG1387 最大正方形]]></title>
    <url>%2F2018%2F09%2F28%2FLG1387-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题目在这里. 尽管本题数据范围非常小，即便是最朴素的暴力 $O(N^4)$ 也可以过掉。但是本题却是一个非常标准的悬线法动态规划模板题，可以优化到 $O(N^2)$. 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define MAXN 100#define MAXM MAXNbool map[MAXN][MAXM];int lt[MAXN][MAXM], rt[MAXN][MAXM], up[MAXN][MAXM];int main() &#123; int _max = 0, res, totLine, totList; scanf("%d%d", &amp;totLine, &amp;totList); for (int i = 0; i &lt; totLine; i++) for (int j = 0; j &lt; totList; j++) &#123; scanf("%d", &amp;res); map[i][j] = res == 1; if (res == 1) &#123; lt[i][j] = rt[i][j] = j; up[i][j] = 1; &#125; &#125; for (int i = 0; i &lt; totLine; i++) for (int j = 1; j &lt; totList; j++) if (map[i][j] &amp;&amp; map[i][j - 1]) lt[i][j] = lt[i][j - 1]; for (int i = 0; i &lt; totLine; i++) for (int j = totList - 2; j &gt;= 0; j--) if (map[i][j] &amp;&amp; map[i][j + 1]) rt[i][j] = rt[i][j + 1]; for (int i = 0; i &lt; totLine; i++) for (int j = 0; j &lt; totList; j++) if (map[i][j]) &#123; if (i != 0 &amp;&amp; map[i - 1][j]) &#123; up[i][j] = up[i - 1][j] + 1; lt[i][j] = std::max(lt[i][j], lt[i - 1][j]); rt[i][j] = std::min(rt[i][j], rt[i - 1][j]); &#125; _max = std::max(_max, std::min(rt[i][j] - lt[i][j] + 1, up[i][j])); &#125; std::cout &lt;&lt; _max &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】ZJOI2007 棋盘制作]]></title>
    <url>%2F2018%2F09%2F28%2FZJOI2007-%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[题目在这里. 这道题目可以使用所谓的 悬线法 解决。大致题意是给定一个 01 矩阵，我们需要找到一块 01 相间的正方形和一块这样的矩形子矩阵，并求出它们的最大面积分别是多少。 我们可以假定如果两个相邻的元素不相等，那么它们就可以被放在一起，我们认为他们是同种的，这样在判断的时候注意一下，就是一道模板题了。 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define sqr(x) ((x)*(x))#define MAXN 2001#define MAXM MAXNbool map[MAXN][MAXM];int rt[MAXN][MAXM], lt[MAXN][MAXM], up[MAXN][MAXM];int main()&#123; int totLine, totList, res; scanf("%d%d", &amp;totLine, &amp;totList); for (int i = 0; i &lt; totLine; i++) for (int j = 0; j &lt; totList; j++) &#123; scanf("%d", &amp;res); assert(res == 0 || res == 1); map[i][j] = (res == 1); rt[i][j] = lt[i][j] = j; up[i][j] = 1; &#125; //预处理 for (int i = 0; i &lt; totLine; i++) for (int j = 1; j &lt; totList; j++) if (map[i][j] ^ map[i][j - 1]) lt[i][j] = lt[i][j - 1]; for (int i = 0; i &lt; totLine; i++) for (int j = totList - 2; j &gt;= 0; j--) if (map[i][j] ^ map[i][j + 1]) rt[i][j] = rt[i][j + 1]; //Dp int max1 = 1, max2 = 1; for (int i = 0; i &lt; totLine; i++) for (int j = 0; j &lt; totList; j++) &#123; if (i != 0 &amp;&amp; (map[i][j] ^ map[i - 1][j])) &#123; lt[i][j] = std::max(lt[i][j], lt[i - 1][j]); rt[i][j] = std::min(rt[i][j], rt[i - 1][j]); up[i][j] = up[i - 1][j] + 1; &#125; //更新答案 max1 = std::max(max1, (rt[i][j] - lt[i][j] + 1)*up[i][j]); max2 = std::max(max2, sqr(std::min(up[i][j], (rt[i][j] - lt[i][j] + 1)))); &#125; printf("%d\n%d\n", max2, max1); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】Church]]></title>
    <url>%2F2018%2F09%2F27%2FChurch%2F</url>
    <content type="text"><![CDATA[在这题中，需要分不同的情况进行讨论。 如果 $n=1$ 或者 $m=1$ ,那么方案是确定下来了的，路径长度为 $2n(m-1)$ 或者 $2m(n-1)$. 假设当前处于任意一点，那么下一步可以朝 8 个方向进行移动，但是这 8 个方向只有两种可能的路径长度: 1 和 $\sqrt{2}$. 如果 $2|nm$, 那么路径长度为 $nm$. 这已经是理论下界，因为我们需要移动至少 $nm$ 次，而每一次移动至少走长度为 1 的路径。而无论如何，我们都可以构造出如下的方案： 如果不是这样，能不能走一个 $nm$ 长度的路径返回出发点？实际上是不行的，因为我们需要走奇数次 1 路径，而这样无论如何都无法回到出发点。解决的办法是将一个 1 路径换成一个 $\sqrt2$ 路径，这样就可以构造出如下方案： 代码如下： 1234567891011121314151617#include&lt;bits/stdc++.h&gt;int main()&#123; long long n, m; std::cin &gt;&gt; n &gt;&gt; m; if (n == 1 || m == 1)printf("%.2lf", (double)(((n == 1 ? n : n - 1) * (m == 1 ? m : m - 1)) &lt;&lt; 1)); else &#123; if ((n*m) &amp; 1)printf("%.2lf", (double)n * m - 1 + std::sqrt(2)); else printf("%.2lf", (double)n*m); &#125; putchar('\n'); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P1983 车站分级]]></title>
    <url>%2F2018%2F09%2F27%2FP1983-%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[题目在这里. 这题目意思就是说，有 $n$ 个数，每一次告诉你在一个区间里面有一些数大于其它的数，求最少多少个不同的数可以满足这些要求。直接按照题意建立模型，拓扑排序跑一遍即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define MAXN 1001#define MAXM MAXNbool G[MAXN][MAXN];std::vector&lt;int&gt; arr;std::queue&lt;int&gt; que;int main()&#123; bool init[MAXN], inQueue[MAXN]; int totStation, totTr, totStop, a, begin, end, _max = 1; int val[MAXN], inDegree[MAXN] = &#123;&#125;; memset(G, false, sizeof(G)); scanf("%d%d", &amp;totStation, &amp;totTr); for (int i = 0; i &lt; totTr; i++) &#123; scanf("%d", &amp;totStop); assert(totStop &gt;= 0); memset(init, false, sizeof(init)); begin = INT_MAX; end = INT_MIN; &#123;std::vector&lt;int&gt; T; std::swap(T, ::arr); &#125; while (totStop--) &#123; scanf("%d", &amp;a); arr.push_back(--a); init[a] = true; begin = std::min(begin, a); end = std::max(end, a); &#125; assert(begin &lt;= end); for (const auto &amp;it : arr) for (int i = begin; i &lt; end; i++) if (!init[i] &amp;&amp; !G[i][it]) &#123; G[i][it] = true; inDegree[it]++; &#125; &#125; memset(inQueue, false, sizeof(inQueue)); memset(val, 0, sizeof(val)); for (int i = 0; i &lt; totStation; i++) if (inDegree[i] == 0) &#123; que.push(i); inQueue[i] = true; val[i] = 1; &#125; assert(!que.empty()); int nowAt; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); for (int i = 0; i &lt; totStation; i++) if (G[nowAt][i]) &#123; val[i] = std::max(val[i], val[nowAt] + 1); _max = std::max(_max, val[i]); if ((--inDegree[i] == 0) &amp;&amp; (!inQueue[i])) &#123; que.push(i); inQueue[i] = true; &#125; &#125; &#125; std::cout &lt;&lt; _max &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>暴力/枚举</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】NOI2001 炮兵阵地]]></title>
    <url>%2F2018%2F09%2F26%2FNOI2001-%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[题目在这里. 可以发现，如果在当前行做出了某一个决策，那么可能会影响此后的两行，所以，在状态压缩的过程中，我们需要保存一些额外的东西。 将每行摆放用一个二进制数每一位 0/1 分别代表 有 和 没有 ，以十进制的形式保存。记 $f_{line,S_i,S_j}$ 为当前为第 $line$ 行，这一行的摆放情况为 $S_i$, 上一行的摆放情况为 $S_j$,在此基础之上能够放置的最多炮兵。记 $Count(i)$ 为二进制数 $i$ 有多少位是 1. 那么可以发现 f_{line,S_i,S_j} = \max(f_{line-1,S_j,S_k}) + Count(S_i)这里需要枚举一下 $S_k$, 同时由于题目有较多的限制，所以有一部分的状态是不可能达到的非法状态，我们让这样的状态的 $f$ 为 -1. 在此后的计算中，不考虑这样的状态。如果满足了以下全部条件，即进行转移： $S_i, S_j,S_k$ 这样的摆放在各行都是可行的。 这样的摆放不会互相冲突，即不存在一列有超过一个炮兵。 $f_{line-1,S_j,S_k} \neq -1$. 最后，答案为 $\max(f_{totLine,S_i,S_j})$. 时间复杂度为 $O(N\times 8^M)$, 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;#define MAXN 150int surface[MAXN], D[2][1 &lt;&lt; 11][1 &lt;&lt; 11];std::vector&lt;int&gt; arr;bool ReadChar() &#123; char it; do it = std::toupper(getchar()); while (it != 'P'&amp;&amp;it != 'H'); return it == 'P';&#125;int CountBits(int it) &#123; int cnt = 0; for (; it &gt; 0; it &gt;&gt;= 1)if (it &amp; 1)cnt++; return cnt;&#125;bool Check(int a) &#123; a &lt;&lt;= 2; while (a &gt; 0) &#123; while ((a&amp;(1 &lt;&lt; 2)) == 0)a &gt;&gt;= 1; if ((a&amp;((1 &lt;&lt; 5) - 1)) != (1 &lt;&lt; 2))return false; a &gt;&gt;= 3; &#125;return true;&#125;bool Check(int a, int b) &#123; if (!(Check(a) &amp;&amp; Check(b)))return false; while (a &gt; 0) &#123; if ((a &amp; 1) &amp;&amp; (b &amp; 1))return false; a &gt;&gt;= 1; b &gt;&gt;= 1; &#125;return true;&#125;bool Match(const int &amp;a, const int &amp;b) &#123; if ((a | b) &gt; b)return false; else return true;&#125;int main()&#123; int totLine, totList, now, last; scanf("%d%d", &amp;totLine, &amp;totList); assert(totLine &lt;= 100); assert(totList &lt;= 10); for (int i = 1; i &lt;= totLine; i++) &#123; surface[i] = 0; for (int j = 0; j &lt; totList; j++) if (ReadChar()) surface[i] |= (1 &lt;&lt; j); &#125; for (int i = (1 &lt;&lt; totList) - 1; i &gt;= 0; i--) if (Check(i, 0)) arr.push_back(i); //const int FULL = (1 &lt;&lt; totList) - 1; now = 0; last = 1; for (int nowLine = 1; nowLine &lt;= totLine; nowLine++) &#123; std::swap(now, last); for (const auto &amp;i : arr) for (const auto &amp;j : arr) &#123; if ((!Check(i, j)) || (!Match(i, surface[nowLine])) || (!Match(j, surface[nowLine - 1]))) &#123; D[now][i][j] = -1; continue; &#125; else D[now][i][j] = 0; for (const auto &amp;k : arr) &#123; if (D[last][j][k] &lt; 0)continue; if (nowLine - 2 &gt;= 0 &amp;&amp; (!Match(k, surface[nowLine - 2])))continue; if (Check(i, k) &amp;&amp; Check(j, k)) D[now][i][j] = std::max(D[now][i][j], D[last][j][k] + CountBits(i)); &#125; &#125; &#125; int _max = 0; for (const auto &amp;it : arr) for (const auto &amp;ls : arr) if (Match(it, surface[totLine]) &amp;&amp; Match(ls, surface[totLine - 1])) _max = std::max(_max, D[now][it][ls]); std::cout &lt;&lt; _max &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】BJWC2010 外星联络]]></title>
    <url>%2F2018%2F09%2F25%2FBJWC2010-%E5%A4%96%E6%98%9F%E8%81%94%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[在本题中，我们其实可以将所有字串出现次数全部统计出来，方法是利用 Trie. 在每次插入时，加入一个新的字符就将在这里结束的串的数量加一，这样我们就统计完成了以某一个位置为起点的所有串。将整个串从头到尾扫一遍然后重复这个操作，就可以完成全部子串的统计，这一步是指数级别的。 之后，只需要将整棵树先序遍历一遍，即为字典序，如果当前出现次数大于 1 则打印出来，这一步的复杂度是线性级别的。 完整的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define MAXN 9000002int ch[MAXN][2], endHere[MAXN], tail = 1;short num[3000];short read() &#123; char it; do it = getchar(); while (it != '0'&amp;&amp;it != '1'); return it - '0';&#125;void dfs(const int &amp;nowAt = 0) &#123; if (endHere[nowAt] &gt; 1)printf("%d\n", endHere[nowAt]); if (ch[nowAt][0] != -1)dfs(ch[nowAt][0]); if (ch[nowAt][1] != -1)dfs(ch[nowAt][1]);&#125;int main()&#123; memset(ch, -1, sizeof(ch)); memset(endHere, 0, sizeof(endHere)); int len, nowAt; scanf("%d", &amp;len); for (int i = 0; i &lt; len; i++)num[i] = read(); for (int st = 0; st &lt; len; st++) &#123; nowAt = 0; for (int i = st; i &lt; len; i++) &#123; if (ch[nowAt][num[i]] == -1)ch[nowAt][num[i]] = tail++; nowAt = ch[nowAt][num[i]]; endHere[nowAt]++; &#125; &#125;dfs(); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P1113 杂务]]></title>
    <url>%2F2018%2F09%2F24%2FP1113-%E6%9D%82%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[题目在这里. 记一共有 $n$ 个任务。一个任务 $i$ 的前置任务有 $m$ 个，从 $pre_{i,0}$ 到 $pre_{i,m}$，它最早在 $time_i$ 时刻完成，完成它需要的时间为 $t_i$。 那么对于每一个任务的完成时间，有 time_i = \begin{cases} t_i \space\space\space\space m=0\\ \max(pre_{i,j})+t_i\space\space\space \text{else} \end{cases}答案为 \max(time_i)代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;using System.Collections.Generic;namespace P1113&#123; class Program &#123; public class G &#123; public static List&lt;int&gt;[] Gp; public static bool[] vis; public static int[] fin, time; &#125; static void Main(string[] args) &#123; string[] div; int totJob = Convert.ToInt32(Console.ReadLine()), jobID, minTime = 0; G.Gp = new List&lt;int&gt;[totJob]; for (int i = 0; i &lt; totJob; i++) G.Gp[i] = new List&lt;int&gt; &#123; &#125;; G.vis = new bool[totJob];G.fin = new int[totJob];G.time = new int[totJob]; for(int i = 0; i &lt; totJob; i++) &#123; div = Console.ReadLine().Split(' '); jobID = Convert.ToInt32(div[0]) - 1;G.time[jobID] = Convert.ToInt32(div[1]); for (int j = 2; div[j] != "0"; j++) G.Gp[jobID].Add(Convert.ToInt32(div[j]) - 1); &#125; for (int i = 0; i &lt; totJob; i++) minTime = Math.Max(minTime, f(i)); Console.WriteLine(minTime.ToString()); &#125; static int f(int job) &#123; if (G.vis[job]) return G.fin[job]; int fin = 0;G.vis[job] = true; foreach (var it in G.Gp[job]) fin = Math.Max(fin, f(it)); return (G.fin[job] = fin + G.time[job]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模拟</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P1514 引水入城]]></title>
    <url>%2F2018%2F09%2F24%2FP1514-%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[这是一道毒瘤题。 先 BFS 两次，第一次判断可行性，即上面所有的城市都建造蓄水厂能不能覆盖全部的沙漠城市，如果不行直接退出程序。 第二次 BFS 对沿海城市逐个搜索，求出在这里建造蓄水厂能够覆盖的城市。可以发现，如果当前城市 高于它两边的城市 ，又因为最终一定有解，所以它的覆盖范围是一个连续区间。如果不是这样，那么这个城市就肯定没有选择的必要，因为它的旁边就有一个比它更高的城市，在那里建立蓄水厂只可能覆盖到更多的城市。加上了这个优化不仅简化了问题，更节省了大量计算能力。 最后，问题就变成了给定一堆区间，求出最少选多少个区间使得它们的区间并等于整段区间。直接暴力动态规划即可。 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define MAXN 550#define MAXM MAXNint high[MAXN][MAXM];bool vis[MAXN][MAXM];std::queue&lt; std::pair&lt;int, int&gt; &gt; que;std::vector&lt; std::pair&lt;int, int&gt; &gt;arr;const int cgx[] = &#123; 0,0,1,-1 &#125;, cgy[] = &#123; 1,-1,0,0 &#125;;int main()&#123; int totLine, totList; //Read scanf("%d%d", &amp;totLine, &amp;totList); assert(NULL &lt; totLine &amp;&amp; totLine &lt;= MAXN &amp;&amp; NULL &lt; totList&amp;&amp;totList &lt;= MAXM); for (int i = 0; i &lt; totLine; i++)for (int j = 0; j &lt; totList; j++) scanf("%d", high[i] + j); //检查可行性 if (totLine &gt; 1) &#123; memset(vis, false, sizeof(vis)); for (int i = 0; i &lt; totList; i++) &#123; que.push(std::make_pair(0, i)); vis[0][i] = true; &#125; int points = totList; bool flag = false; while (points &gt; 0 &amp;&amp; !que.empty()) &#123; const auto nowAt = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; auto it = std::make_pair(nowAt.first + cgy[i], nowAt.second + cgx[i]); if (it.first &lt; 0 || it.first &gt;= totLine || it.second &lt; 0 || it.second &gt;= totList || vis[it.first][it.second] || high[it.first][it.second] &gt;= high[nowAt.first][nowAt.second]) continue; vis[it.first][it.second] = true; if (it.first == totLine - 1) if (--points &lt;= 0) &#123; flag = true; break; &#125; que.push(it); &#125; if (flag)break; &#125; if (!flag) &#123; //无解 printf("0\n%d\n", points); //system("pause"); return 0; &#125; &#125; puts("1"); //Find Seg int start, end; for (int startPos = 0; startPos &lt; totList; startPos++) &#123; if (startPos != 0 &amp;&amp; high[0][startPos] &lt; high[0][startPos - 1])continue; if (startPos != totList - 1 &amp;&amp; high[0][startPos] &lt; high[0][startPos + 1])continue; start = totLine == 1 ? startPos : INT_MAX; end = totLine == 1 ? startPos : INT_MIN; memset(vis, false, sizeof(vis)); &#123; std::queue&lt; std::pair&lt;int, int&gt; &gt; T; std::swap(T, que); &#125; que.push(std::make_pair(0, startPos)); vis[0][startPos] = true; while (!que.empty()) &#123; const auto nowAt = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; auto it = std::make_pair(nowAt.first + cgy[i], nowAt.second + cgx[i]); if (it.first &lt; 0 || it.first &gt;= totLine || it.second &lt; 0 || it.second &gt;= totList || vis[it.first][it.second] || high[it.first][it.second] &gt;= high[nowAt.first][nowAt.second]) continue; vis[it.first][it.second] = true; if (it.first == totLine - 1) &#123; start = std::min(start, it.second); end = std::max(end, it.second); &#125;que.push(it); &#125; &#125; if (start &lt;= end) arr.push_back(std::make_pair(start, end)); &#125; int D[MAXM]; memset(D, 0x7f, sizeof(D)); for (int i = 0; i &lt; totList; i++) for (const auto &amp;it : arr) if (i &gt;= it.first&amp;&amp;i &lt;= it.second) D[i] = it.first == 0 ? 1 : std::min(D[i], D[it.first - 1] + 1); assert(D[totList - 1] &lt;= totList); std::cout &lt;&lt; D[totList - 1] &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>暴力/枚举</tag>
        <tag>搜索</tag>
        <tag>线性动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】SCOI2005 互不侵犯]]></title>
    <url>%2F2018%2F09%2F23%2FSCOI2005-%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF%2F</url>
    <content type="text"><![CDATA[这是一道状态压缩动态规划基础题。 定义 $D_{i,cnt,S}$ 代表第 $i$ 行的状态为 $S$ ,前 $i$ 行一共有 $cnt$ 个国王的方案数。十进制数 $S$ 代表这一行棋子的情况按照二进制表示：0 代表没有，1 反之。初始状态 $D_{0,0,\varnothing} = 1$ ，其它的等于 0. 目标状态：$\sum D_{size,knights,S}$. 假定前 $i-1$ 行都已经正确地完成了计算，现在需要求第出 $i$ 行的一个状态 $D_{i,k,S}$. 假设这一行按照 $S$ 摆放是没有冲突的，而且上一行的状态为 $T$ ，这两行也不会互相冲突。那么 D_{i,k,S} = \sum D_{i-1,k-Count(S),T}这里 Count() 函数返回一个整数用二进制表示之后有多少个 1. 在这里代表第 $i$ 行有多少个棋子。 所有状态的转移至依赖于上一行，所以可以利用滚动数组将第一维变为 0/1. 其次，还可以预处理出集合 $S$ 所有可能的值，即单独一行没有冲突的所有摆放方案，减少很大一部分枚举。 这么做之后总时间复杂度为 $O(NM|S|^2)$. 事实上 $|S|$ 非常小，即使是面对最大的数据，也没有超过 150. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;long long D[2][90][1 &lt;&lt; 11];//当前行/上一行 总共国王数量 这一行的状态std::vector&lt;int&gt; S;int CountBit(int targ) &#123; int cnt = 0; for (; targ &gt; 0; targ &gt;&gt;= 1)if (targ &amp; 1)cnt++; return cnt;&#125;bool Check(int now, int last) &#123; now &lt;&lt;= 1; last &lt;&lt;= 1; while (now &gt; 0) &#123; if (now &amp; 2) if (((last&amp;((1 &lt;&lt; 3) - 1)) != 0) || ((now&amp;((1 &lt;&lt; 3) - 1)) != 2)) return false; now &gt;&gt;= 1; last &gt;&gt;= 1; &#125;return true;&#125;int main()&#123; memset(D, 0, sizeof(D)); int siz, totKnight; std::cin &gt;&gt; siz &gt;&gt; totKnight; //预处理 for (int i = 0; i &lt; (1 &lt;&lt; (siz)); i++) if (Check(i, 0))S.push_back(i); //Dp int now = 0, last = 1; ***D = 1; for (int i = 1; i &lt;= siz; i++) &#123; //当前行 std::swap(now, last); for (int numb = 0; numb &lt;= totKnight; numb++) for (const auto &amp;statu : S) &#123; if (CountBit(statu) &gt; numb)continue; D[now][numb][statu] = 0; for (const auto &amp;prev : S) if (Check(statu, prev) &amp;&amp; CountBit(statu) + CountBit(prev) &lt;= numb) //可以转移 D[now][numb][statu] += D[last][numb - CountBit(statu)][prev]; &#125; &#125; //统计答案 long long cnt = 0; for (const auto &amp;it : S) cnt += D[now][totKnight][it]; std::cout &lt;&lt; cnt &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩动态规划</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1034A Enlarge GCD]]></title>
    <url>%2F2018%2F09%2F22%2FCF1034A-Enlarge-GCD%2F</url>
    <content type="text"><![CDATA[题目在这里. 给你 $n$ 个数，第 $i$ 个为 $a_i \in N^+$. 现在你需要去掉其中的一些数(不能是全部的数)使得剩下的数的最大公约数比原先所有数的最大公约数大。你需要求出最少去掉多少个数可以达成这一目标，无解输出 -1. 这是一道数学题。记原先 $n$ 个数中第 $i$ 个数为 $a_i$, 它们的最大公约数为 $\gcd(a)$. 设剩下的数有 $m$ 个，其中第 $i$ 个是 $b_i$,他们的最大公约数为 $\gcd(b)$. 首先，我们将数组 $a$ 中所有的元素唯一分解，那么 $\gcd(a)$ 就是这些质因子的交集 (如果是空集那么 $\gcd(a) = 1$ ) 现在我们要去掉一部分元素使得这个交集扩大。记这个集合为 $S$ ,那么如果我们任意地去掉几个元素，$|S|$ 肯定是不会变小的。现在考虑如何尽可能少地去掉元素。 要想让 $|S|$ 变大，我们只需要往里面加入一个质因子即可，因为如果多了反而可能需要删掉更多的数。将 $a$ 中所有元素除以 $\gcd(a)$ 得到一个新的数组 $c$ ,也就是说 $\forall c_i = a_i\div \gcd(a)$. 将数组 $c$ 中所有的元素唯一分解，记 $cnt_i =i$ 这个质因子能够被 $c$ 中多少个数整除。那么，最划算的就是加入一个 $cnt_j$ 最大的数 $j$.因为有最多的数包含这个质因子，将剩下 $n-cnt_j$ 个不包含 $j$ 这个质因子的数去掉即可。 很容易发现，这么做一定是最优的，想让 $\gcd(a)$ 变大，唯一的方法是 通过去掉元素使得原本只属于部分元素的质因子属于全部元素 假定这个质因子为 $j$, 那么去掉了所有不包含 $j$ 或者包含 $j$ 的个数较少的元素，$\gcd(a)$ 就会变为 $\gcd(a)\times j$. 而对于每一个 $j$ ,这么做的代价是 $n-cnt_j$ .因此，删掉的元素数量随着 $cnt_j$ 增大而减小，一个最大的 $cnt_j$ 一定就是最优解了。 特别地，如果 $a$ 数组中元素全部一样那么一定无解。否则即便是只保留下一个 $a$ 中最大的元素也可以使得 $\gcd(a)$ 变得更大。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define MAXN (300010)#define MAXM (15000010)template&lt;typename T&gt;T gcd(T a, T b) &#123; if (a == b)return a; return b == 0 ? a : gcd(b, a%b); &#125;int min_Factor[MAXM]; std::vector&lt;int&gt; prime;int get_Primes(const int siz) &#123; if (siz &lt; 2)return 0; memset(min_Factor, 0, sizeof(min_Factor)); for (int i = 2; i &lt; siz; i++) &#123; if (min_Factor[i] == 0) &#123; min_Factor[i] = i; prime.push_back(i); &#125; //i*prime[j] 将会被它的最小质因子 prime[i] 筛掉 for (int j = 0; j &lt; prime.size(); j++) &#123; if ( i*prime[j] &gt; siz || //超出范围 prime[j] &gt; min_Factor[i] //prime[j]并不是i*prime[j]的最小质因子 )break; min_Factor[i*prime[j]] = prime[j]; &#125; &#125; return prime.size();&#125;int cnt[MAXM], num[MAXN];int main()&#123; int totNums, _max, div, gcdAll; bool uniq = false; scanf("%d%d", &amp;totNums, num); gcdAll = *num; _max = *num; for (int i = 1; i &lt; totNums; i++) &#123; scanf("%d", num + i); _max = std::max(_max, num[i]); if (num[i] != *num)uniq = true; gcdAll = gcd(gcdAll, num[i]); &#125; //全部一样则无解 if (!uniq) &#123; puts("-1"); /*system("pause");*/ return 0; &#125; for (int i = 0; i &lt; totNums; i++) num[i] /= gcdAll; get_Primes(++_max); //唯一分解 for (int i = 0; i &lt; totNums; i++) while (num[i] &gt; 1) &#123; div = min_Factor[num[i]]; cnt[div]++; while (num[i] % div == 0) num[i] /= div; &#125; int appeTm = INT_MIN; for (int i = 1; i &lt; _max; i++) appeTm = std::max(appeTm, cnt[i]); //删掉的数尽可能少 std::cout &lt;&lt; totNums - appeTm &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数的线性筛法 模板]]></title>
    <url>%2F2018%2F09%2F22%2F%E7%B4%A0%E6%95%B0%E7%9A%84%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[如果一个正整数无法被除了 1 和自己之外的任何正整数整除，那么这个正整数就是素数，否则就是合数。特别地，1 不是素数。 要判定一个数是不是素数只需要看看能不能找到一个不是 1 或者它本身的数 $a$ 将其整除即可，假定 $p=a\times b\space \space(a\leq b)$, 那么我们只需要找到了 $a$ ，即可判定 $p$ 不是素数，可以发现，如果存在 $a$ ，那么 $a\leq \sqrt{p}​$. 123456bool isPrime(int targ) &#123; if (targ &lt; 2)return false; int siz = std::sqrt(targ); for (int i = 2; i &lt;= siz; i++)if (targ%i == 0)return false; return true;&#125; 如果我们需要找到正整数区间 $(1,n]$ 内所有的素数，那么就需要使用到所谓的素数的筛选算法。有一种算法可以在 $O(N)$ 的时间复杂度内解决这个问题。 如果一个数存在一个不等于它本身的质因子，那么它就不是一个素数。这样，我们可以寻找每一个合数最小的质因子，用这个质因子将他们筛掉。记 $f_i = i$ 最小的质因子。我们用一个循环从 2 开始，起初 $\forall f_i=0$, 如果循环到某一个数 $i$ 满足 $f_i = 0$, 那么意味着我们 在此之前 没有找到它的任何质因子,直到现在 $f_i = i$ ,因为 $i$ 是一个素数。 如果目前循环到一个数 $t$, 无论它是不是一个素数我们都可以尝试将 $f_t$ 乘上一个之前得到的素数来筛掉 $f_t \times prime_i$ ，此时 $f_{f_t \times prime_i} = prime_i$. 特别地，如果 $prime_i &gt; f_t$ ，说明 $f_t \times prime_i$ 的最小质因子已经不是 $prime_i$ 了，这时就不用再去考虑更大的素数了。 执行上述步骤之后，每一个合数都是被自己最小的质因子筛掉的，根据唯一分解定理，如果一个合数只可能被自己最小的质因子筛掉，那么 它一定只被筛掉了一次。因此，这个算法时间复杂度是 $O(N)$. 123456789101112131415161718int min_Factor[MAXM]; std::vector&lt;int&gt; prime;int get_Primes(const int siz) &#123; if (siz &lt; 2)return 0; memset(min_Factor, 0, sizeof(min_Factor)); for (int i = 2; i &lt; siz; i++) &#123; if (min_Factor[i] == 0) &#123; min_Factor[i] = i; prime.push_back(i); &#125; //i*prime[j] 将会被它的最小质因子 prime[i] 筛掉 for (int j = 0; j &lt; prime.size(); j++) &#123; if ( i*prime[j] &gt; siz || //超出范围 prime[j] &gt; min_Factor[i] //prime[j]并不是i*prime[j]的最小质因子 )break; min_Factor[i*prime[j]] = prime[j]; &#125; &#125; return prime.size();&#125; //返回值为区间内素数的个数 另外一种名为 Eratosthenes 筛法的算法也可以得到这样的素数表，非常好写且时间复杂度为 $O(N\log\log N)$ ,已经非常接近于线性。但是，线性筛法不仅帮助我们得到了素数，还可以告诉我们一些额外的东西。例如 $f_i$ 就是 $i$ 最小的质因子，且区间内所有的 $f_i$ 都是已经完成了计算的。这样有什么用处呢？如果给你一堆正整数，其中第 $i$ 个是 $a_i$ ，你需要将他们唯一分解，这个时候我们就可以先使用线性筛法筛 $(1,\max(a_i)]$ 范围内的素数，然后对于任何一个 $t\in a$,将 $t$ 不断地除去 $f_t$, 这样与使用所谓的试除法相比，节约了大量的计算能力。]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】POJ3585 Accumulation Degree]]></title>
    <url>%2F2018%2F09%2F20%2FPOJ3585-Accumulation-Degree%2F</url>
    <content type="text"><![CDATA[题目大致意思是有一个连通的无向图由 $n$ 个结点和 $n-1$ 条边构成，如果任取一点为根，就可以转换为一个有根树，我们称根为源点，所有叶子节点为汇点，源点会源源不断地流出水来，这些水将流向汇点。所有的边都有一个流量值，单位时间流过这条边的水量不能超过这个值，而且中间的结点不能囤积水量，如果源点任取，那么最终有多少单位的水可以流向汇点。 我们假设以 $i$ 为源点，以 0 号结点为根，总共可以流 $f_i$ 单位的水到汇点。那么这 $f_i$ 单位的水量就是流向了 $i$ 的儿子和经由它的祖先流向别处，如图。 假定我们已经到达了一个结点 $v$ ，如何更新它的一个儿子 $t$ 的 $f_t$ ?由于 $v$ 很可能有多个儿子，而 $f_t$ 又依赖于其它儿子的 $f$ 值，而其他儿子的 $f$ 值又依赖于 $f_t$. 很显然这样不可行。 这个时候，我们需要两次 dfs 来求出所有点的 $f$ 值。虽然 $f$ 很不好求，但是我们可以间接地求得，具体地说，定义 $d_i$ 为以 $i$ 为根的子树以 $i$ 为源点能够流入汇点的总水量。可见 d_i = \sum_{t \in son_i} \min(d_t, \space val_{i\leftrightarrow t})一次遍历即可求出说有点的 $d$ 值，接下来我们用另一次遍历求出 $f$ .假定当前结点为 $i$, $t$ 为 $i$ 的儿子。如果 $f_i$ 已经被正确地求出，那么 $f_t$ 可以分为向上和向下两部分。向下直接就是 $d_t$, 而向上稍微有点复杂，具体应该是 $f_i - i$流向 $t$ 的流量。也就是 $f_i - \min(d_t,\space val_{i\leftrightarrow t})$. 注意，由 $t$ 流向 $i$ 的流量不能超过 $val_{i\leftrightarrow t}$. f_t = d_t+\min(val_{i\leftrightarrow t},\space f_i-\min (d_t,\space val_{i\leftrightarrow t}))这样，两次 dfs ，$f_i$ 最大的结点 $i$ 即为流量最大时的源点， $f_i$ 即为所求答案。由于在 dfs 过程中 $f_i,\space d_i$ 每次更新都是 $O(1)$ 的，所以总时间复杂度为 $O(N)$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define MAXN 200050struct way &#123; int to, val;&#125;;std::vector&lt;way&gt; G[MAXN];bool vis[MAXN];int D[MAXN], f[MAXN], inDegree[MAXN];void dp(const int &amp;nowAt = 0)&#123; D[nowAt] = 0; vis[nowAt] = true; for (int i = 0; i &lt; G[nowAt].size();i++) &#123; const way &amp;it = G[nowAt][i]; if (!vis[it.to]) &#123; dp(it.to); if (inDegree[it.to] != 1) D[nowAt] += std::min(it.val, D[it.to]); else D[nowAt] += it.val; &#125; &#125;&#125;void dfs(const int &amp;nowAt = 0)&#123; vis[nowAt] = true; for (int i = 0; i &lt; G[nowAt].size(); i++) &#123; const way &amp;it = G[nowAt][i]; if (!vis[it.to]) &#123; if (inDegree[nowAt] == 1)f[it.to] = D[it.to] + it.val; else f[it.to] = D[it.to] + std::min(f[nowAt] - std::min(D[it.to], it.val), it.val); dfs(it.to); &#125; &#125;&#125;int main()&#123; int totCases, totNodes, fr, to, val; scanf("%d", &amp;totCases); while (totCases--) &#123; scanf("%d", &amp;totNodes); memset(inDegree, 0, sizeof(inDegree)); memset(D, 0, sizeof(D)); memset(f, 0, sizeof(f)); for (int i = 0; i &lt;= totNodes; i++)G[i].clear(); way init; for (int i = 1; i &lt; totNodes; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;val); --fr; --to; init.val = val; init.to = to; G[fr].push_back(init); init.to = fr; G[to].push_back(init); inDegree[fr]++; inDegree[to]++; &#125; memset(vis, false, sizeof(vis)); dp(); memset(vis, false, sizeof(vis)); *f = *D; dfs(); int ans = INT_MIN; for (int i = 0; i &lt; totNodes; i++) ans = std::max(ans, f[i]); printf("%d\n", ans); &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树上动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】数字转换]]></title>
    <url>%2F2018%2F09%2F19%2F%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[题目大致意思是，如果一个数 $a$ 所有约数（不包括 $a$) 的和 $\sum a$ 小于 $a$ 那么 $\sum a$ 和 $a$ 这两个数之间就可以互相转换。现在给定一个范围 $n$ ，如果所有的数字变换都在不超过 $n$ 的范围内进行，求最多能够进行多少次没有重复数字出现的变换步数。 这题本质上是求一个树上的最长链。对于这类问题，我们可以递归地求解，对于每一个结点 $v$，假定 $d1_v$ 和 $d2_v$ 分别为以 $v$ 为起点的最长链和次长链，特别地，如果 $v$ 只有一个儿子，那么次长链是不存在的。然后，在所有的点中选出一个 $\max\{d1_i+d2_i\}$ ，即为答案。 在这题中，对于每一个数 $a$ ，假定它可以变换为 $T_a$, 那么显然如果存在 $T_a$ 那么 $T_a &lt; a$.这样，我们可以将 $T_a$ 作为父亲，$a$ 作为儿子，建树完成之后，答案也就出来了。但是，这里求一个数的约数之和也是需要相当的时间开销的，尤其是对于 $n\leq 50000$ 这种规模的数据。 解决的方法是使用父亲表示法存数，假设 $fa_i$ 为 $i$ 的父亲，那么 $fa_i = T_i$. 下面的代码可以在 $O(N)$ 时间复杂度内求出所有的 $fa_i$. 1234std::cin &gt;&gt; totNums;for (int i = 1; i &lt;= totNums; i++) for (int j = 2; i*j &lt;= totNums; j++) fa[i*j] += i; 虽然有两重循环，但是总的计算次数为 $\sum_{i=1}^{n} n\div i$ ，仍然是 $O(N)$. 然后，我们还可以知道一个比较大的数如果与一个较小的数存在关系，那么较大数一定是较小数的后代，这样，我们只用再将所有的数从大到小扫一遍，顺便更新 $d1,d2$,最后按照之前提到的方法计算出一个 $\max\{d1_i+d2_i\}$ 就可以了。 代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define MAXN 50050int main()&#123; int totNums, rank1[MAXN] = &#123;&#125;, rank2[MAXN] = &#123;&#125;, fa[MAXN] = &#123;&#125;; std::cin &gt;&gt; totNums; for (int i = 1; i &lt;= totNums; i++) for (int j = 2; i*j &lt;= totNums; j++) fa[i*j] += i; //Dp for (int i = totNums; i &gt; 0; i--) if (fa[i] &lt; i) &#123; if (rank1[fa[i]] &lt; rank1[i] + 1) &#123; //fa[i] 最长链短于 i 最长链加一 rank2[fa[i]] = rank1[fa[i]]; rank1[fa[i]] = rank1[i] + 1; &#125; else if (rank2[fa[i]] &lt; rank1[i] + 1) rank2[fa[i]] = rank1[i] + 1; &#125; int _max = INT_MIN; for (int i = 1; i &lt;= totNums; i++) _max = std::max(_max, rank1[i] + rank2[i]); std::cout &lt;&lt; _max &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树上动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P2016 战略游戏 - 有根树的点集划分问题 模板]]></title>
    <url>%2F2018%2F09%2F19%2F%E6%B4%9B%E8%B0%B7P2016-%E6%88%98%E7%95%A5%E6%B8%B8%E6%88%8F---%E6%9C%89%E6%A0%B9%E6%A0%91%E7%9A%84%E7%82%B9%E9%9B%86%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[这道题对应一个树上动规的经典问题。即在树上所有点中选择一部分作为一个集合，使得所有边的两个点中至少一个在这个集合中。 解决的方法非常简单，对于任何一个点，有选择和不选择两种方案，如果不选，它的所有儿子必选。如果选，它的所有儿子可选可不选。这样，我们使用两个数组 $get_i,\space set_i$ 分别代表以 $i$ 为根的子树，选择\不选择 $i$ 使得题意得到满足的最小集合大小。而最终的答案就是 $\min\{get_{root},\space set_{root}\}$. 这个算法每一次更新都是 $O(1)$ 的，总时间复杂度为 $O(N)$. C#代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Collections.Generic;namespace P2016&#123; class Program &#123; class G &#123; public static List&lt;int&gt;[] Gp; public static int[] get, set; public static bool[] root; &#125; static void Main(string[] args) &#123; string[] div; int totNodes &#x3D; Convert.ToInt32(Console.ReadLine()), nowAt, cnt, root &#x3D; 0; G.get &#x3D; new int[totNodes];G.set &#x3D; new int[totNodes]; G.Gp &#x3D; new List&lt;int&gt;[totNodes];G.root &#x3D; new bool[totNodes]; for (int i &#x3D; 0; i &lt; totNodes; i++) G.Gp[i] &#x3D; new List&lt;int&gt; &#123; &#125;; for(int i &#x3D; 0; i &lt; totNodes; i++) &#123; div &#x3D; Console.ReadLine().Split(&#39; &#39;); cnt &#x3D; Convert.ToInt32(div[1]);nowAt &#x3D; Convert.ToInt32(div[0]); for (int j &#x3D; 2; cnt &gt; 0; cnt--) &#123; G.Gp[nowAt].Add(Convert.ToInt32(div[j])); G.root[Convert.ToInt32(div[j++])] &#x3D; true; &#125; &#125; while (G.root[root]) root++; dfs(root); Console.WriteLine(Math.Min(G.set[root], G.get[root])); &#125; static void dfs(int nowAt) &#123; G.set[nowAt] &#x3D; 1;G.get[nowAt] &#x3D; 0; foreach (var it in G.Gp[nowAt]) &#123; dfs(it); G.set[nowAt] +&#x3D; Math.Min(G.set[it], G.get[it]); G.get[nowAt] +&#x3D; G.set[it]; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树上动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CTSC1997 选课]]></title>
    <url>%2F2018%2F09%2F18%2FCTSC1997-%E9%80%89%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[题目是给定 $n$ 个不同的课程，每一门课都有一定学分，当然有一些课需要预先学习了某一门课才可以学习，现在学习 $m$ 门课，问最大的总学分。 我们先对题目进行建模，记 $a \rightarrow b$ 代表学习 $b$ 需要先学习 $a$ ，那么就可以以没有任何先修课的课程为根，按照题意建立一棵树，对于树上任何一点，如果需要学习这门课程，必须学完它的所有祖先。需要注意的是，可能有非常多的课程都没有先修课，所以我们可以假定有一个结点 0 ，它没有任何先修课，但是原先没有先修课的课程需要先学习 0 号课程，换句话说，添加一个 0 号结点将森林转换为有根树，便于操作。当然，这个结点不计入总课程，也不能得到任何学分。 状态定义为 $D_{r,i}$ 代表以 $r$ 为根的子树中选择 $i$ 门课程能够获得的最多学分，这里假定 $r$ 是没有先修课的，答案就是 $D_{0,m}$. 过程还是使用搜索实现，假定当前结点为 $u$ 且 $u \rightarrow v$. 那么先递归地 dfs($v$)，然后转移方程是 D_{u,i} = \max\{D_{u,i},\space D_{u,i-j}+D_{v,j}\} \space \space (i \ge j)不要忘记，算完这一步之后得到的答案是错的，因为没有选择 $u$ 结点，解决的办法是将所有的 D_{u,i} = D_{u,i-1}+val_u$val_u$ 代表学习 $u$ 能够获得的学分，这样一来，无论之前的结果如何，结点 $u$ 最终都强制地被选择了，在任何情况下都满足题意。 整个算法时间复杂度为 $O(NM)$. C#代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using System;using System.Collections.Generic;using System.Collections;namespace LuoGu_2014&#123; class Program &#123; class G &#123; public static int totCho; public static int[,] D; &#x2F;&#x2F;以 u 为子树选择 k 门课程的最大学分 public static int[] val;&#x2F;&#x2F;一门课学习获得的学分 public static List&lt;int&gt;[] Gr; &#125; static void Main(string[] args) &#123; string[] div &#x3D; Console.ReadLine().Split(&#39; &#39;); int totLes &#x3D; Convert.ToInt32(div[0]) + 1;G.totCho &#x3D; Convert.ToInt32(div[1]); G.D &#x3D; new int[totLes, G.totCho + 1];G.val &#x3D; new int[totLes]; G.Gr &#x3D; new List&lt;int&gt;[totLes]; for (int i &#x3D; 0; i &lt; totLes; i++) G.Gr[i] &#x3D; new List&lt;int&gt; &#123; &#125;; for(int i &#x3D; 1; i &lt; totLes; i++) &#123; div &#x3D; Console.ReadLine().Split(&#39; &#39;); G.val[i] &#x3D; Convert.ToInt32(div[1]); G.Gr[Convert.ToInt32(div[0])].Add(i); &#125; G.val[0] &#x3D; 0; dfs(); Console.WriteLine(G.D[0, G.totCho]); &#125; static void dfs(int nowAt &#x3D; 0) &#123; G.D[nowAt, 0] &#x3D; 0; foreach(var it in G.Gr[nowAt]) &#123; dfs(it); for (int i &#x3D; G.totCho; i &gt; 0; i--) for (int j &#x3D; i; j &gt; 0; j--) G.D[nowAt, i] &#x3D; Math.Max( G.D[nowAt, i], G.D[nowAt, i - j] + G.D[it, j]); &#x2F;&#x2F;更新当前状态，j代表在 it 中选择 j 门课程 &#125; &#x2F;&#x2F;选择儿子课程的前提必须选择 nowAt if (nowAt !&#x3D; 0)&#x2F;&#x2F;0是虚拟节点，不占用课程量 for (int i &#x3D; G.totCho; i &gt; 0; i--) G.D[nowAt, i] &#x3D; G.D[nowAt, i - 1] + G.val[nowAt];&#x2F;&#x2F;强制选择 nowAt &#x2F;&#x2F;此后所有的 G.D[now,k] 都包含了 nowAt, 都是合法的 &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树上动态规划</tag>
        <tag>背包</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】二叉苹果树]]></title>
    <url>%2F2018%2F09%2F18%2F%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目在这里. 这题本质上并不难，但是有很多细节需要注意。 首先，数据的输入是一个无向图，我们事先并不知道输入的两个结点中谁是父亲结点。假设 $u \rightarrow v$ 代表 $u$ 是 $v$ 的直接父亲，那么我们在读入时先按照无向图保存，由于最终的根节点一定是1，所以在这里 dfs 一下就可以了，很容易就可以转换为有根树。其次，题目给定的是一条边上的苹果数量，最终保留 $m$ 条边。可以发现，最终留下了的边和结点正好组成了一棵树，因此，我们可以假设题目要求的是最终保留 $m+1$ 个不同的结点，而某一条边 $u \rightarrow v$ 上面的苹果数量，可以看成是结点 $v$ 上面的苹果数量，这两种定义是完全等价的，不会影响答案。 转换为有根树之后，我们就可以开始 DP 了，在递归的过程中，记 $R_i,\space L_i$ 分别为 $i$ 右左两个儿子，当前节点为 $r$，保留 $k$ 个结点. $D_{r,i}$ 代表以 $r$ 为根的子树保留 $i$ 个结点的最大苹果数量。递归函数的返回值就是 $D_{r,i}$ 的值。 如果 $i \leq 0$ ，返回 0. 如果 $R_r=L_r=0$ 说明当前节点是一个叶子节点，返回 $val_r$. 计算过的直接返回算得的值。 枚举一下 $j$ ，$D_{r,i} = \max\{D_{r,i},\space D_{Ri,j}+D_{Li,k-j-1}+val_r\}$. 返回 $D_r,i$. 在第四步中，去掉当前结点不看，我们还能够选择 $i-1$ 个结点，这些节点可以被分配给左右两个子树，所以我们枚举一下分配给左子树多少个，最后取一个最大的即可。 总时间复杂度为 $O(NM)$, 完整的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define MAXN 200int totNode, nodes;int D[MAXN][MAXN], L[MAXN], R[MAXN], val[MAXN];struct Edge &#123; int to, val;&#125;;bool vis[MAXN]; std::vector&lt;Edge&gt; G[MAXN];void ToTree(const int &amp;nowAt = 1) &#123; for (const auto &amp;it : G[nowAt]) if (!vis[it.to]) &#123; vis[it.to] = true; val[it.to] = it.val; if (L[nowAt] == 0) L[nowAt] = it.to; else R[nowAt] = it.to; ToTree(it.to); &#125;&#125;int Dp(const int &amp;nowAt = 1, const int &amp;links = nodes) &#123; if (links &lt;= 0)return 0; if ((L[nowAt] == 0) &amp;&amp; (R[nowAt] == 0))return val[nowAt]; //叶子节点 if (D[nowAt][links] &gt; 0)return D[nowAt][links]; //计算过的 for (int i = 0; i &lt; links; i++) D[nowAt][links] = std::max(D[nowAt][links], Dp(L[nowAt], i) + Dp(R[nowAt], links - i - 1) + val[nowAt]); return D[nowAt][links];&#125;int main()&#123; memset(D, -1, sizeof(D)); memset(vis, false, sizeof(vis)); vis[1] = true; std::cin &gt;&gt; totNode &gt;&gt; nodes; ++nodes; int fr, to, val; for (int i = 1; i &lt; totNode; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;val); G[fr].push_back(&#123; to,val &#125;); G[to].push_back(&#123; fr,val &#125;); &#125;ToTree(); std::cout &lt;&lt; Dp() &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树上动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P1273 有线电视网]]></title>
    <url>%2F2018%2F09%2F17%2FP1273-%E6%9C%89%E7%BA%BF%E7%94%B5%E8%A7%86%E7%BD%91%2F</url>
    <content type="text"><![CDATA[树上背包动态规划入门祭。题目链接. 在这一题中，使用背包的思想在树上递归地处理。假设 $D_{r,i,k}$ 为以 $r$ 为根的子树在只考虑它前 $i$ 个儿子的情况下提供给 $k$ 个用户所能够获得的 最大利润 ,注意这个值可能是一个负数，代表亏本。我们在递归地处理完所有的结点之后，选取一个在根结点处不亏本的 $k$ 的值，即找到一个最大的 $k$ 使得 $D_{root,\sum chilld,k} \ge 0$ ，此时的 $k$ 即为所求答案。 事实上，这里的 $i$ 可以用滚动数组去掉。递归的过程用 dfs 实现，步骤如下： 如果当前结点 $u​$ 是叶子节点， $D_{u,1} = 1​$ ，返回1. 递归处理一个儿子节点 $v$ 更新一下 $D_{u,i} = \max\{D_{u,i},D_{u,i-j} - val_{u \rightarrow v} + D_{v,j}\}$ 这里 $i\ge j$. 返回以 $u$ 为根节点的子树包含的叶子节点数量。 dfs 的返回值 $f$ 可以帮助我们少计算一些不必要的信息，例如当 $f_r = 3$ ,即这下面有3个叶子节点，而我们却去算 $D_{r,100}$ ，这很明显只会浪费掉大量的计算能力。 dfs 代码如下： 123456789101112131415161718int dfs(const int &amp;nowAt = 0)&#123; D[nowAt][0] = 0; if (nowAt &gt;= totNode - totLf) &#123; //叶子结点 D[nowAt][1] = val[nowAt]; return 1; &#125; int child = 0, res; for (const auto &amp;it : G[nowAt]) &#123; res = dfs(it.to); for (int i = 0; i &lt;= child; i++)T[i] = D[nowAt][i]; for (int i = 0; i &lt;= child; i++) for (int j = 0; j &lt;= res; j++) D[nowAt][i + j] = std::max(D[nowAt][i + j], T[i] - it.val + D[it.to][j]); child += res; &#125; return child;&#125; 这里有一行 1for (int i = 0; i &lt;= child; i++)T[i] = D[nowAt][i]; 它将 $D_u$ 拷贝到了一个临时数组 $T$ 中，原因是后面我们需要使用到一个比较小的 $i$ 去更新一个较大的 $i$,从而造成覆盖掉存储的值引发错误。另外的一种解决办法是 不完全地滚动其中的一维 ，加一维 0/1 代表现在和过去的值，那么上述这一行就可以直接简写成： 1std::swap(now, last); 不过，这么做远远没有上面的做法直观。 对于时间复杂度，我们将整棵树搜索一遍就是 $O(N)$, 不仅如此，我们还有可能多达 $n$ 个的叶子节点，而上述 dfs 过程中计算了他们，总的时间复杂度理论上为 $O(N^2)$. 但是，可以看到我们使用 dfs 的返回值作为信息，减少了非常多的多余计算，实际的效果将会远远低于这个理论值。 完整的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define MAXN 3050struct Edge &#123; int to, val;&#125;;std::vector&lt;Edge&gt; G[MAXN];int totNode, totLf;int D[MAXN][MAXN], val[MAXN], T[MAXN];bool vis[MAXN];int dfs(const int &amp;nowAt = 0)&#123; D[nowAt][0] = 0; if (nowAt &gt;= totNode - totLf) &#123; //叶子结点 D[nowAt][1] = val[nowAt]; return 1; &#125; int child = 0, res; for (const auto &amp;it : G[nowAt]) &#123; res = dfs(it.to); for (int i = 0; i &lt;= child; i++)T[i] = D[nowAt][i]; for (int i = 0; i &lt;= child; i++) for (int j = 0; j &lt;= res; j++) D[nowAt][i + j] = std::max(D[nowAt][i + j], T[i] - it.val + D[it.to][j]); child += res; &#125; return child;&#125;int main()&#123; memset(D, -0x7f, sizeof(D)); memset(vis, false, sizeof(vis)); scanf("%d%d", &amp;totNode, &amp;totLf); int cnt, to, val, tot = 0; for (int i = 0; i &lt; totNode - totLf; i++) &#123; scanf("%d", &amp;cnt); while(cnt--) &#123; scanf("%d%d", &amp;to, &amp;val); G[i].push_back(&#123; to - 1,val &#125;); &#125; &#125; for (int i = totNode - totLf; i &lt; totNode; i++) &#123; scanf("%d", ::val + i); tot += ::val[i]; &#125; dfs(); for (int i = totLf; i &gt;= 0; i--)if (D[0][i] &gt;= 0) &#123; printf("%d\n", i); break; &#125; //system("pause"); return 0; &#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树上动态规划</tag>
        <tag>背包</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】POJ-3349 Snowflake Snow Snowflakes]]></title>
    <url>%2F2018%2F09%2F16%2FPOJ-3349-Snowflake-Snow-Snowflakes%2F</url>
    <content type="text"><![CDATA[哈希模板题，使用除留余数法构造哈希函数，套用模板就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;malloc.h&gt;struct Snow &#123; int len[6]; unsigned int Hash() &#123; int x = 0; for (int i = 0; i &lt; 6; i++)x = (x + len[i]) % 100007; return x; &#125; bool operator == (const Snow &amp;comp)const &#123; for (int i = 0; i &lt; 6; i++)if (len[i] != comp.len[i])return false; return true; &#125;&#125;;#define nullptr NULLtemplate&lt;typename T, size_t arraySize = 100007&gt;class HashTable &#123;protected:#define comp(a,b) a-&gt;val==b#define HASHNUM arraySizeprivate: struct Node &#123; T val; Node* next; &#125;*arr[HASHNUM]; Node* newNode() &#123; Node* creat = (Node*)malloc(sizeof(Node)); creat-&gt;next = nullptr; return creat; &#125;public: void clear() &#123; for (int i = 0; i &lt; HASHNUM; i++)arr[i] = nullptr; &#125; void Insert(Snow &amp;it) &#123; int hashCode = it.Hash(); if (arr[hashCode] == nullptr) &#123; arr[hashCode] = newNode(); arr[hashCode]-&gt;val = it; return; &#125;Node *nowAt = arr[hashCode]; while (nowAt-&gt;next != nullptr)nowAt = nowAt-&gt;next; nowAt-&gt;next = newNode(); nowAt-&gt;next-&gt;val = it; &#125; bool Count(Snow &amp;it) &#123; int hashCode = it.Hash(); Node *nowAt = arr[hashCode]; while (nowAt != nullptr) &#123; if (nowAt-&gt;val == it)return true; else nowAt = nowAt-&gt;next; &#125; return false; &#125; const size_t Max_Size() &#123; return HASHNUM; &#125;&#125;;HashTable&lt;Snow&gt; S;int main()&#123; int num; Snow init; scanf("%d", &amp;num); while (num--) &#123; for (int i = 0; i &lt; 6; i++)scanf("%d", init.len + i); std::sort(init.len, init.len + 6); if (!S.Count(init))S.Insert(init); else &#123; std::cout &lt;&lt; "Twin snowflakes found." &lt;&lt; std::endl; goto End; &#125; &#125; std::cout &lt;&lt; "No two snowflakes are alike." &lt;&lt; std::endl;End: //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表API]]></title>
    <url>%2F2018%2F09%2F16%2F%E5%93%88%E5%B8%8C%E8%A1%A8API%2F</url>
    <content type="text"><![CDATA[需要在自己的结构体中重载等于运算符并写哈希函数: unsigned int Hash()。 123456789101112131415161718192021222324252627282930313233343536373839template&lt;typename T, size_t arraySize = 100007&gt;class HashTable &#123;protected:#define comp(a,b) a-&gt;val==b#define HASHNUM arraySizeprivate: struct Node &#123; T val; Node* next; &#125;*arr[HASHNUM]; Node* newNode() &#123; Node* creat = (Node*)malloc(sizeof(Node)); creat-&gt;next = nullptr; return creat; &#125;public: void clear() &#123; for (int i = 0; i &lt; HASHNUM; i++)arr[i] = nullptr; &#125; void Insert(Snow &amp;it) &#123; int hashCode = it.Hash(); if (arr[hashCode] == nullptr) &#123; arr[hashCode] = newNode(); arr[hashCode]-&gt;val = it; return; &#125;Node *nowAt = arr[hashCode]; while (nowAt-&gt;next != nullptr)nowAt = nowAt-&gt;next; nowAt-&gt;next = newNode(); nowAt-&gt;next-&gt;val = it; &#125; bool Count(Snow &amp;it) &#123; int hashCode = it.Hash(); Node *nowAt = arr[hashCode]; while (nowAt != nullptr) &#123; if (nowAt-&gt;val == it)return true; else nowAt = nowAt-&gt;next; &#125; return false; &#125; const size_t Max_Size() &#123; return HASHNUM; &#125;&#125;;HashTable&lt;STRUCT&gt; S;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[USACO08DEC] Trick or Treat on the Farm]]></title>
    <url>%2F2018%2F09%2F14%2F%5BUSACO08DEC%5D-Trick-or-Treat-on-the-Farm%2F</url>
    <content type="text"><![CDATA[题目大致是说，有 $n$ 头牛一开始在自己编号为 $i$ 的牛棚中，它接下来会去往一个特定的牛棚 $next_{nowAt}$ ,每个牛棚中都有一颗糖果，问每一头牛分别可以收集到多少糖果？ 这题很容易想到直接深搜，用一个 bool 数组判重，最后第一次遇到一个已经到达过了的牛棚就立刻停止，统计一下这一路上过来收集到的总糖果数 $num_i$ ，即为答案。这么做的时间复杂度是 $O(N^2)$. 事实上我们可以做得更好，可以发现，对于每一个特定的 $num_i$ ，它的值都是确定的。我们想想牛走过的牛棚的情况，由于最终一定会碰到一个之前已经经过了的牛棚，所以不难想象出它的行进轨迹是先是链状然后进入环，我们可以在每次 dfs 时将环找出，那么从这一路上经过的所有牛棚出发对应的 $num$ 值我们也就都知道了，节约了大量不必要的计算。 代码如下，在 dfs 过程中，每一个点只考虑了一次；判环时，环上每一个点只访问了一次。所以总时间复杂度为 $O(N)$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define MAXN 100050int next[MAXN], step[MAXN], vis[MAXN];bool inCycle[MAXN];void Select(int nowAt) &#123; int cnt = 0, now = nowAt; do &#123; now = next[now]; cnt++; &#125; while (now != nowAt); while (!inCycle[nowAt]) &#123; inCycle[nowAt] = true; step[nowAt] = cnt; nowAt = next[nowAt]; &#125;&#125;void dfs(const int &amp;nowAt, const int &amp;dfs_Clock) &#123; if (vis[nowAt] != -1) &#123; if (vis[nowAt] == dfs_Clock) //发现新环 Select(nowAt); return; &#125; vis[nowAt] = dfs_Clock; dfs(next[nowAt], dfs_Clock); if (!inCycle[nowAt]) step[nowAt] = step[next[nowAt]] + 1;&#125;int main()&#123; memset(inCycle, false, sizeof(inCycle)); memset(vis, -1, sizeof(vis)); int totCow; scanf("%d", &amp;totCow); for (int i = 0; i &lt; totCow; i++) &#123; scanf("%d", next + i); --next[i]; &#125; for (int i = 0; i &lt; totCow; i++) dfs(i, i); //putchar('\n'); for (int i = 0; i &lt; totCow; i++)printf("%d\n", step[i]); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>搜索</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P2756 飞行员配对方案问题]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%B4%9B%E8%B0%B7P2756-%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[很明显的二分图最大匹配。 先将数据读入进来，英国飞行员作为左边的结点，战败国飞行员作为右边的结点，然后在他们之间连边。 跑一边二分图最大匹配，得出最佳方案的数量。 这时我们已经处理出来了一个数组，代表当前飞行员与谁进行了配对，将这个数组处理一下输出出来就可以了，注意不要重复。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define MAXN 150std::vector&lt;int&gt; G[MAXN];bool vis[MAXN];int match[MAXN];bool dfs(const int &amp;nowAt) &#123; for (const auto &amp;it : G[nowAt]) if (!vis[it]) &#123; vis[it] = true; if (match[it] == -1 || dfs(match[it])) &#123; match[nowAt] = it; match[it] = nowAt; return true; &#125; &#125; return false;&#125;int main()&#123; int tot, Vanquished, fr, to, _count = 0; scanf("%d%d", &amp;Vanquished, &amp;tot); while(true)&#123; scanf("%d%d", &amp;fr, &amp;to); if (fr == -1 &amp;&amp; to == -1)break; G[fr].push_back(to); G[to].push_back(fr); &#125; memset(match, -1, sizeof(match)); for (int i = 1; i &lt;= Vanquished; i++) &#123; memset(::vis, false, sizeof(::vis)); if (dfs(i))_count++; &#125; if (_count == 0) &#123; puts("No Solution!"); return 0; &#125; printf("%d\n", _count); bool vis[MAXN]; memset(vis, false, sizeof(vis)); for (int i = 0; i &lt;= tot; i++) if (match[i] != -1 &amp;&amp; (!vis[i])) &#123; vis[i] = true; vis[match[i]] = true; printf("%d %d\n", i, match[i]); &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dinic 模板]]></title>
    <url>%2F2018%2F09%2F10%2FDinic-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[Dinic 算法可以用来解决网络最大流问题。 对于这个问题，很容易想到一种方法，就是不断地找从源点 $s$ 到汇点 $t$ 的路径，取其中最小剩余流量的边然后将路径上所有的边的剩余流量减去这个 $\Delta f$ ，总流量加上 $\Delta f$. 但是，这么做是错的，很容易就可以找到反例，而对策是对于每一条边建立一条 反向边 ，我们称两条边互为反向边，如果一条边上的剩余流量减去的 $\Delta f$, 那么它的反向边的流量就要加上 $\Delta f$. 这么做保证了正确性，因为反向边为我们提供了一个反悔的机会。 但是，这么做很容易被卡。使用 Dinic 算法为图建立一个层次图，这样保证每一条边的选择都带我们离汇点更进一步，这样不断增广，不断刷新层次，在正确性得以保证的前提下，时间效率也非常不错。 代码如下，对应题目洛谷P3376. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define MAXN 10050struct Edge &#123; int fr, to; int cap; //流量上限 int flow; //当前流量&#125;;std::vector&lt;Edge&gt; edges;std::vector&lt;int&gt; G[MAXN];bool vis[MAXN];int dis[MAXN], cur[MAXN];//层-上次考虑的边int totNode, totEdge, s, t;//点的个数、有向边的个数、源点序号、汇点序号bool Bfs() &#123; //构造层次图 memset(vis, false, sizeof(vis)); std::queue&lt;int&gt; que; que.push(s); vis[s] = true; dis[s] = 0; int nowAt; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); for (const auto &amp;it : G[nowAt]) if (!vis[edges[it].to] &amp;&amp; edges[it].cap &gt; edges[it].flow) &#123; vis[edges[it].to] = true; dis[edges[it].to] = dis[nowAt] + 1; que.push(edges[it].to); &#125; &#125; return vis[t]; //能否有流量到达t点&#125;int dfs(int nowAt, int maxFlow) &#123; if (nowAt == t || maxFlow &lt;= 0)return maxFlow; int flow = 0, deltaFlow; //在此产生的流量总和-单次的流量 for (int &amp;i = cur[nowAt]; i &lt; G[nowAt].size(); i++) &#123; /* 从上次考虑的边开始，因为前面的边已经考虑过了。 * 引用可以方便写代码的同时修改cur的相应值 */ auto&amp; it = edges[G[nowAt][i]]; if (dis[it.to] == dis[nowAt] + 1 &amp;&amp; 0 &lt; (deltaFlow = dfs(it.to, std::min(maxFlow, it.cap - it.flow)))) &#123; it.flow += deltaFlow; edges[G[nowAt][i] ^ 1].flow -= deltaFlow; maxFlow -= deltaFlow; flow += deltaFlow; if (maxFlow &lt;= 0)break; &#125; &#125; return flow;&#125;int main()&#123; scanf("%d%d%d%d", &amp;totNode, &amp;totEdge, &amp;s, &amp;t); int fr, to, cap, cnt = 0; for (int i = 0; i &lt; totEdge; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;cap); edges.push_back(&#123; fr,to,cap,0 &#125;); edges.push_back(&#123; to,fr,0,0 &#125;); //边与方向边 G[fr].push_back(edges.size() - 2); G[to].push_back(edges.size() - 1); //邻接表中保存边的编号 &#125; while (Bfs()) &#123; memset(cur, 0, sizeof(cur)); cnt += dfs(s, INT_MAX); &#125; std::cout &lt;&lt; cnt &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】联合权值]]></title>
    <url>%2F2018%2F09%2F07%2FP1351%E8%81%94%E5%90%88%E6%9D%83%E5%80%BC%2F</url>
    <content type="text"><![CDATA[这道题目在我的做题计划中放置了接近8个月，其实现在看来也没有多难。 题目告诉我们，输入的无向图其实是一棵树，距离为2的所有有序点对都会产生一个联合权值等于他们权值之积。我们需要求出联合权值的总和和最大值。 可以发现有一种情况是比较好想的，就是对于一个结点可以与他的爷爷产生联合权值，在 dfs 的时候多保存一个爷爷结点的信息即可。还剩下一种情况就是对于一个结点它的儿子们互相之间可以产生联合权值，朴素地累加会超时，对于不同的问题有不同的方法。 先看最大值，在当前节点与爷爷之间产生一个最大的联合权值，然后儿子之间取出两个权值最大的更新一下。前提是当前节点有至少两个儿子。 然后是总和，当前节点与爷爷之间可以互相产生联合权值，所以算的时候要乘上2.然后我们可以根据乘法的结合律快速地求出儿子之间的联合权值，只用先将所有的儿子权值累加，然后对于每一个儿子，它能够产生的联合权值就是它本身的权值乘上累加和减去它本身的权值之差，这样我们就将这一步从指数级别的复杂度降低到了线性级别。 具体细节见代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Collections;namespace LuoGu_P1531&#123; class Program &#123; public class Global &#123; public static List&lt;int&gt;[] G; public static bool[] vis; public static Int64 cnt, max; public static int[] val; &#125; static void Main(string[] args) &#123; string[] div; int totNodes &#x3D; Convert.ToInt32(Console.ReadLine()), fr, to; Global.vis &#x3D; new bool[totNodes]; Global.G &#x3D; new List&lt;int&gt;[totNodes];Global.val &#x3D; new int[totNodes]; for(int i &#x3D; 0;i &lt; totNodes;i++) Global.G[i] &#x3D; new List&lt;int&gt; &#123; &#125;; for(int i &#x3D; 1;i &lt; totNodes;i++) &#123; div &#x3D; Console.ReadLine().Split(&#39; &#39;); fr &#x3D; Convert.ToInt32(div[0]) - 1;to &#x3D; Convert.ToInt32(div[1]) - 1; Global.G[fr].Add(to);Global.G[to].Add(fr); &#125; div &#x3D; Console.ReadLine().Split(&#39; &#39;); for(int i &#x3D; 0;i &lt; totNodes;i++) Global.val[i] &#x3D; Convert.ToInt32(div[i]); for(int i &#x3D; 0;i &lt; totNodes;i++) if(!Global.vis[i]) dfs(i, -1, -1); Console.WriteLine(Global.max.ToString() + &quot; &quot; + Global.cnt.ToString()); &#125; static void dfs(int nowAt, int fa, int gFa) &#123; Global.vis[nowAt] &#x3D; true; if(gFa !&#x3D; -1) &#123; Global.cnt +&#x3D; (Global.val[nowAt] * Global.val[gFa]) &lt;&lt; 1; Global.max &#x3D; Math.Max(Global.max, Global.val[nowAt] * Global.val[gFa]); Global.cnt %&#x3D; 10007; &#125; Int64 rank1 &#x3D; -1, rank2 &#x3D; -1, tot &#x3D; 0; foreach(var it in Global.G[nowAt]) &#123; if(Global.vis[it]) continue; if(Global.val[it] &gt;&#x3D; rank1) &#123; rank2 &#x3D; rank1; rank1 &#x3D; Global.val[it]; &#125; else if(Global.val[it] &gt; rank2) rank2 &#x3D; Global.val[it]; tot +&#x3D; Global.val[it]; &#125; if(rank2 !&#x3D; -1) Global.max &#x3D; Math.Max(Global.max, rank1 * rank2); foreach(var it in Global.G[nowAt]) if(!Global.vis[it]) Global.cnt &#x3D; (Global.cnt + (tot - Global.val[it]) * Global.val[it]) % 10007; foreach(var it in Global.G[nowAt]) if(!Global.vis[it]) dfs(it, nowAt, fa); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树上动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图最大匹配 模板]]></title>
    <url>%2F2018%2F09%2F07%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[对于一张二分图，选出尽量多的边，使得任意两条选中的边均没有公共点。 代码对应题目：洛谷P3386. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define MAXN 3000std::vector&lt;int&gt; G[MAXN]; //存图bool vis[MAXN]; //当前搜索访问点int match[MAXN]; //匹配对象bool dfs(const int &amp;nowAt) &#123;//能否寻找到一条增广路 for (const auto &amp;it : G[nowAt]) if (!vis[it]) &#123; vis[it] = true; if (match[it] == -1 || dfs(match[it])) &#123; //没有匹配对象或者可以从这里找到增广路 match[it] = nowAt; match[nowAt] = it; return true; &#125; &#125; return false;&#125;int main()&#123; memset(match, -1, sizeof(match)); int sizX, sizY, totEdge, fr ,to, cnt = 0, siz; scanf("%d%d%d", &amp;sizX, &amp;sizY, &amp;totEdge); siz = sizX + sizY; for (int i = 0; i &lt; totEdge; i++) &#123; scanf("%d%d", &amp;fr, &amp;to); --fr; to += sizX - 1; if (fr &lt; sizX&amp;&amp;to &gt;= sizX &amp;&amp; to &lt; siz) &#123;//将合法的数据添加到图G中 G[fr].push_back(to); G[to].push_back(fr); &#125; &#125; for (int i = 0; i &lt; sizX; i++) &#123; memset(vis, false, sizeof(vis)); if (dfs(i))cnt++; &#125; std::cout &lt;&lt; cnt &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】[HNOI2003]操作系统]]></title>
    <url>%2F2018%2F09%2F06%2FHNOI2003-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[这题思路不难，就是用一个优先队列模拟一下即可。 在这个优先队列中，按照优先级作为第一关键字，到达时间作为第二关键字排序。实现时先定义一个变量 当前时间 ，一开始可以为 0.随后每一次读入读 下一个任务 ，这时就会出现一段空余时间，含义是从上一个任务进入队列开始到下一个任务到达，这一段时间我们的 CPU 按照既定的顺序处理任务。我们可以知道，当前任务在没有执行完之前如果没有另外一个新的任务的加入，那么它是不会因为某种原因停止的，所以这一段时间我们直接拿出堆顶的任务，执行，再重复这个操作直到堆为空或者时间结束。 假定时间结束了堆还不是空的，直接将当前处理的任务和新的任务一起扔到堆中，再循环操作即可。因为虽然有的情况是当前任务不会被新任务打断，但是我们也可以假定它就是被打断了，只不过接下来处理的仍然是它而已。这相当于没有打断，但是在实现上会容易一些。 读完了所有任务，直接将堆中剩余的任务一个接着一个地处理完即可。 每一次操作堆的时间复杂度为 $O(\log N)$ ，每一个新任务最多打断一个正在执行的任务，然后进堆出堆一次，总的时间复杂度为 $O(N \log N)$. 注意这里常数可能有点大，因为 $O(\log N)$ 的操作严格意义上有 $O(3\times N)$ 次。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;struct Mission &#123; int ID, arriveTime, time, pr; bool operator &lt; (const Mission comp)const &#123; return comp.pr == this-&gt;pr ? comp.arriveTime &lt; this-&gt;arriveTime : comp.pr &gt; this-&gt;pr; &#125;&#125;;std::priority_queue&lt;Mission&gt; que;int main()&#123; Mission working; int id, arr, time, pro, nowTime = 0, timeExt; while (scanf("%d%d%d%d", &amp;id, &amp;arr, &amp;time, &amp;pro) == 4) &#123; timeExt = arr - nowTime; while (!que.empty() &amp;&amp; timeExt &gt; 0) &#123; working = que.top(); que.pop(); if (timeExt &gt;= working.time) &#123; timeExt -= working.time; printf("%d %d\n", working.ID, arr - timeExt); continue; &#125; else &#123; working.time -= timeExt; que.push(working); timeExt = 0; &#125; &#125; que.push(&#123; id,arr,time,pro &#125;); nowTime = arr; &#125; nowTime = arr; //最后一个进程到达的时间是现在的时间 while (!que.empty()) &#123; working = que.top(); que.pop(); nowTime += working.time; printf("%d %d\n", working.ID, nowTime); &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EternalAlexander的题目]]></title>
    <url>%2F2018%2F09%2F06%2FEternalAlexander%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[EternalAlexander 最近给我推荐了一些好题。这不代表题目是他原创的。 数列问题题目链接：添柴ID12331. 描述详情有一个数列a[1…n]，Zeratul要对这个数列做两种操作： 1 L R：代表将子串a[L…R]从小到大排序。 2 L R：代表将子串a[L…R]从大到小排序。在若干次这样的操作之后，Zeratul要你输出a[k]的值。 输入格式第一行包括两个整数n，m，代表数列的长度和查询的次数。第二行包括n个整数a[1…n]，代表这个数列。接下来m行，每行三个整数，代表一次操作。最后一行包括一个整数k，代表查询a[k]的值。 输出格式输出一个整数，a[k]的值。 限制 对于20%的数据，$n,m\leq100 $ 对于另外20%的数据，$a[i]\leq2 $ 对于60%的数据，$n,m \leq 20000 $ 对于100%的数据，$n,m \leq 100000，1 \leq a[i] \leq 100000，1 \leq L \leq R \leq n $. 样例输入5 25 4 3 2 11 1 52 2 44 输出2 思路这是一道非常有意思的题目，可以看到数据范围非常的大，普通的模拟是肯定不行的，我们必须往贪心、动态规划这些方面去思考，但是这么做之后还是让人毫无头绪。 注意到最后我们只要求求出某一个位置上面的数值，也就是说其它的位置对我们来说是无关紧要的，如果我们能够想出来某一种方法，使得我们随便给出一个数 $k$ ,可以判断它是比所求数大还是小，不是就可以二分答案了吗？ 既然我们都算出来要求的数了，为什么还要去比较大小什么的，直接输出不就完了？事实上，我没有想出来能够在规定时间内求出这个数的方法，但是我们却可以在很短的时间内得出它与 $k$ 的大小关系，这个方法有点难想，但是却并不难。 实践将原来的数组变为一个0-1序列 $b$，如果 $a_i &lt; k$ 则 $b_i = 0$ 否则为1. 使用 $b$ 数组建立线段树，线段树需要支持以下几个操作： 查询区间和 将区间内的数全部修改为特定值 然后一个个地处理每一次操作，看看 $[L,R]$ 中间有几个1，记这个数值为 $n_0$ ，然后根据不同的排序方式进行一下修改操作： 如果是从小到大排序，修改 $[L,R-n_0-1]$ 为0，修改 $[L+n_0,R]$ 为1. 反之，修改 $[L,L+n_0]$ 为1，修改 $[L+n_0+1,R]$ 为0. 最后，如果位于 $b_{询问位置}$ 的数为0，说明 $k$ 大了，如果是1，说明 $k$ 小了或者正好等于。 这样，我们在如果操作个数是 $Q$ 次，那么我们在 $O(Q\log N)$ 的时间复杂度内计算出了大小关系。总的时间复杂度为 $O(Q \log N \log \max \{N\})$. 需要特别注意的是，我们在写线段树的时候会有两个标签，分别代表这段区间有没有被全部赋为1或者0，在我们向下移动标记的时候需要覆盖掉下面区间的一切标签。例如，当前区间有一个全部为0的标记，它的左儿子可能就有一个全部为1的标记，这个时候向下移动标记就要将这个全部为1去掉，不然就会出现很多难以调试的错误。 题目略显毒瘤，但是对于练习思维和线段树非常有帮助。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;bits/stdc++.h&gt;#define MAXN 100050int origSeq[MAXN], L[MAXN], R[MAXN], pos; bool cgT[MAXN];int totNums, totCg;//线段树struct Node &#123; int fr, to, trs; bool markTrue, markFalse, mark; Node *lft, *rgt;&#125;*root = nullptr;Node* NewNode() &#123; Node* creat = (Node*)malloc(sizeof(Node)); creat-&gt;lft = creat-&gt;rgt = nullptr; creat-&gt;trs = 0; creat-&gt;mark = creat-&gt;markFalse = creat-&gt;markTrue = false; return creat;&#125;void freeNode(Node* targ) &#123; if (targ-&gt;lft != nullptr)freeNode(targ-&gt;lft); if (targ-&gt;rgt != nullptr)freeNode(targ-&gt;rgt); std::free(targ);&#125;void PushDown(Node* targ) &#123; if (targ-&gt;markTrue) &#123; if (targ-&gt;lft != nullptr) &#123; targ-&gt;lft-&gt;mark = true; targ-&gt;lft-&gt;markTrue = true; targ-&gt;lft-&gt;markFalse = false; targ-&gt;lft-&gt;trs = targ-&gt;lft-&gt;to - targ-&gt;lft-&gt;fr + 1; &#125; if (targ-&gt;rgt != nullptr) &#123; targ-&gt;rgt-&gt;mark = true; targ-&gt;rgt-&gt;markTrue = true; targ-&gt;rgt-&gt;markFalse = false; targ-&gt;rgt-&gt;trs = targ-&gt;rgt-&gt;to - targ-&gt;rgt-&gt;fr + 1; &#125; &#125; if (targ-&gt;markFalse) &#123; if (targ-&gt;lft != nullptr) &#123; targ-&gt;lft-&gt;mark = true; targ-&gt;lft-&gt;markFalse = true; targ-&gt;lft-&gt;markTrue = false; targ-&gt;lft-&gt;trs = 0; &#125; if (targ-&gt;rgt != nullptr) &#123; targ-&gt;rgt-&gt;mark = true; targ-&gt;rgt-&gt;markFalse = true; targ-&gt;lft-&gt;markTrue = false; targ-&gt;rgt-&gt;trs = 0; &#125; &#125; targ-&gt;mark = targ-&gt;markTrue = targ-&gt;markFalse = false;&#125;void fresh(Node* targ) &#123; targ-&gt;trs = 0; if (targ-&gt;lft != nullptr)targ-&gt;trs += targ-&gt;lft-&gt;trs; if (targ-&gt;rgt != nullptr)targ-&gt;trs += targ-&gt;rgt-&gt;trs;&#125;void Build(const size_t &amp;siz, const int &amp;comp) &#123; Node *a, *b, *ext; std::queue&lt;Node*&gt; que, add; //Render for (int i = 0; i &lt; siz; i++) &#123; ext = NewNode(); ext-&gt;fr = ext-&gt;to = i; ext-&gt;trs = comp &gt; origSeq[i] ? 0 : 1; que.push(ext); &#125; while (que.size() &gt; 1) &#123; while (que.size() &gt; 1) &#123; a = que.front(); que.pop(); b = que.front(); que.pop(); ext = NewNode(); ext-&gt;fr = a-&gt;fr; ext-&gt;to = b-&gt;to; ext-&gt;lft = a; ext-&gt;rgt = b; ext-&gt;trs = a-&gt;trs + b-&gt;trs; add.push(ext); &#125; if (!que.empty()) &#123; add.push(que.front()); que.pop(); &#125; std::swap(que, add); &#125; root = que.front();&#125;int Count(const int &amp;fr, const int &amp;to, Node* nowAt = root) &#123; if (nowAt == nullptr)return 0; if (nowAt-&gt;fr &gt; to || nowAt-&gt;to &lt; fr)return 0; if (nowAt-&gt;mark)PushDown(nowAt); if (nowAt-&gt;fr &gt;= fr &amp;&amp; nowAt-&gt;to &lt;= to)return nowAt-&gt;trs; else return Count(fr, to, nowAt-&gt;lft) + Count(fr, to, nowAt-&gt;rgt);&#125;void SetSeq(const int &amp;fr, const int &amp;to, const bool &amp;val, Node* nowAt = root) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;fr &gt; to || nowAt-&gt;to &lt; fr)return; if (nowAt-&gt;mark)PushDown(nowAt); if (nowAt-&gt;fr &gt;= fr &amp;&amp; nowAt-&gt;to &lt;= to) &#123; nowAt-&gt;mark = true; if (val == true) &#123; nowAt-&gt;markTrue = true; nowAt-&gt;markFalse = false; nowAt-&gt;trs = nowAt-&gt;to - nowAt-&gt;fr + 1; &#125; else &#123; nowAt-&gt;markFalse = true; nowAt-&gt;markTrue = false; nowAt-&gt;trs = 0; &#125; &#125; else &#123; SetSeq(fr, to, val, nowAt-&gt;lft); SetSeq(fr, to, val, nowAt-&gt;rgt); fresh(nowAt); &#125;&#125;bool Query(const int &amp;k, Node* nowAt = root) &#123; if (nowAt-&gt;mark)PushDown(nowAt); if (nowAt-&gt;fr == nowAt-&gt;to&amp;&amp;nowAt-&gt;fr == k)return nowAt-&gt;trs == 1 ? true : false; if (nowAt-&gt;lft == nullptr || nowAt-&gt;rgt == nullptr) return Query(k, nowAt-&gt;lft == nullptr ? nowAt-&gt;rgt : nowAt-&gt;lft); else return Query(k, nowAt-&gt;lft-&gt;to &gt;= k ? nowAt-&gt;lft : nowAt-&gt;rgt);&#125;//------------------//二分检查bool Solve(int numTry) &#123; Build(totNums, numTry); int cnt1; for (int i = 0; i &lt; totCg; i++) &#123; cnt1 = Count(L[i], R[i]); if (cgT[i] == true) &#123; SetSeq(L[i], L[i] + cnt1 - 1, true); SetSeq(L[i] + cnt1, R[i], false); &#125; else &#123; SetSeq(L[i], R[i] - cnt1, false) SetSeq(R[i] - cnt1 + 1, R[i], true); &#125; &#125; bool ans = Query(pos); freeNode(root); root = nullptr; return ans;&#125;int main()&#123; int fr = 1, to = INT_MIN, mid, cgTo; //read scanf("%d%d", &amp;totNums, &amp;totCg); for (int i = 0; i &lt; totNums; i++) &#123; scanf("%d", origSeq + i); to = std::max(to, origSeq[i]); &#125; for (int i = 0; i &lt; totCg; i++) &#123; scanf("%d%d%d", &amp;cgTo, L + i, R + i); L[i]--; R[i]--; cgT[i] = cgTo == 1 ? false : true; &#125; scanf("%d", &amp;pos); pos--; while (fr &lt; to) &#123; mid = (fr + to) &gt;&gt; 1; if (Solve(++mid)) fr = mid; else to = mid - 1; &#125; printf("%d\n", fr); //system("pause"); return 0;&#125; 也是调了好几个小时才AC. 区间和尚未发现包含这道题目的OJ. 描述详情有一个数组包含 $n$ 个数，$a_0, a_1 \cdots \cdots a_{n-1}$ ,求这个数列所有元素之和为负数的子序列。 输入格式一行一个数 $n$. 一行 $n$ 个数 $a_i$. 输出格式一行一个数，代表元素和为负数的子序列的数量。 限制$1 \leq n \leq 500000$. 样例输入2 -1 -1 输出3 思路一个长度为 $n$ 的数列包含 $\frac{n(n-1)}{2}$ 个子序列，将他们全部枚举出来绝对 T 飞，即便是使用了前缀和优化也照样 $O(N^2)$ 面对数据无能为力。 尽管如此，前缀和确实是一个非常好的思路，我们 $O(N)​$ 就可以求出前缀和，这个时候如果我们将前缀和放在一个数组中，其代表的就是一整段区间的和，左端点为0.记这个数组为 $b​$,那么如果 $b_i &gt; b_j​$ 且 $i&lt;j​$ 说明区间 $[a_i,a_j]​$ 的数字之和为负数，这看上去是不是很像逆序对？求出来就是答案了。 实践归并排序和树状数组应该都可以解决本题。唯一需要注意的是逆序对的数量代表着有多少个满足 $b_i &gt; b_j$ 且 $i&lt;j$ 的区间 $[a_i,a_j]$ 的数字之和为负数，在这里 $a_i \not= 0$,因此所有的 $b_i &lt;0$ 也需要被计入答案中，因为这是也是一个没有考虑过的区间。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1008611;int a[maxn], r[maxn], ans = 0, n, ts[maxn];void msort(int s, int t)&#123; if (s == t) return; int mid = (s + t) &gt;&gt; 1; msort(s, mid); msort(mid + 1, t); int i = s, j = mid + 1, k = s; while (i &lt;= mid &amp;&amp; j &lt;= t) &#123; if (a[i] &lt;= a[j]) r[k] = a[i], k++, i++; else &#123; r[k] = a[j], k++, j++; ans += mid - i + 1; &#125; &#125; while (i &lt;= mid) r[k] = a[i], k++, i++; while (j &lt;= t) r[k] = a[j], k++, j++; for (int i = s; i &lt;= t; i++) a[i] = r[i];&#125;int main()&#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", ts + i); *a = 0; for (int i = 1; i &lt;= n; i++)a[i] = a[i - 1] + ts[i]; msort(1, n); for (int i = 1; i &lt;= n; i++)if (a[i] &lt; 0)ans++; printf("%d\n", ans); //system("pause"); return 0;&#125; Super Mario题目链接：HDOJ4417 描述详情有一个数组包含 $n$ 个数，$a_0, a_1 \cdots \cdots a_{n-1}$ ,有 $m$ 个询问，你需要求出 $a_i$ 至 $a_j$ 有多少个数小于 $k$. 输入格式一行一个数 $T$ 代表数据组数. 一行 $2$ 个数 $n,m$. 一行 $n$ 个数 $a_i$. 接下来 $m$ 行每行一个询问 $a_i,a_j,k$. 输出格式每组数据前输出 Case X: 接下来 $m$ 行 $m$ 个数代表询问答案。 限制$1 \leq n,m \leq 10^5$. $0 \leq k \leq 1000000000$. 样例输入12345678910111213110 100 5 2 7 5 4 3 8 7 7 2 8 63 5 01 3 11 9 40 1 03 5 55 5 14 6 31 5 75 7 3 输出1234567891011Case 1:4003120151 思路我的第一道分块题目。 这题思路还比较好想，由于有2秒的时限，可以直接暴力，带上分块即可。 实践先将原序列读进来，分块的大小为 $\sqrt n$ ，对于每一个块开一个结构体，里面有另外一个数组保存这 $\sqrt n$ 个数。每个分块的区间信息和数组读取完之后，为每一个块内的数组排序。 对于每一条询问，不在块中的两边暴力，在块中的二分查找。总时间复杂度为 $O(M \space \sqrt N \space \log \sqrt N )$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;struct Seq &#123; int fr, to; int high[120]; int bound(const int &amp;H) &#123; return std::upper_bound(this-&gt;high, this-&gt;high + to - fr + 1, H) - this-&gt;high; &#125;&#125;;Seq block[120];int orig[10050], totBlocks;int findBlock(const int &amp;x) &#123; int fr = 0, to = totBlocks - 1, mid; while (fr &lt; to) &#123; mid = (fr + to) &gt;&gt; 1; if (block[mid].fr &lt;= x &amp;&amp; block[mid].to &gt;= x)return mid; if (block[mid].fr &gt; x)to = mid - 1; else fr = mid + 1; &#125; return fr;&#125;int main()&#123; int totCases, totNums, totQuery, fr, to, maxH; int seqFr, seqTo, blockSize, last, blockNo, cnt; scanf("%d", &amp;totCases); for (int Case = 1; Case &lt;= totCases; Case++) &#123; printf("Case %d:\n", Case); scanf("%d%d", &amp;totNums, &amp;totQuery); blockSize = std::sqrt(totNums); totBlocks = totNums / blockSize; last = 0; blockNo = 0; for (int i = 0; i &lt; totNums; i++) &#123; scanf("%d", orig + i); if (i - last + 1 &gt;= blockSize) &#123; //新的块 last = i + 1; block[blockNo].to = i; block[blockNo].fr = i - blockSize + 1; for (int j = 0; j &lt; blockSize; j++) block[blockNo].high[j] = orig[i - blockSize + j + 1]; std::sort(block[blockNo].high, block[blockNo].high + blockSize); blockNo++; &#125; &#125; //回答询问 while (totQuery--) &#123; cnt = 0; scanf("%d%d%d", &amp;fr, &amp;to, &amp;maxH); seqFr = findBlock(fr) + 1; seqTo = findBlock(to) - 1; if (seqFr &gt; seqTo) &#123; for (int i = fr; i &lt;= to; i++) if (orig[i] &lt;= maxH)cnt++; &#125; else &#123; for (int i = fr; i &lt; block[seqFr].fr; i++) if (orig[i] &lt;= maxH)cnt++; for (int i = block[seqTo].to + 1; i &lt;= to; i++) if (orig[i] &lt;= maxH)cnt++; for (int i = seqFr; i &lt;= seqTo; i++) cnt += block[i].bound(maxH); &#125; printf("%d\n", cnt); //ans.push(cnt); &#125; &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题集</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模拟</tag>
        <tag>线段树</tag>
        <tag>二分答案</tag>
        <tag>前缀和</tag>
        <tag>排序</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P2085]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%B4%9B%E8%B0%B7P2085%2F</url>
    <content type="text"><![CDATA[题目不难，看上去像是数学题，实际上应该使用优先队列解决。 记 $N$ 为正整数集合，由于出现了一些问题，那个符号打不出来 仔细观察题目，发现 $x \in N$ 也就是说自然数 $x \ge 1$. 如果我们能够证明对于任何一个函数 $f(x)$ 而言， $\forall f(x) \leq f(x+b)$ 这里 $b \in N$ 且 $x,x+b$ 都在 $f$ 的定义域中，那么题目可以转换为一个经典问题。首先可能是最小的是所有的 $f_i(1)$ ，我们在这当中选择一个最小的假定为 $f_j(1)$, 拿出队列，再放一个 $f_j(2)$ 进去，重复这个操作，得到的一定是最小的 $m$ 个数，因为有了上述定理，队列中所有的函数都是最小的，换一个大一点的 $x$ 进去不可能得到一个更小的值，换一个小一点的 $x$ 进去就和之前的重复了。 证明： $\forall f(x) \leq f(x+y)$. $f(x) = ax^2 + bx +c$ 且 $a,b,c\in N$ .(已知) $\because f(x) \leq f(x+y)$ $\therefore f(x+y)-f(x)\ge 0$ 即证 $f(x+y)-f(x)\ge 0$. f(x+y)-f(x) = ax^2+ay^2+axy+bxy+c-ax^2-bx-c也就是 ay^2+axy+bx(y-1)$\because y\in N$ $\therefore y-1\ge 0$ 式子中每一项都不小于0，所以 $f(x+y)-f(x) \ge 0$. 证毕. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define sqr(x) ((x)*(x))struct FUNCTION &#123; int a, b, c, x; long long val; void Solve() &#123; x++; val = a * sqr(x) + b * x + c; &#125; bool operator &lt; (FUNCTION comp)const &#123; return comp.val &lt; this-&gt;val; &#125;&#125;;std::priority_queue&lt;FUNCTION&gt; que;int main()&#123; int totFunc, totMins; FUNCTION init; //read scanf("%d%d", &amp;totFunc, &amp;totMins); for (int i = 0; i &lt; totFunc; i++) &#123; scanf("%d%d%d", &amp;init.a, &amp;init.b, &amp;init.c); init.x = 0; init.Solve(); que.push(init); &#125; for (int i = 0; i &lt; totMins; i++) &#123; init = que.top(); que.pop(); printf("%lld ", init.val); init.Solve(); que.push(init); &#125;putchar('\n'); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P1967]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%B4%9B%E8%B0%B7P1967%2F</url>
    <content type="text"><![CDATA[这题近似于模板题，就是 最小生成树+LCA 求一下树上两个点之间的唯一路径上面权值最小的一条边，思路非常简单，但是想要实现还是需要注意很多细节的。 尽管如此，我的第一次提交还是 WA 掉了一个点，下载下来一看发现其中的一个询问错了，有可能会存在很多棵树需要分别 dfs ，最终的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define MAXN 100050int totCity, totRoad;//最小生成树int up[MAXN];int findTop(int nowAt) &#123; return up[nowAt] == nowAt ? nowAt : up[nowAt] = findTop(up[nowAt]);&#125;void unity(int a, int b) &#123; a = findTop(a); b = findTop(b); up[a] = b;&#125;struct edge &#123; int fr, to, val; bool operator () (edge a, edge comp)const &#123; return a.val &gt; comp.val; &#125;&#125;;std::vector&lt;edge&gt; toTree;//-----------//LCAstruct way &#123; int to, val;&#125;;std::vector&lt;way&gt; G[MAXN];int depth[MAXN], fa[MAXN][21], maxVal[MAXN][21];void dfs(edge roadLink) &#123; depth[roadLink.to] = roadLink.fr == 0 ? 1 : depth[roadLink.fr] + 1; fa[roadLink.to][0] = roadLink.fr; maxVal[roadLink.to][0] = roadLink.val; for (int i = 1; i &lt; 21; i++) &#123; fa[roadLink.to][i] = fa[fa[roadLink.to][i - 1]][i - 1]; maxVal[roadLink.to][i] = std::min(maxVal[roadLink.to][i - 1], maxVal[fa[roadLink.to][i - 1]][i - 1]); &#125; for (const auto &amp;it : G[roadLink.to]) if (depth[it.to] &lt;= 0) dfs(&#123; roadLink.to,it.to,it.val &#125;);&#125;int LCA(int a, int b) &#123; if (depth[a] &lt; depth[b])std::swap(a, b); int _min = INT_MAX; for (int i = 20; i &gt;= 0; i--) if (depth[fa[a][i]] &gt;= depth[b]) &#123; _min = std::min(_min, maxVal[a][i]); a = fa[a][i]; &#125; if (a == b)return _min; for (int i = 20; i &gt;= 0; i--) if (fa[a][i] != fa[b][i]) &#123; _min = std::min(std::min(maxVal[a][i], maxVal[b][i]), _min); a = fa[a][i]; b = fa[b][i]; &#125; return std::min(std::min(maxVal[b][0], maxVal[a][0]), _min);&#125;int main()&#123; memset(depth, 0, sizeof(depth)); for (int i = 0; i &lt; MAXN; i++)up[i] = i; int fr, to, val, totCar; scanf("%d%d", &amp;totCity, &amp;totRoad); for (int i = 0; i &lt; totRoad; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;val); toTree.push_back(&#123; fr,to,val &#125;); &#125;std::sort(toTree.begin(), toTree.end(), edge()); int siz = totCity - 1; for (const auto &amp;it : toTree) if (findTop(it.fr) != findTop(it.to)) &#123; unity(it.fr, it.to); G[it.fr].push_back(&#123; it.to,it.val &#125;); G[it.to].push_back(&#123; it.fr,it.val &#125;); if (--siz &lt;= 0)break; &#125; for (int i = 1; i &lt;= totCity; i++) if (depth[i] &lt;= 0) dfs(&#123; 0,i,0 &#125;); scanf("%d", &amp;totCar); for (int i = 0; i &lt; totCar; i++) &#123; scanf("%d%d", &amp;fr, &amp;to); if (findTop(fr) != findTop(to))puts("-1"); else printf("%d\n", LCA(fr, to)); &#125; //system("pause"); return 0;&#125; 题目非常毒瘤，但是用来练习 LCA 也可以算是一道好题。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>排序</tag>
        <tag>LCA</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1037C Equalize]]></title>
    <url>%2F2018%2F09%2F04%2FCF1037C-Equalize%2F</url>
    <content type="text"><![CDATA[题目链接 ：给你两个长度都是 $n$ 的0-1字符串 $a$ 和 $b$ ,你可以对 $a$ 执行两种操作： 将 $a_i xor 1$ ,代价为1. 将 $a_i ， a_j \space (j \not = i)$ 互换位置，代价为 $|j-i|$. 你需要使用最小的代价，使得 $a=b$. 贪心的策略是只看两个字符串字符不同的那些位置，然后看看能不能交换到旁边的一个位置消除掉两个字符的不同，如果可以则使用 2 ，否则1. 原因是如果交换到间隔一个或者更多的位置上去，最多也只能消除掉两个字符的不同，但是代价却大于2，不如方案1划算。 最终的时间复杂度为 $O(N)$ ，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Collections;namespace P1967&#123; class Program &#123; public class Global &#123; public static string a; public static List&lt;int&gt; up1, down1; &#125; static void Main(string[] args) &#123; int len &#x3D; Convert.ToInt32(Console.ReadLine()), inp; Global.a &#x3D; Console.ReadLine(); Global.up1 &#x3D; new List&lt;int&gt; &#123; &#125;;Global.down1 &#x3D; new List&lt;int&gt; &#123; &#125;; for(int i &#x3D; 0;i &lt; len;i++) &#123; inp &#x3D; Console.Read() - &#39;0&#39;; if(inp !&#x3D; (Global.a[i] - &#39;0&#39;)) &#123; if(inp &#x3D;&#x3D; 1) Global.down1.Add(i); else Global.up1.Add(i); &#125; &#125; int downNow &#x3D; 0, cnt &#x3D; 0; for(int upNow &#x3D; 0;upNow &lt; Global.up1.Count;upNow++) &#123; if(downNow &gt;&#x3D; Global.down1.Count) &#123; cnt++;continue; &#125; while(downNow &lt; Global.down1.Count &amp;&amp; Global.up1[upNow] - Global.down1[downNow] &gt;&#x3D; 2) &#123; cnt++; downNow++; &#125; if(downNow &lt; Global.down1.Count &amp;&amp; Math.Abs(Global.down1[downNow] - Global.up1[upNow]) &lt; 2) downNow++; cnt++; &#125; cnt +&#x3D; Global.down1.Count - downNow; Console.WriteLine(cnt.ToString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成树学习笔记]]></title>
    <url>%2F2018%2F09%2F03%2F%E7%94%9F%E6%88%90%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[描述生成树一般是通过某种算法在一张无向图中去掉一部分连边，使得最终剩下的 $n$ 个顶点和 $n-1$ 条边能够构成一颗树，通常情况下我们要在这基础之上，使得生成树满足某种性质或者符合我们的要求，这样特殊的生成树典型的例子就是最小生成树。最小生成树的求解算法有 $prim$ 和 $kruskal$ 等。 以下部分内容摘自刘汝佳、陈锋的书[算法竞赛入门经典——训练指南]。 以下的证明过程是我个人的一些 idea, 不能保证全部正确，如果您发现有任何错误或者瑕疵可以直接指出，我会第一时间改正。 为了方便起见，记原图为 $G$, $G$ 的最小生成树为 $K$ ,$K$ 包含的点集为 $S$, 边集为 $E$. 在没有特殊说明的前提下，边层级下 $|G| = m$ ,点层级下 $|G| = n$. Kruskal 和 Prim两种算法都可以在线性对数时间复杂度内求出连通图的最小生成树，但是两者考虑的方向不同，分别在边层级和点层级。尽管如此，它们也存在很多共同点，比如都会在当前的一个边层级集合中考虑边权最小的那一条边。 代码如下： Kruskal12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using System;using System.Collections.Generic;namespace Kruskal&#123; class Program &#123; public class Road &#123; public int Fr &#123; get; set; &#125; public int To &#123; get; set; &#125; public int Val &#123; get; set; &#125; &#125; public class CompRoad : IComparer&lt;Road&gt; &#123; public int Compare(Road a, Road b) &#123; if(a.Val &#x3D;&#x3D; b.Val) return 0; else return (a.Val &lt; b.Val) ? -1 : 1; &#125; &#125; public class Union_find &#123; private static int[] Up; public static void Activate(int n) &#123; Up &#x3D; new int[n]; for(int i &#x3D; 0;i &lt; n;i++) Up[i] &#x3D; i; &#125; public static int findTop(int nowAt) &#123; return Up[nowAt] &#x3D;&#x3D; nowAt ? nowAt : Up[nowAt] &#x3D; findTop(Up[nowAt]); &#125; public static void Untiy(int a,int b) &#123; a &#x3D; findTop(a);b &#x3D; findTop(b); Up[a] &#x3D; b; &#125; &#125; public class Global &#123; public static List&lt;Road&gt; rd; &#125; static void Main(string[] args) &#123; string[] div &#x3D; Console.ReadLine().Split(&#39; &#39;); int totNodes &#x3D; Convert.ToInt32(div[0]), totLinks &#x3D; Convert.ToInt32(div[1]); Global.rd &#x3D; new List&lt;Road&gt; &#123; &#125;; Union_find.Activate(totNodes + 1); for(int i &#x3D; 0;i &lt; totLinks;i++) &#123; div &#x3D; Console.ReadLine().Split(&#39; &#39;); Global.rd.Add(new Road() &#123; Fr &#x3D; Convert.ToInt32(div[0]), To &#x3D; Convert.ToInt32(div[1]), Val &#x3D; Convert.ToInt32(div[2]) &#125;); &#125; Global.rd.Sort(new CompRoad()); Int64 _count &#x3D; 0; foreach(var it in Global.rd) &#123; if(Union_find.findTop(it.Fr) !&#x3D; Union_find.findTop(it.To)) &#123; Union_find.Untiy(it.Fr, it.To); _count +&#x3D; it.Val;totNodes--; &#125; if(totNodes &lt;&#x3D; 1) break; &#125; if(totNodes &gt; 1) Console.WriteLine(&quot;orz&quot;); else Console.WriteLine(_count.ToString()); &#125; &#125;&#125; 以及 Prim12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Prim#include&lt;bits/stdc++.h&gt;#define MAXN 5050struct Edge&#123; int to,val; bool operator &lt; (Edge comp)const&#123; return val &gt; comp.val; &#125;&#125;;bool init[MAXN];std::vector&lt;Edge&gt; G[MAXN];std::priority_queue&lt;Edge&gt; que;int main()&#123; memset(init,false,sizeof(init)); int totNodes, totEdges, fr, to, val; //read scanf("%d%d", &amp;totNodes, &amp;totEdges); for(int i = 0; i &lt; totEdges; i++)&#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;val); --fr; --to; G[fr].push_back(&#123; to,val &#125;); G[to].push_back(&#123; fr,val &#125;); &#125; *init = true; for(const auto &amp;it:*G) que.push(it); Edge nowAt; long long _count = 0; while(!que.empty())&#123; nowAt = que.top(); que.pop(); if(init[nowAt.to]) continue; init[nowAt.to] = true; _count += nowAt.val; for(const auto &amp;it:G[nowAt.to]) if(!init[it.to]) que.push(it); &#125; bool flag = true; for(int i = 0; i &lt; totNodes; i++) if(!init[i])&#123; flag = false;break; &#125; if(!flag)puts("orz"); else std::cout&lt;&lt;_count&lt;&lt;std::endl; return 0;&#125; 基本思想是在边层级上从小到大一个个尝试可能加入的边，在点层级上每次加入由当前点扩展出去的所有可能边中权值最小的那个。不难证明他们是正确的。 基本性质最小生成树满足以下几个性质。 切割性质 假定所有边权值都不相同。设 $C$ 为 $G$ 中既非空集也非全集的 $V$ 的子集，边 $e$ 是满足一个端点在 $S$ 内，另一个端点不在 $S$ 内的所有边中权值最小的一个，则 $G$ 的所有生成树均包含 $e$. 证明： 设在边层级上， $K_0$ 为 $S$ 的最小生成树， $K_1$ 为 $V-S$ 的最小生成树， 则 $V$ 的最小生成树为 $K_0 \cup K_1$, 除此之外还要再加上一条边，在点层级上连接 $K_0$ 和 $K_1$ .而这一条边，最小就是 $e$. 证毕. 回路性质 假定所有边权值均不相同。设 $C$ 为 $G$ 中任意回路，边 $e$ 是 $C$ 上权值最大的边，则图 $G$ 的所有生成树均不包含 $e$. 证明： 反证法。假定 $e \in K$, 那么 $C$ 上一定有至少一条边 $v$ 不属于 $K$, 将 $v$ 加入 $K$ 中，则会出现一条回路，这条回路一定包含 $e$ ,倘若在这条回路上去掉任意一条边 $K$ 就会重新成为 $G$ 的生成树，而如果去掉的边是 $e$, 答案只可能更优，因为 $e$ 是 $C$ 上权值最大的边。这样，不可能存在任何一个最小生成树包含 $e$. 证毕. 增量最小生成树 从包含 $n$ 个点的空图开始，依次加入 $m$ 条带权边。每加入一条边，输出当前最小生成树的权值。（不连通则输出无解） 解法： 每加入一条边 $e = (u,v)$ 后，图中恰好包含一个环。根据回路性质，删除回路上权值最大的边即可，因此只用在之前的 $K$ 中找到 $u$ 到 $v$ 权值最大的路径与 $e$ 比较，删除权值最大的一条，总时间复杂度为 $O(nm)$. 相关题目： CF609E : Minimum spanning tree for each edge 给定一个无向连通图 $G$, 边集为 $E$, 你需要求出所有的 $K$, 包含边 $e_i \in E$, 且 $e_i \in K$. 在边层级上输出 $K$ 的权值。 解法： 从这道题中可以看出一些增量最小生成树和之前提到的回路性质的影子。先求出 $K$, 然后一条条加边，求一下加入边 $e$ 两个端点的 $LCA$ , 去掉两个点到 $LCA$ 路径中权值最大的点即可。特别地，如果 $e \in K$, 那么直接输出当前 $K$ 的权值即可。 关键代码： 123456789//最小生成树int leftn = totNode - 1;for (const auto &amp;it : links) if (findTop(it.fr) != findTop(it.to)) &#123; unity(it.fr, it.to); totEdgeTotVal += it.val; G[it.fr].push_back(&#123; it.to,it.val &#125;); G[it.to].push_back(&#123; it.fr,it.val &#125;); if (--leftn &lt;= 0)break; &#125; 1234for (const auto &amp;it : origLinks) &#123; LCA(it.fr, it.to); printf("%lld\n", totEdgeTotVal + it.val - _max);&#125; 瓶颈类生成树瓶颈指的是生成树中最大的某一个权值，通常情况下会要求这个瓶颈尽可能小。 最小瓶颈生成树 给定无向图 $G$ ,求一棵生成树，使得最大边权值尽可能小。 解法： 直接求最小生成树，$K$ 一定是 $G$ 的最小瓶颈生成树。 证明： 先证明一个引理，如果 $T$ 为 $G$ 的子图，那么 $K$ 一定包含 $T$ 的最小生成树 $T_K$.理由如下： 将 $G$ 中所有的边分为三类： $v \in K$ $s \in G-T$ $t$ 的两个端点分别在 $G-T$ 和 $T$ 中。 那么我们在进行 Kruskal 的过程中，碰到的合法边一定为这三类，而且去掉不属于 $T_K$ 的边不看，这个过程就是在求 $T$ 的最小生成树，因为所有其他的加边都不会影响这个过程，而添加边的顺序是无关紧要的(我们只关心最终有那些边)，因此 $G$ 的最小生成树就是 $G-T$ 的最小生成树和 $T_K$ 加上一条最小的 $t$. 证毕。 假设有三个集合 $A,B,C$ 在点层级上满足 $A \cup B \cup C = G$ 且 $A,B,C$ 之间的交集都为空集，记它们的最小生成树分别为 $A_K, B_K, C_K$ ,那么 $K$ 一定包含 $A_K, B_K,C_K$. 根据引理，我们再讨论 $A_K,B_K,C_K$ 内部的点或者边是没有意义的，他们已经确认是符合条件且最小的。 假定连接 $A_K \leftrightarrow B_K , B_K \leftrightarrow C_K , C_K \leftrightarrow A_K$ 的最小边分别为 $a,b,c$ 且 $a \leq b \leq c$ . 且 $b$ 为 $K$ 中权值最大的边。 $a,b \in K, c\notin K$. 如果能够找到一个更优的解，我们将要放弃选择 $b$ 而选择其它的边。如果将 $b$ 换成 $c$ 或者其它的边不可能使答案更优，$a$ 也一样，因为它们都已经是最小的了。可见，我们无法构造出来一个使得答案更优的生成树。 证毕。 最小瓶颈路 给定 $G$ 中的两个结点 $v,u$ ，求出从 $u$ 到 $v$ 的一条路径，使得这条路径上最长边的最大边长尽可能小。 解法： 求出 $K$ , $v \to u$ 的唯一路径即为所求路径。 证明： 利用求最短路径的算法。如果以 $u$ 为起点，$v$ 为终点执行一次最短路，那么就可以求出来一条路径 $S$ 满足题意，只需证明 $S \subseteq K$ 即可。 回顾 Dijkstra 的具体过程，我们每一次选择一个没有选择过的，而且起点到它距离最短的点 $t$ 对其他点进行更新，由于 $t$ 也是由某一个点 $t_0$ 连上 $t_0 \to t$ 从而最小，相当于是找了一条最小的边加入了进来，对于 $t$ 前面所有的点都是如此。具体地说，从 $s$ 出发加入一条 $s \to s_1$ 使得 $s \to s_1$ 最小，再将所有的由 $s_1$ 出发的点加入到考虑的边集中，又求出 $s_1 \to s_2$ 使得 $s \to s_2$ 最小 $\cdots \space \cdots$ 这个过程不就是 Prim 算法吗？这一步结束之后求出的 $S$ 就是 $G$ 的某一个子图的最小生成树。 而我们前面已经证明过，$S$ 在点层级和边层级下都是 $K$ 的一部分。 因此原命题得证。证毕。 实践： 先求出 $K$, 然后对于每一个询问执行一次 LCA，即可求出题目要求的路径最大值。 每对点之间的最小瓶颈路 给出图 $G$ ,求出所有 $s,v \in G$ 且 $s \not= v$ 的最小瓶颈路中的最大权值。 这可以看作是上一个问题的多询问版本，之前提到的方法完全可以使用，正确性已经得到了证明，如果询问 $Q$ 次，时间复杂度为 $O(N\log N + Q\log N)$ . 但是，如果 $Q$ 大得可怕，存在有效率更高的算法。 解法： 求出 $K$ 之后借助 DFS 从任意一个结点开始搜索，每到达一个新的结点，就用之前已经访问过了的结点到其父节点的权值和加上父亲到它的权值进行更新，DFS 结束之后就求出了所有 $s,v$ 的情况，可以 O(1) 回答询问。总的时间复杂度为 $O(N\log N+N^2+Q)$ ，三项分别代表求出最小生成树，DFS，回答询问。 次小生成树 将 $G$ 的所有生成树按照权值和从小到大排序，排在第二位的生成树就是 $G$ 的次小生成树。 解法： 求出 $K$ ,枚举接下来将要加入那一条新边，加入一条新边 $u \leftrightarrow v$之后，会出现一条回路，减去 $K$ 中 $u\to v$ 唯一路径上的最大边权值，计算出一个可能的生成树，然后再这些可能的生成树中选择一个最小的，即为所求的次小生成树。实现细节中求最大边权可以借助之前提到的 每对点之间的最小瓶颈路 解法。总时间复杂度为 $O(N^2)$.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF427C]]></title>
    <url>%2F2018%2F09%2F02%2FCF427C%2F</url>
    <content type="text"><![CDATA[这题意思是让你找出有向图 $G$ 中所有强连通分量中点权最小的点权值之和，以及有多少种不同的选择方法使得点权和最小。 首先，如果我们求出来了所有的SCC，那么只用在相信时间内处理每一个 $SCC_i$, 就可以找出 $min\{SCC_i\}$ 和 $\sum_{j=0} ^{n} 1 (j \in SCC_i \space ,\space j = min\{SCC_i\})$ . 求出所有 SCC 可以使用 Tarjan 算法，我们可以在找到一个新的 SCC 时就更新答案，最后的时间复杂度为 $O(N)​$. 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define MAXN 100050const long long mod = 1000000007;int val[MAXN]; std::vector&lt;int&gt; G[MAXN];int pre[MAXN], low[MAXN], sccID[MAXN], dfs_Clock, nowScc;long long _count = 1, ans = 0;std::stack&lt;int&gt; S;void dfs(int nowAt) &#123; pre[nowAt] = low[nowAt] = dfs_Clock++; S.push(nowAt); for (const auto &amp;it : G[nowAt]) &#123; if (pre[it] == -1) &#123; dfs(it); low[nowAt] = std::min(low[nowAt], low[it]); &#125; else if (sccID[it] == -1) low[nowAt] = std::min(low[nowAt], pre[it]); &#125; //New SCC if (pre[nowAt] == low[nowAt]) &#123; int x, cnt = 0, _min = INT_MAX; do &#123; x = S.top(); S.pop(); sccID[x] = nowScc; if (val[x] == _min)cnt++; else if (val[x] &lt; _min) &#123; cnt = 1; _min = val[x]; &#125; &#125; while (x != nowAt); nowScc++; _count = _count * (cnt % mod) % mod; ans += _min; &#125;&#125;int main()&#123; int totNodes, totRoads, fr, to; scanf("%d", &amp;totNodes); for (int i = 0; i &lt; totNodes; i++)scanf("%d", val + i); scanf("%d", &amp;totRoads); for (int i = 0; i &lt; totRoads; i++) &#123; scanf("%d%d", &amp;fr, &amp;to); G[--fr].push_back(--to); &#125; dfs_Clock = nowScc = 0; memset(pre, -1, sizeof(pre)); memset(sccID, -1, sizeof(sccID)); for (int i = 0; i &lt; totNodes; i++) if (pre[i] == -1)dfs(i); std::cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; _count &lt;&lt; std::endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF609E]]></title>
    <url>%2F2018%2F09%2F02%2FCF609E%2F</url>
    <content type="text"><![CDATA[给定一张无向图 $G$, $e \in G$, 分别求出所有包含 $e_i $ 的最小生成树的边权之和。 生成树具有回路性质，即： 假定所有边权值均不相同。设 $C$ 为 $G$ 中任意回路，边 $e$ 是 $C$ 上权值最大的边，则图 $G$ 的所有生成树均不包含 $e$. 所以先求出 $G$ 的最小生成树 $K$, 然后一条条加边，求一下加入边 $e$ 两个端点的 $LCA$ , 去掉两个点到 $LCA$ 路径中权值最大的点即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;#define MAXN 200050//最小生成树struct Road &#123; int fr, to, val; bool operator () (Road a, Road comp)const &#123; return a.val &lt; comp.val; &#125;&#125;;std::vector&lt;Road&gt; links, origLinks;int up[MAXN];int findTop(int nowAt) &#123; return up[nowAt] == nowAt ? nowAt : up[nowAt] = findTop(up[nowAt]);&#125;void unity(int a, int b) &#123; a = findTop(a); b = findTop(b); up[a] = b;&#125;//------------------//LCAstruct way &#123; int to, val;&#125;;std::vector&lt;way&gt; G[MAXN];int Fa[MAXN][21], depth[MAXN];long long maxVal[MAXN][21], _max;void dfs(const int nowAt,const int valLink = INT_MIN, const int fa = 0) &#123; depth[nowAt] = fa == 0 ? 1 : depth[fa] + 1; Fa[nowAt][0] = fa; maxVal[nowAt][0] = valLink; for (int i = 1; i &lt; 21; i++) &#123; Fa[nowAt][i] = Fa[Fa[nowAt][i - 1]][i - 1]; maxVal[nowAt][i] = std::max(maxVal[nowAt][i - 1], maxVal[Fa[nowAt][i - 1]][i - 1]); &#125; for (const auto &amp;it : G[nowAt]) if (depth[it.to] == -1) dfs(it.to, it.val, nowAt);&#125;void LCA(int a, int b) &#123; _max = INT_MIN; if (depth[a] &lt; depth[b])std::swap(a, b); for (int i = 20; i &gt;= 0; i--) if (depth[Fa[a][i]] &gt;= depth[b]) &#123; _max = std::max(_max, maxVal[a][i]); a = Fa[a][i]; &#125; if (a == b)return; for (int i = 20; i &gt;= 0; i--) if (Fa[a][i] != Fa[b][i] &amp;&amp; Fa[a][i] != 0) &#123; _max = std::max(std::max(maxVal[a][i], maxVal[b][i]), _max); a = Fa[a][i]; b = Fa[b][i]; &#125; _max = std::max(std::max(maxVal[a][0], maxVal[b][0]), _max);&#125;int main()&#123; memset(depth, -1, sizeof(depth)); memset(Fa, 0, sizeof(Fa)); for (auto &amp;it : maxVal)for (auto &amp;cg : it)cg = INT_MIN; for (int i = 0; i &lt; MAXN; i++)up[i] = i; int totNode, totEdge, fr, to, val; long long totEdgeTotVal = 0; //read scanf("%d%d", &amp;totNode, &amp;totEdge); for (int i = 0; i &lt; totEdge; i++) &#123; scanf("%d%d%d", &amp;fr, &amp;to, &amp;val); links.push_back(&#123; fr, to,val &#125;); origLinks.push_back(&#123; fr,to,val &#125;); &#125;std::sort(links.begin(), links.end(), Road()); //最小生成树 int leftn = totNode - 1; for (const auto &amp;it : links) if (findTop(it.fr) != findTop(it.to)) &#123; unity(it.fr, it.to); totEdgeTotVal += it.val; G[it.fr].push_back(&#123; it.to,it.val &#125;); G[it.to].push_back(&#123; it.fr,it.val &#125;); if (--leftn &lt;= 0)break; &#125; //LCA dfs(1); for (const auto &amp;it : origLinks) &#123; LCA(it.fr, it.to); printf("%lld\n", totEdgeTotVal + it.val - _max); &#125; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成树</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无向图Bicoloring黑白二着色 模板]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%97%A0%E5%90%91%E5%9B%BEBicoloring%E9%BB%91%E7%99%BD%E4%BA%8C%E7%9D%80%E8%89%B2-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[无向图的黑白二着色需要我们对一个无向图 $G$ 的每一个结点涂上黑色或者白色。要求一个符合条件的着色图 $G$ 使得 $G$ 中所有连边连接的两个结点有着不同的颜色。 定义每个节点有三种状态： 没有访问 ， 黑色 ， 白色. $G$ 中所有连通块的着色方案都是唯二确定的，如果确定了其中某一个点的颜色，方案唯一确定，另一种方案是将所有颜色反转。所以将所有点遍历一遍，如果状态是 没有访问 ，则随便涂上一个颜色，由于方案唯一确定，直接深搜即可，如果发现有一处矛盾，直接返回无解，不需要回溯。 相关题目： 洛谷P1330 封锁阳光大学 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System;using System.Collections;namespace P1967&#123; class Program &#123; public class Global &#123; public static List&lt;int&gt;[] G; public static bool?[] col; public static uint black, white; &#125; static void Main(string[] args) &#123; string[] div &#x3D; Console.ReadLine().Split(&#39; &#39;); int totNodes &#x3D; Convert.ToInt32(div[0]), totRoad &#x3D; Convert.ToInt32(div[1]), fr, to; &#x2F;&#x2F;分配内存 Global.col &#x3D; new bool?[totNodes]; Global.G &#x3D; new List&lt;int&gt;[totNodes]; for(int i &#x3D; 0;i &lt; totNodes;i++) &#123; Global.G[i] &#x3D; new List&lt;int&gt; &#123; &#125;; Global.col[i] &#x3D; null; &#125; &#x2F;&#x2F;read for(int i &#x3D; 0;i &lt; totRoad;i++) &#123; div &#x3D; Console.ReadLine().Split(&#39; &#39;); fr &#x3D; Convert.ToInt32(div[0]) - 1;to &#x3D; Convert.ToInt32(div[1]) - 1; Global.G[fr].Add(to);Global.G[to].Add(fr); &#125; &#x2F;&#x2F;dfs bool flag &#x3D; true; uint _count &#x3D; 0; for(int i &#x3D; 0;i &lt; totNodes;i++) if(Global.col[i] &#x3D;&#x3D; null) &#123; Global.white &#x3D; 0;Global.black &#x3D; 0; if(dfs(i, true) &#x3D;&#x3D; false) &#123; flag &#x3D; false; break; &#125; else _count +&#x3D; Math.Min(Global.black, Global.white); &#125; if(flag &#x3D;&#x3D; false) Console.WriteLine(&quot;Impossible&quot;); else Console.WriteLine(_count.ToString()); &#125; static bool dfs(int nowAt, bool color) &#123; Global.col[nowAt] &#x3D; color; if(color) Global.white++; else Global.black++; foreach(var it in Global.G[nowAt]) &#123; if(Global.col[it] &#x3D;&#x3D; color) return false; else if(Global.col[it] &#x3D;&#x3D; null) if(!dfs(it, !color)) return false; &#125; return true; &#125; &#125;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有向图的强连通分量SCC的Tarjan算法 模板]]></title>
    <url>%2F2018%2F09%2F02%2F%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8FSCC%E7%9A%84Tarjan%E7%AE%97%E6%B3%95-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[有向图的强连通分量满足在一张有向图 $G$ 中，存在若干个SCC,为 $S_i$. 而对于每一个 $S_i$, 在点层级满足 $\forall s,t \in S_i$ , $s ,t$ 相互可达。 Tarjan 算法依然借助low数组，以此将同时存在于同一个搜索树中的很多 SCC 分离出来，如果一个结点 $s$ 在更新完成之后，$low_s = pre_s$ ,那么我们就发现了一个新的 SCC：在点层级下以 $s$ 作为搜索树的根的子树。 实现过程中，可以使用一个栈保存结点，如果发现了新的 SCC, 这个 SCC 的点集包含栈中 $s$ 和 $s$ 以后添加进来的那些元素。 SCC 的 Tarjan 算法时间复杂度是线性级别的，相比较于 Kosaraju 算法，常数要更小一些。 代码如下： 1234567891011121314151617181920212223242526272829std::stack&lt;int&gt; S;void dfs(int nowAt) &#123; pre[nowAt] = low[nowAt] = dfs_Clock++; S.push(nowAt); for (const auto &amp;it : G[nowAt]) &#123; if (pre[it] == -1) &#123; dfs(it); low[nowAt] = std::min(low[nowAt], low[it]); &#125; else if (sccID[it] == -1) low[nowAt] = std::min(low[nowAt], pre[it]); &#125; //New SCC if (pre[nowAt] == low[nowAt]) &#123; int x, cnt = 0, _min = INT_MAX; do &#123; x = S.top(); S.pop(); sccID[x] = nowScc; if (val[x] == _min)cnt++; else if (val[x] &lt; _min) &#123; cnt = 1; _min = val[x]; &#125; &#125; while (x != nowAt); nowScc++; _count = _count * (cnt % mod) % mod; ans += _min; &#125;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更多信息&联系方式]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF%26%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Skype: live:kevin77478 Outlook邮箱地址：Kevin77478@outlook.com Gmail邮箱地址: Mickeysnow1031@gmail.com Facebook: Thunremmoni Twitter: Mickey-snow Instagram: thunremmoni Google+: Mickey Snow Github: Mickey-snow 洛谷: Mickey_snow Codeforces: Mickey-snow]]></content>
      <categories>
        <category>搭建与测试</category>
      </categories>
      <tags>
        <tag>Untagged</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎访问Mickey-snow的博客]]></title>
    <url>%2F2018%2F09%2F01%2FWelcome%2F</url>
    <content type="text"><![CDATA[您好，我是 \mathcal{Mickey-snow}来自WFLS,HB,PRC. 欢迎访问我的博客！阁下可以查看 Mickey-snow 的简介，通过这些方式与我交流，共同学习、进步。 这是本项目的地址：https://github.com/Mickey-snow/Mickey-snow.github.io.]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Untagged</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>搭建与测试</category>
      </categories>
      <tags>
        <tag>Untagged</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Hexo中插入图片]]></title>
    <url>%2F2018%2F08%2F31%2F%E5%9C%A8Hexo%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[在网上学习了很多种方法，安装了一堆插件仍然不管用。事实上只用先设置 post_asset_folder 为 true 参数，然后在Hexo目录下执行 npm install https://github.com/CodeFalling/hexo-asset-image —save. 具体使用过程中，创建一个文件夹放在 _posts 下，与需要使用图片的文档同名，然后将图片放入文件夹中即可。文档中这样写： 1&#123;% asset_img xxx.jpg 图片描述 %&#125; 效果如下:]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Untagged</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1029F]]></title>
    <url>%2F2018%2F08%2F27%2FCF1029F%20Multicolored%20Markers%2F</url>
    <content type="text"><![CDATA[你需要在一个排布着无限个瓦块的地方将 $a$ 片瓦块染成红色， $b$ 片瓦块染成蓝色。一开始所有的瓦块都是白色的，你只能在白色的瓦块上染色。而且染色完成之后的瓦块必须满足： 所有红色瓦块形成一个矩形或者所有蓝色瓦块形成一个矩形。 所有不是白色的瓦块形成一个矩形。 求出在所有可行的方案中，所有不是白色的瓦块形成的矩形的最小周长 $min(C)$ . 输出这个 $C$. 可以发现，最终有色瓦块形成的这个矩形的长和宽如果分别为 $m​$ 和 $n​$ ,那么 $m+n=a+b​$.我们将所有可能的 $m​$ 和 $n​$ 全部枚举出来，找到一个最小的 $C​$ 就可以了。 不难发现，一组符合条件的 $m$ 和 $n$ 满足下列条件： $m | a+b$ . $n \ge \lceil a \div m \rceil$ 或 $n \ge \lceil b \div m \rceil$ . 我们可以用两次循环分别枚举 $m$ 满足条件2的前半部分或者后半部分。如果限制 $m \leq n$ ，那么 $m \in [1, \sqrt {a+b}]$ 且 $m \in N^+$ ,缩小了枚举范围。时间复杂度为 $O(\sqrt{N})$ . 代码如下： 12345678910111213141516171819202122232425262728293031using System;namespace CF1029F &#123; class Program &#123; static void Main(string[] args) &#123; string[] div &#x3D; Console.ReadLine().Split(&#39; &#39;); Int64 a &#x3D; Convert.ToInt64(div[0]), b &#x3D; Convert.ToInt64(div[1]), _min &#x3D; Int64.MaxValue; Int64 tot &#x3D; a + b, siz &#x3D; (Int64)Math.Sqrt(tot) + 1, len &#x3D; a; for(int i &#x3D; 1;i &lt; siz;i++) &#123; if(a % i &#x3D;&#x3D; 0) len &#x3D; a &#x2F; i; if(tot % i &#x3D;&#x3D; 0 &amp;&amp; tot &#x2F; i &gt;&#x3D; len) _min &#x3D; Math.Min(_min, ((tot &#x2F; i + i) &lt;&lt; 1)); &#125; len &#x3D; b; for(int i &#x3D; 1;i &lt; siz;i++) &#123; if(b % i &#x3D;&#x3D; 0) len &#x3D; b &#x2F; i; if(tot % i &#x3D;&#x3D; 0 &amp;&amp; tot &#x2F; i &gt;&#x3D; len) _min &#x3D; Math.Min(_min, ((tot &#x2F; i + i) &lt;&lt; 1)); &#125; Console.WriteLine(_min.ToString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力/枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过自定义的比较器排序]]></title>
    <url>%2F2018%2F08%2F27%2F%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在使用自定义比较器比较两个变量时，等于则返回0，小于返回-1，大于返回1. 对于Class类的比较器： 1234567891011public class Road &#123; public int Fr &#123; get; set; &#125; public int To &#123; get; set; &#125; public int Val &#123; get; set; &#125;&#125;public class CompRoad : IComparer&lt;Road&gt; &#123; public int Compare(Road a, Road b) &#123; if(a.Val &#x3D;&#x3D; b.Val) return 0; else return (a.Val &lt; b.Val) ? -1 : 1; &#125;&#125; 同样的方法适用于内置类型，在这里按照 Road.Val 大小排序。调用： 1.Sort(new CompRoad()); 使用这种方法完成题目【模板】最小生成树 ,代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using System;using System.Collections.Generic;namespace P1967&#123; class Program &#123; public class Road &#123; public int Fr &#123; get; set; &#125; public int To &#123; get; set; &#125; public int Val &#123; get; set; &#125; &#125; public class CompRoad : IComparer&lt;Road&gt; &#123; public int Compare(Road a, Road b) &#123; if(a.Val &#x3D;&#x3D; b.Val) return 0; else return (a.Val &lt; b.Val) ? -1 : 1; &#125; &#125; public class Union_find &#123; private static int[] Up; public static void Activate(int n) &#123; Up &#x3D; new int[n]; for(int i &#x3D; 0;i &lt; n;i++) Up[i] &#x3D; i; &#125; public static int findTop(int nowAt) &#123; return Up[nowAt] &#x3D;&#x3D; nowAt ? nowAt : Up[nowAt] &#x3D; findTop(Up[nowAt]); &#125; public static void Untiy(int a,int b) &#123; a &#x3D; findTop(a);b &#x3D; findTop(b); Up[a] &#x3D; b; &#125; &#125; public class Global &#123; public static List&lt;Road&gt; rd; &#125; static void Main(string[] args) &#123; string[] div &#x3D; Console.ReadLine().Split(&#39; &#39;); int totNodes &#x3D; Convert.ToInt32(div[0]), totLinks &#x3D; Convert.ToInt32(div[1]); Global.rd &#x3D; new List&lt;Road&gt; &#123; &#125;; Union_find.Activate(totNodes + 1); for(int i &#x3D; 0;i &lt; totLinks;i++) &#123; div &#x3D; Console.ReadLine().Split(&#39; &#39;); Global.rd.Add(new Road() &#123; Fr &#x3D; Convert.ToInt32(div[0]), To &#x3D; Convert.ToInt32(div[1]), Val &#x3D; Convert.ToInt32(div[2]) &#125;); &#125; Global.rd.Sort(new CompRoad()); Int64 _count &#x3D; 0; foreach(var it in Global.rd) &#123; if(Union_find.findTop(it.Fr) !&#x3D; Union_find.findTop(it.To)) &#123; Union_find.Untiy(it.Fr, it.To); _count +&#x3D; it.Val;totNodes--; &#125; if(totNodes &lt;&#x3D; 1) break; &#125; if(totNodes &gt; 1) Console.WriteLine(&quot;orz&quot;); else Console.WriteLine(_count.ToString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于倍增实现的LCA 模板]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%9F%BA%E4%BA%8E%E5%80%8D%E5%A2%9E%E5%AE%9E%E7%8E%B0%E7%9A%84LCA-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[代码对应题目 洛谷P3379 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define MAXNODE 500050 //最大可能的节点数//无向图 Gstd::vector&lt;int&gt; G[MAXNODE];//倍增预处理int up[MAXNODE][20];//深度 - 根int depth[MAXNODE], root;//生成一颗有根树 &amp; 计算深度 &amp; 倍增预处理void dfs(const int rootNow, const int &amp;fa = -1) &#123; //当前节点和当前节点的父节点 depth[rootNow] = depth[fa] + 1; //当前节点深度等于父节点深度加一 memset(up[rootNow], -1, sizeof(up[rootNow])); *up[rootNow] = fa; //计算倍增 for (int i = 1; i &lt; 20; i++) up[rootNow][i] = up[up[rootNow][i - 1]][i - 1]; //2^k = 2^(k-1) * 2 //递归处理子节点 for (const auto &amp;it : G[rootNow]) if (depth[it] == -1) dfs(it, rootNow);&#125;//求a和b的LCAint LCA(int a, int b) &#123; if (depth[a] &lt; depth[b])std::swap(a, b); //确保a的深度不小于b //将A移动到同一深度 for (int x = 19; x &gt;= 0; x--) if (depth[a] - (1 &lt;&lt; x) &gt;= depth[b]) a = up[a][x]; if (a == b)return a; //利用倍增同时移动两个节点 for (int x = 19; x &gt;= 0; x--)//移动到a,b为LCA的两个子节点时停止 if (up[a][x] != -1 &amp;&amp; up[a][x] != up[b][x]) &#123; a = up[a][x]; b = up[b][x]; &#125; return up[a][0];&#125;int main()&#123; memset(depth, -1, sizeof(depth)); int totNode, totQuery, fr, to; //Read scanf("%d%d%d", &amp;totNode, &amp;totQuery, &amp;root); for (int i = 1; i &lt; totNode; i++) &#123; scanf("%d%d", &amp;fr, &amp;to); G[--fr].push_back(--to); G[to].push_back(fr); &#125; dfs(--root); for (int i = 0; i &lt; totQuery; i++) &#123; scanf("%d%d", &amp;fr, &amp;to); printf("%d\n", LCA(fr - 1, to - 1) + 1); &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1029C]]></title>
    <url>%2F2018%2F08%2F25%2FCF1029C%2F</url>
    <content type="text"><![CDATA[CF1029C _Maximal Intersection_ : 暴力 题目大意：给定 $n$ 个区间，你需要在当中去掉一个，求剩下区间交的长度。这里长度是指区间右端点数值减去左端点，例如区间 $[1,2]$ 长度为 $1$.区间交指区间相交的部分，例如区间 $[2,5]$ 和区间 $[3,8]$ 的区间交为 $[3,5]$. 在这题中，$n$ 高达 $3 \times 10^5$ ，很容易让人想到贪心，去掉区间长度最小的。但是这么做是错误的，因为这个最小的区间位置是不确定的，很有可能是这样的情况： 这种情况下，正解应该是去掉橘色的线段，而我们的贪心却去掉了黑色的。 不得不说这题的数据范围非常具有欺骗性，尽管 $n$ 最高有可能达到 $3 \times 10^5$ ，我们依然可以在 $O(N)$ 的时间复杂度内计算出一个数组 $a$, 其中 $a_i$ 代表去掉区间 $i$ 后所有区间的区间并。 这里给出合并两个区间的代码，它很好理解： 123456789struct cg &#123; int fr, to;&#125;;cg Range(cg a, cg b) &#123; cg ret; ret.fr = std::max(a.fr, b.fr); ret.to = std::min(a.to, b.to); return ret;&#125; cg是为了保存一个区间写的结构体。记合并区间 $A$ 和 $B$ 为 $A \bigotimes B$ . 当我们合并一堆区间的时候，无论按照什么顺序合并，结果一定一样。换句话说，$\bigotimes$ 运算满足交换律： A \bigotimes B \bigotimes C = A \bigotimes C \bigotimes B假设题目给定的区间为 $b_i$ ，那么 a_i = b_0 \bigotimes \cdots \bigotimes b_{i-1} \bigotimes b_{i+1} \bigotimes \cdots \bigotimes b_{n-1}将这个过程分为两部分，第一部分为所有 $b_j | j &lt; i$ ,第二部分为所有 $b_j | j &gt; i$ .可以发现我们没有必要单独为每一个 $a$ 计算一遍这个过程，将 $a_i$ 的第一部分添加一个 $b_i$ 就是 $a_{i+1}$ 的第一部分了，按照这个思路，计算所有的第一部分时间复杂度为 $O(N)$, 第二部分也是。 12345678910cg now = *seg;for (int i = 1; i &lt; totSeg; i++) &#123; arr[i] = now; now = Range(now, seg[i]);&#125;now = seg[totSeg - 1];for (int i = totSeg - 2; i &gt;= 0; i--) &#123; arr[i] = Range(arr[i], now); now = Range(now, seg[i]);&#125; 代码中 $arr$ 就是之前提到的 $a$ 数组， $seg$ 就是之前提到的 $b$ 数组。 执行完这一过程，$a$ 数组即为满足条件的数组。最后再扫一遍，求出一个最大值即可。总的时间复杂度仍然为 $O(N)$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;struct cg &#123; int fr, to;&#125;;cg seg[300500], arr[300500];cg Range(cg a, cg b) &#123; cg ret; ret.fr = std::max(a.fr, b.fr); ret.to = std::min(a.to, b.to); return ret;&#125;int main()&#123; int totSeg, fr, to; cin &gt;&gt; totSeg; for (int i = 0; i &lt; totSeg; i++) &#123; cin &gt;&gt; fr &gt;&gt; to; seg[i] = &#123; fr,to &#125;; arr[i] = &#123; INT_MIN,INT_MAX &#125;; &#125; cg now = *seg; for (int i = 1; i &lt; totSeg; i++) &#123; arr[i] = now; now = Range(now, seg[i]); &#125; now = seg[totSeg - 1]; for (int i = totSeg - 2; i &gt;= 0; i--) &#123; arr[i] = Range(arr[i], now); now = Range(now, seg[i]); &#125; int _max = 0; for (int i = 0; i &lt; totSeg; i++) _max=std::max(_max, arr[i].to - arr[i].fr); cout &lt;&lt; _max &lt;&lt; endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力/枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1029D]]></title>
    <url>%2F2018%2F08%2F25%2FCF1029D%20Concatenated%20Multiples%2F</url>
    <content type="text"><![CDATA[给定 $n$ 个整数分别为 $a_i$ ,任选两个数 $a_i, a_j$ 可以合并为 $\overline{a_ia_j}$ （$i \ne j$）.例如 $12$ 和 $345$ 可以合并为 $12345$. 问在所有可行的合并后的整数中，有多少个可以被 $k$ 整除。 这题思路并不难，与处理一下即可。首先，我们需要知道如果合并两个整数得到 $\overline{xy}$ ,那么这就等价于 x \times (log_{10}y+1)+y为了方便起见，我们定义一个函数 $cnt(i) = i$ 在十进制下的位数。例如 $cnt(123) = 3$. 接下来我们预处理出来一个二维数组 $mp_{w,x} = $ 满足 $a_i \times 10^w \equiv x (mod \space k)$ 的所有 $a_i$ 的个数。由于题中给出的数据最大不超过10位数，所以完成这一步的时间复杂度为 $O(N)$. 但是，虽然时间复杂度看上去非常令人乐观，但是这么做的空间复杂度却达到了 $O(K)$ ,难以承受。一种解决的办法是使用 $map$ ，将这个二维数组变成一个一维的 $map$ 数组，此后每次操作时间复杂度都会加上一个 $log$ ，整个预处理为 $O(N \space logN)$ . 与处理完成之后，我们回过头再去看前面给出的公式 $\overline{xy} = x \times (log_{10}y+1)+y$ . 这里 $x,y \in a$ .因此我们可以枚举一下 $y$ ,符合条件的 $x$ 的个数就是 mp_{cnt(y) \space , \space (k-y) \space mod \space k}将这些累加起来，在这个过程中如果存在 $\overline{yy} \equiv 0 (mod \space k)$ 说明有一个是依靠将自己拼在自己后面得到的，将答案减去一。 需要特别注意的是，这题卡常数，即便是时间复杂度正确也有可能会超出时间限制，在这里我使用了一点额外的空间，预先保存了一些频繁使用的数值，避免多次的计算。 代码如下，这份代码在 $2000ms$ 的限制下使用时间大约在 $1800ms$. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const long long cult[] = &#123; 1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,(long long)10000000000,(long long)100000000000 &#125;;inline int read() &#123; int X = 0, w = 0; char ch = 0; while (!std::isdigit(ch)) &#123; w |= ch == '-'; ch = std::getchar(); &#125; while (std::isdigit(ch)) X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48), ch = std::getchar(); return w ? -X : X;&#125;int Cnt(int x) &#123; int _count = 0; while (x &gt; 0) &#123; x /= 10; _count++; &#125; return _count;&#125;#define MAXN 200050int num[MAXN], mod[MAXN];map&lt;int, int&gt; mp[11];int main()&#123; int totNums = read(), k = read(); //read for (int i = 0; i &lt; totNums; i++) &#123; num[i] = read(); mod[i] = num[i] % k; &#125; for (int i = 0; i &lt; totNums; i++) for (int j = 1; j &lt; 11; j++) mp[j][(int)(cult[j] % k*mod[i] % k)]++; int its; long long _count = 0; for (int i = 0; i &lt; totNums; i++) &#123; its = Cnt(num[i]); if (mod[i] != 0) _count += mp[its][k - mod[i]]; else _count += mp[its][0]; if ((cult[its] % k*mod[i] % k + mod[i]) % k == 0) _count--; &#125; cout &lt;&lt; _count &lt;&lt; endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力/枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF510C]]></title>
    <url>%2F2018%2F08%2F24%2FCF510C%20Fox%20And%20Names%2F</url>
    <content type="text"><![CDATA[CF510C _Fox And Names_ : 拓扑排序 题目大意：给定 $n$ 个字符串，求出一个字典是的这 $n$ 个字符串是已经按照字典序排好序了的。 如果我们有 $n$ 个字符串，我们至多可以得到 $n-1$ 个类似于字符 $s$ 小于字符 $t$ 的约束条件。假设 $ a_i $ 为第 $i$ 个字符串，那么如果它们按照字典序排列好的话一定满足 $\forall a_i \leq a_{i+1}$ .模拟一下比较字典序的过程，要比较两个字符串字典序时我们可以创建两个指针一位位地往后面扫，在这里也一样，扫到第一个不相同的位置，就可以得到 $a_i[j] &lt; a_{i+1}[j]$ . 之后，将26个字母当作结点，按照这些条件进行一次拓扑排序即可，如果无法排序则说明这样的字典不存在。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; G[26];int in[26] = &#123;&#125;;char pos[26], *nowAt = pos;int main()&#123; int totStrings, it; cin &gt;&gt; totStrings; string a, b; if (totStrings == 1) &#123; for (char it = 'a'; it &lt;= 'z'; it++)cout &lt;&lt; it; putchar('\n'); return 0; &#125; cin &gt;&gt; b; for (int now = 1; now &lt; totStrings; now++) &#123; a = b; cin &gt;&gt; b; for (int i = 0; i &lt; a.length(); i++) &#123; if (i &gt;= b.length()) &#123; puts("Impossible");return 0; &#125; if (a[i] != b[i]) &#123; G[a[i] - 'a'].push_back(b[i] - 'a'); in[b[i] - 'a']++; break; &#125; &#125; &#125; queue&lt;int&gt; que; for (int i = 0; i &lt; 26; i++)if (in[i] == 0)que.push(i); while (!que.empty()) &#123; it = que.front(); que.pop(); *nowAt++ = it; for (const auto &amp;_it : G[it]) if (--in[_it] == 0) que.push(_it); &#125; if (nowAt != pos + 26)puts("Impossible"); else for (int i = 0; i &lt; 26; i++)putchar(pos[i] + 'a'); putchar('\n'); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF920E]]></title>
    <url>%2F2018%2F08%2F24%2FCF920E_Connected_Components%2F</url>
    <content type="text"><![CDATA[题目大意：给定一张无向图 $ G $ , 求 $ G $ 的补图的连通块的个数。 这里补图就是完全图 $ K $ 去掉所有 $ G $ 中的连边，也就是断掉所有原本连着的两个点，连上所有原本没有连接的两个点。记 $G$ 的补图为 $T$ 。如果点 $s$ 和点 $t$ 处于同一个连通块中，那么一定有一条路径可以从 $s$ 到 $t$ ,所有满足上述条件的 $s$ 和 $t$ 点的集合称为一个连通块。 我们先将所有的边读入进来，假定一开始所有的点都不属于任何一个连通块，然后将所有的点扫一遍，如果发现一个点 $s$ 不属于任何一个连通块，以 $s$ 为起点广度优先搜索，枚举一下点 $t$ ，如果 $s$ 和 $t$ 在 $G$ 中没有连边，就将 $t$ 加入队列中，与此同时记录一下当前连通块的大小。这么做是正确的，除了这个补图有点非同寻常以外几乎与正常地求连通块没有区别，但是，这么做每一次枚举 $t$ 都要尝试所有可能的点，时间复杂度高达 $O(N^2)$，难以承受。 BFS代码如下，我们可以以这个为模型考虑优化的方案。 123456789101112131415int _count(const int &amp;start) &#123; queue&lt;int&gt; que; que.push(start); vis[start] = true; int nowAt, _cnt = 1, i; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); sort(G[nowAt].begin(), G[nowAt].end()); for (int to = i = 0; to &lt; totPoints; to++) &#123; if (i &lt; G[nowAt].size() &amp;&amp; to == G[nowAt][i]) &#123; i++; continue; &#125; if (!vis[to]) &#123; vis[to] = true; que.push(to); _cnt++; &#125; &#125; &#125; return _cnt;&#125; 时间超出限制的根本原因就是枚举 $t$ 的时候浪费了大量的计算能力，事实上，大部分的 $t$ 都已经属于其它的连通块了，因此永远不可能用得上，能不能不枚举这些点呢？其实是可以的，如果发现了一个 $t$ 可以加入当前的连通块，我们将其删掉就可以了，这可以用一种数据结构在 $O(1)$ 的时间复杂度内完成这一操作。 套上了链表，我们还可以用一个集合 $S$ 保存图 $G$ 中所有的连边，最后判断一下如果 $s \to t$ 这条边不在集合 $S$ 中，说明这是一个合法的 $t$. AC代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;//链表----------------------------struct Node &#123; int val; Node *nxt; void DeleteNext() &#123; if (this-&gt;nxt == nullptr)return; Node *it = this-&gt;nxt; this-&gt;nxt = it-&gt;nxt; it = nullptr; &#125;&#125;*frnt = nullptr;Node* newNode() &#123; Node* ext = (Node*)malloc(sizeof(Node)); ext-&gt;nxt = nullptr; return ext;&#125;void build(size_t siz) &#123; //在一开始，所有的点都在链表中 frnt = newNode(); frnt-&gt;val = 0; Node *it = frnt, *ext; for (int i = 1; i &lt; siz; i++) &#123; ext = newNode(); ext-&gt;val = i; it-&gt;nxt = ext; it = ext; &#125;&#125;//-------------------------------------#define MAXPOINTS 200005vector&lt;int&gt; cnt; //每一个连通块包含的点的个数int totPoints, totEdges;bool vis[MAXPOINTS];struct Edge &#123; int fr, to; bool operator &lt; (Edge comp) const &#123; return fr == comp.fr ? to &lt; comp.to : fr &lt; comp.fr; &#125;&#125;;set&lt;Edge&gt; G; //图Gint _count(const int &amp;start) &#123;//广搜 queue&lt;int&gt; que; que.push(start); int nowAt, _cnt = 1; while (!que.empty()) &#123; nowAt = que.front(); que.pop(); for (Node *it = frnt; it != nullptr &amp;&amp; it-&gt;nxt != nullptr;) &#123;//我也不知道这里到底循环了多少次 if (vis[it-&gt;nxt-&gt;val]) &#123; it-&gt;DeleteNext(); continue; &#125; if (G.count(&#123; nowAt,it-&gt;nxt-&gt;val &#125;) || it-&gt;nxt-&gt;val == nowAt) &#123; it = it-&gt;nxt; continue; &#125; vis[it-&gt;nxt-&gt;val] = true; _cnt++; que.push(it-&gt;nxt-&gt;val); it-&gt;DeleteNext(); &#125; &#125; return _cnt;&#125;int main()&#123; memset(vis, false, sizeof(vis)); int a, b; cin &gt;&gt; totPoints &gt;&gt; totEdges; for (int i = 0; i &lt; totEdges; i++) &#123; scanf("%d%d", &amp;a, &amp;b); --a; --b; G.insert(&#123; a,b &#125;); G.insert(&#123; b,a &#125;); &#125; build(totPoints); for (Node* it = frnt; it != nullptr; it = it-&gt;nxt) &#123; if (vis[it-&gt;val])continue; vis[it-&gt;val] = true; cnt.push_back(_count(it-&gt;val)); &#125; cout &lt;&lt; cnt.size() &lt;&lt; endl; sort(cnt.begin(), cnt.end());//输出时要是排好序了的 for (const auto &amp;it : cnt) printf("%d ", it); putchar('\n'); //system("pause"); return 0;&#125; 其实，如果去掉链表的部分不看，代码还是非常直观的 有了链表的优化可以将所有枚举将为 $N$ 次，由于每次判断是否在集合中为 $O(logN)$ ，所以时间复杂度为 $O$(玄学) $O(NlogN)$ ?]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF437C]]></title>
    <url>%2F2018%2F08%2F23%2FCF437C%20The%20Child%20and%20Toy%20%2F</url>
    <content type="text"><![CDATA[由于删除的顺序不同，每个点会为我们带来不同的代价。 但是无论我们按照什么顺序删除，我们每删除掉一个点，这个点的所有连边都会消失，如果从边的角度考虑，删除每一条边的代价最小是这条边所连两个点中价值最小的，所以可以贪心进行求解，时间复杂度为 $O(N)$. 代码如下： 12345678910111213141516171819202122232425using System;namespace CF437C&#123; class Program &#123; static void Main(string[] args) &#123; string[] inp &#x3D; Console.ReadLine().Split(&#39; &#39;); int totPoints &#x3D; Convert.ToInt32(inp[0]), totEdges &#x3D; Convert.ToInt32(inp[1]), a, b; int[] w &#x3D; new int[totPoints]; inp &#x3D; Console.ReadLine().Split(&#39; &#39;); for(int i &#x3D; 0;i &lt; totPoints;i++) w[i] &#x3D; Convert.ToInt32(inp[i]); Int64 cnt &#x3D; 0; for(int i &#x3D; 0;i &lt; totEdges;i++) &#123; inp &#x3D; Console.ReadLine().Split(&#39; &#39;); cnt +&#x3D; Math.Min(w[Convert.ToInt32(inp[0]) - 1], w[Convert.ToInt32(inp[1]) - 1]); &#125; Console.WriteLine(cnt.ToString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无向图的点-双连通分量]]></title>
    <url>%2F2018%2F08%2F23%2F%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E7%82%B9-%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940#define MAXN 200000struct Edge &#123; int fr, to;&#125;;int pre[MAXN], bccNo[MAXN], dfs_clock, bcc_cnt;vector&lt;int&gt; G[MAXN], bcc[MAXN];stack&lt;Edge&gt; S;int dfs(int nowAt, int fa) &#123; int lowU = pre[nowAt] = dfs_clock++, lowV; for (const auto &amp;v : G[nowAt]) &#123; if (pre[v] == -1) &#123; S.push(&#123; nowAt,v &#125;); lowV = dfs(v, nowAt); if (lowV &gt; pre[nowAt]) &#123; //New BCC bcc[bcc_cnt].clear(); while (true) &#123; Edge it = S.top(); S.pop(); if (bccNo[it.fr] != bcc_cnt) &#123; bccNo[it.fr] = bcc_cnt; bcc[bcc_cnt].push_back(it.fr); &#125; if (bccNo[it.to] != bcc_cnt) &#123; bccNo[it.to] = bcc_cnt; bcc[bcc_cnt].push_back(it.to); &#125; if (it.to == v &amp;&amp; it.fr == nowAt)break; &#125;bcc_cnt++; &#125; &#125; else if (pre[v] &lt; pre[nowAt]) &#123; S.push(&#123; nowAt,v &#125;); lowU = min(lowU, pre[v]); &#125; &#125; return lowU;&#125;void Find_BCC(int n) &#123; memset(pre, -1, sizeof(pre)); memset(bcc, -1, sizeof(bcc)); dfs_clock = bcc_cnt = 0; for (int i = 0; i &lt; n; i++) dfs(i, -1);&#125; 与求割顶类似，找到一个割顶代表发现一个BCC，栈中存边,原因是点-双联通分量中会出现同一个点属于很多个BCC.(比如割顶)]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1025D]]></title>
    <url>%2F2018%2F08%2F22%2FCF1025D%20Recovering%20BST%2F</url>
    <content type="text"><![CDATA[题目大意：给定一颗二叉搜索树的中序遍历，已知此二叉搜索树所有有连边的两个节点最大公约数都大于 $1$ ,问能否构造出一颗满足条件的二叉搜索树。 开两个二维数组 $lft_{i,j}$ 代表区间 $[i,j]$ 能否构造出以 $j$ 为根的搜索树。类似地，二维数组 $rgt_{i,j}$ 代表区间 $[i,j]$ 能否构造出以 $i$ 为根的搜索树。 由于题目中给定的是中序遍历，所以原搜索树中任何一个子树都是给定数组 $a$ 的一段连续区间，而且无论是 $lft$ 还是 $rgt$ 代表的都是能否构造出一个根只有一个儿子的子树。可见，如果存在一个节点 $k$ 同时满足 $lft_{i,k}$ 和 $rgt_{k,j}$ 那么就是说可以构造出来一颗以 $k$ 为根而且有两个儿子的搜索树，我们可以用这个来转移。如果 $k$ 能够成为子树的根，那么我们再来判断一下 $k$ 能否与 $i-1, j+1$ 连边，推导出 $k$ 可能的父节点，也就是 $lft_{i-1,l}$ 和 $rgt_{i,l+1}$.由于题目没有要求将构造的搜索树输出，所以转移完之后 $k$ 就不重要了，下一步要考虑的根应该是 $i-1$ 和 $l+1$. 如果在某一时刻发现可以以 $k$ 为根，构造出区间 $[1,n]$ 的搜索树。也就是 $i=1,j=n$ ，那么要求的答案就是 Yes,如果执行完了全部循环，说明找不到符合条件的搜索树，答案为 No. 12345678910111213141516171819202122232425262728293031323334353637using System;namespace CF1025D &#123; class Program &#123; static void Main(string[] args) &#123; int totNodes &#x3D; Convert.ToInt32(Console.ReadLine()); string[] inp &#x3D; Console.ReadLine().Split(&#39; &#39;); int[] num &#x3D; new int[totNodes]; bool[,] lft &#x3D; new bool[totNodes, totNodes], rgt &#x3D; new bool[totNodes, totNodes]; for(int i &#x3D; 0;i &lt; totNodes;i++) &#123; num[i] &#x3D; Convert.ToInt32(inp[i]); lft[i, i] &#x3D; true;rgt[i, i] &#x3D; true; &#125; for(int fr &#x3D; totNodes - 1;fr &gt;&#x3D; 0;fr--) for(int to &#x3D; fr;to &lt; totNodes;to++) for(int root &#x3D; fr;root &lt;&#x3D; to;root++) if(lft[fr, root] &amp;&amp; rgt[root, to]) &#123; if(fr &#x3D;&#x3D; 0 &amp;&amp; to &#x3D;&#x3D; totNodes - 1) &#123; Console.WriteLine(&quot;Yes&quot;);return; &#125; if(fr &gt; 0 &amp;&amp; gcd(num[root], num[fr - 1]) &gt; 1) rgt[fr - 1, to] &#x3D; true; if(to &lt; totNodes - 1 &amp;&amp; gcd(num[root], num[to + 1]) &gt; 1) lft[fr, to + 1] &#x3D; true; &#125; Console.WriteLine(&quot;No&quot;); &#125; static int gcd(int a,int b) &#123; return b &#x3D;&#x3D; 0 ? a : gcd(b, a % b); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1027C]]></title>
    <url>%2F2018%2F08%2F21%2FCF1027C%20Minimum%20Value%20Rectangle%2F</url>
    <content type="text"><![CDATA[题目大意：给你 $n$ ($4 \leq n \leq 10^6$) 根木棍，不允许拼接或折断，选择四根组成矩形，求所有合法矩形中周长平方与面积比最小的一个，输出拼成这个矩形的四根木棍。具体的数据范围见英文题面。 这题巧妙至极，看数据范围就很容易想到这题很有可能是一个贪心。 我们记一个矩形周长为 $C$ ，面积为 $S$ . 记 $P = \frac{C^2}{S}$ . 正式贪心之前，先证明一个引理： 引理：$\forall$ 两个合法矩形 $A$ 和 $B$ ，如果它们拥有同等的宽，且 $A$ 的长小于 $B$ 的长，那么 $P_A \leq P_B$ .证明： 假设矩形 $A,B$ 宽为 $a$ ,$A$ 的长为 $b$ ,$B$ 的长为 $b+b_1$ .且 $a,b,b_1 \in R^+$ . 则需证明 \forall a,b,b_1. P_A - P_B \ge 0代入数据，也就是 $$ \frac{[2a+2(b+b_1)]^2}{ab+ab_1} - \frac{(2a+2b)^2}{ab} \ge 0$$ 显而易见，分母大于0，乘上 $ab(ab+ab_1)$ 不会改变这个不等式. 4a^3b+4ab^3+4abb_1^2+8ab^2b_1+8a^2b^2+8a^2bb_1-4a^3b-4ab^3-8a^2b^2-4a^3b_1-4ab^2b_1-8a^2bb_1 \ge 0整理得 4abb_1^2 + 4ab^2b_1 - 4a^3b_1 \ge 0没有了同类项，式子的正确性变得不那么显然了，我们一项项分析。$4abb_1^2$ 一定大于0，而且可以判断出 $4ab^2b_1 - 4a^3b_1 \ge 0$ . 理由如下： 因式分解得 4ab^2b_1 - 4a^3b_1 = 4ab_1(b^{2} - a^{2}) = 4ab_1(a+b)(b-a)$\because 4ab_1 , (a+b) \ge 0 $，由于 $b$ 为长，$\therefore b-a \ge 0$ . $\therefore 4ab^2b_1 - 4a^3b_1 \ge 0$ . $\therefore P_A \leq P_B$ . 证毕。 实现由引理可知，$\forall$ 矩形的宽$a$ ，能使这个矩形 $P$ 值最小的必定是一个最小的 $b$ 满足 $b \ge a$. 将木棍配对，假设最终可用的木棍为 $m$ ,每一对木棍的长度分别为 $a_i$ ,那么我们只用扫一遍，找到一组 $P$ 值最小的 $a_i$ 和 $a_{i+1}$ 即可。 由于任何一个木棍长度都不会超过 $10^4$ ,所以我们可以开一个一维数组，读入的同时桶排序，如果发现超过两个就放一对木棍进入 $b$ 数组，如果超过四个就再放一对。这样就自动过滤掉了多余的无用木棍。完成这一步后需要对 $b$ 数组进行排序。 这一步结束后，我们应该有一个数组 $b$ ,$b_i$ 代表第 $i$ 对木棍长度。前面提到过，$b$ 中元素个数为 $m$. 最后就扫一遍就完了，按照公式 $O(1)$ 算出 $P$ 值，$O(M)$ 结束整个过程。 对于每一组数据，时间复杂度为 $O(N\log{N}+M)$. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Collections;namespace CF1027C &#123; class Program &#123; public class Global &#123; public static int[] len; public static ArrayList arr; public static void RestoreAll() &#123; arr &#x3D; null;len &#x3D; null; len &#x3D; new int[10005];arr &#x3D; new ArrayList &#123; &#125;; &#125; &#125; static void Main(string[] args) &#123; string[] inp; int totCases &#x3D; Convert.ToInt32(Console.ReadLine()), totNums, a, b; decimal _minVal; while(totCases--&gt;0) &#123; totNums &#x3D; Convert.ToInt32(Console.ReadLine()); Global.RestoreAll();inp &#x3D; Console.ReadLine().Split(&#39; &#39;); for(int i &#x3D; 0;i &lt; totNums;i++) &#123; a &#x3D; Convert.ToInt32(inp[i]); Global.len[a]++; if(Global.len[a] &#x3D;&#x3D; 2 || Global.len[a] &#x3D;&#x3D; 4) Global.arr.Add(a); &#125;Global.arr.Sort(); a &#x3D; (int)Global.arr[0];b &#x3D; (int)Global.arr[1];_minVal &#x3D; Solve(1); for(int i &#x3D; 2;i &lt; Global.arr.Count;i++) if(Solve(i) &lt; _minVal) &#123; _minVal &#x3D; Solve(i); a &#x3D; (int)Global.arr[i - 1];b &#x3D; (int)Global.arr[i]; &#125; Console.WriteLine(a.ToString() + &quot; &quot; + a.ToString() + &quot; &quot; + b.ToString() + &quot; &quot; + b.ToString()); &#125; &#125; static decimal Solve(int pos) &#123; return ((decimal)(((int)Global.arr[pos] + (int)Global.arr[pos - 1]) &lt;&lt; 1) * (((int)Global.arr[pos] + (int)Global.arr[pos - 1]) &lt;&lt; 1)) &#x2F; (decimal)((int)Global.arr[pos] * (int)Global.arr[pos - 1]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1027D]]></title>
    <url>%2F2018%2F08%2F19%2FCF1027D%20Mouse%20Hunt%2F</url>
    <content type="text"><![CDATA[题目大意：有一只老鼠在女生宿舍的某一个房间中，女生们希望抓住它，现在我们知道了如果老鼠第 $i$ 秒在房间 $s$ 中，那么到了第 $i+1$ 秒它将到达 $next_i$ 号房间，此过程中不经过任何其它的房间，房间编号从 $1$ 到 $n$ .我们不知道一开始老鼠在哪个房间中，但是可以花费 $cost_i$ 的代价在 $i$ 号房间布置陷阱。布置的陷阱需要满足无论老鼠一开始在那个房间中，最后都会落入陷阱，在此基础之上，要求这个尽可能少的代价 $\sum cost_i$ . 我们将老鼠走的路径抽离出来，发现有三种情况： 老鼠从一个房间 $s$ 出发，走过一条链，到达一个房间 $t$ 满足 $next_t = t$ ,此后一直停留在 $t$. 老鼠从一个房间 $s$ 出发，走过一个环，又回到 $s$ ,此后一直这样循环。 老鼠从一个房间 $s$ 出发，先走过一条链到达 $t$ 这时进入一个环，走了若干步又回到 $t$ ,如此循环。 对于不同的情况，很好设计对策： 唯一的方法是在 $t$ 布置陷阱，在其它地方布置只可能花费更高的代价。 在环中选择一个代价最小的房间布置陷阱。 同2，链接这个环的链可以去掉不看。 这样，无论老鼠一开始在哪个房间，都会最终落入陷阱当中，实现可以依靠暴力。从一个点 $s$ 不停地往下走，我们将这称作第 $s$ 次模拟，同时记录一个数组 $vis_i$ 代表 $i$ 号房间是在哪一次模拟当中经过的，每到达一个房间就将这个房间的 $vis$ 赋值为 $s$ .如果遇到了一个房间 $j$ 满足 $vis_j &lt; s$ 证明这条路走下去一定有一个陷阱(在此之前布置的)，直接 break 掉。如果到达一个房间 $j$ 满足 $next_j = j$ 对应情况1，在$j$ 布置陷阱。如果到达一个房间 $j$ 满足 $vis_j = s$ 对应情况 2 或 3，从这里开始将整个环遍历一遍，找出一个最小值。 由于每一个点我们只赋了一次 $vis$ ，以后看到它就直接停止走下去了，算上判环每个点 经过至多2次，时间复杂度为 $O(N)$. 具体的实现细节见代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 200050int nxt[MAXN], cost[MAXN];int vis[MAXN];int getMin(int start) &#123; int _min = cost[start]; for (int i = nxt[start];; i = nxt[i]) &#123; if (i == start)return _min; else _min = min(_min, cost[i]); &#125;&#125;int main()&#123; memset(vis, false, sizeof(vis)); int totRooms, _min; long long _count = 0; cin &gt;&gt; totRooms; for (int i = 0; i &lt; totRooms; i++)scanf("%d", cost + i); for (int i = 0; i &lt; totRooms; i++) &#123; cin &gt;&gt; nxt[i]; nxt[i]--; if (nxt[i] == i) &#123; vis[i] = -1; _count += cost[i]; &#125; &#125; for (int start = 0; start &lt; totRooms; start++) &#123; if (vis[start] != 0)continue; _min = cost[start]; for (int i = start;; i = nxt[i]) &#123; if (vis[i] != 0) &#123; if (vis[i] == start + 1)_count += getMin(i); break; &#125; vis[i] = start + 1; _min = min(_min, cost[i]); &#125; &#125; cout &lt;&lt; _count &lt;&lt; endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF407B]]></title>
    <url>%2F2018%2F08%2F19%2FCF407B%20Long%20Path%2F</url>
    <content type="text"><![CDATA[首先，我们可以发现一个很有用的信息，就是到达一个房间 $i$ 之后如果不能够直接走向 $i + 1$ (奇数次到达 $i$ ) ，那么之后我们只能够去一个拥有比 $i$ 小的 序号的房间，这为我们提供了动态规划的思路。 我们先开一个二维数组 $Dp$ , $Dp_{i,j}$ 代表从 $i$ 号房间走到 $j$ 号房间需要经过的门的数量，$Dp$ 仅当 $i \leq j$ 时才有意义。如果房间从 1 开始编号，那么答案就是 $Dp_{1,n + 1} - 1$ ，边界条件为 $Dp_{i,i} = 1$. 到这里可能有人会有疑问：这两个1是怎么来的。 事实上，$Dp_{i,i} = 1$ 代表从 $i$ 号房间走到 $i$ 号房间，而并不是呆在原地不动，这也是为什么后面的答案算出来也需要减去1的原因。 第一次到达 $i | i &gt; 1$ 之前，一定到达了 $i - 1$ 号房间正好 2 次。证明：第一次到达 $i$ 号房间之前，一定没有到达过$ i + 1 $。 当第一个达到 $i$ 的时候，走向一个房间 $j$ ,而且 $j \leq i$ ,我们再经过一连串的房间，它们都小于 $i + 1$ ,直到第二次到达 $i$ ，才可以径直走向 $i + 1$. 按照这个逻辑，转移方程如下： $$ Dp_{fr,to} = Dp_{fr,to - 1} + Dp_{next_{to - 1}, to-1} + 1 $$ 有了转移方程，但是由于我太垃圾了看不出来计算顺序，所以我们可以使用记忆化搜索，$Dp_{fr,to}$ 通过以下的函数得到。 1234567static Int64 Solve(int fr,int to) &#123; if(fr &#x3D;&#x3D; to) return Global.Dp[fr, to] &#x3D; 1; if(Global.vis[fr, to]) return Global.Dp[fr, to]; else &#123; Global.vis[fr, to] &#x3D; true;Global.Dp[fr, to] &#x3D; 0; &#125; return (Global.Dp[fr, to] &#x3D; (Solve(fr, to - 1) + Solve(Global.nxt[to - 1], to - 1) + 1) % 1000000007);&#125; 在这份代码中 Global 是全局函数类名， $vis_{i,j}$ 代表有没有计算过，当然也可以用 $Dp_{i,j} = -1$ 达到相同的效果。 时空复杂度为 $O(N^2)$ ，但是由于有些状态搜索不到，所以应该实际上比这个小一些？ 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536using System;namespace CF407B&#123; class Program &#123; public class Global &#123; public static Int64[,] Dp; public static int[] nxt; public static bool[,] vis; &#125; static void Main(string[] args) &#123; int totRooms &#x3D; Convert.ToInt32(Console.ReadLine()); string[] div &#x3D; Console.ReadLine().Split(&#39; &#39;); Global.nxt &#x3D; new int[totRooms]; for(int i &#x3D; 0; i &lt; totRooms; i++) Global.nxt[i] &#x3D; Convert.ToInt32(div[i]) - 1; Global.Dp &#x3D; new Int64[totRooms + 1, totRooms + 1]; Global.vis &#x3D; new bool[totRooms + 1, totRooms + 1]; for(int i &#x3D; 0; i &lt;&#x3D; totRooms; i++) for(int j &#x3D; 0; j &lt;&#x3D; totRooms; j++) Global.vis[i, j] &#x3D; false; Console.WriteLine((Solve(0, totRooms) - 1).ToString()); &#125; static Int64 Solve(int fr,int to) &#123; if(fr &#x3D;&#x3D; to) return Global.Dp[fr, to] &#x3D; 1; if(Global.vis[fr, to]) return Global.Dp[fr, to]; else &#123; Global.vis[fr, to] &#x3D; true;Global.Dp[fr, to] &#x3D; 0; &#125; return (Global.Dp[fr, to] &#x3D; (Solve(fr, to - 1) + Solve(Global.nxt[to - 1], to - 1) + 1) % 1000000007); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1023C]]></title>
    <url>%2F2018%2F08%2F18%2FCF1023C%2F</url>
    <content type="text"><![CDATA[题目大意：给你一个正则括号序列 $s$ ,让你在当中选择一个长度正好为 $t$ 的子串，使得 $t$ 恰好也是一个正则括号序列。 由于我们已经知道了 $s$ 是合法的，所以 $s$ 中的东西我们能用则用，将 $s$ 扫一遍，记录一下当前处于括号的哪一层（也就是前面有多少个’(‘没有’)’与之对应）。如果当前 $s$ 中字符为 ‘(‘而且长度没有达到需要的一半，就将它加入 $t$ 中。如果是 ‘)’,则当前层数减一(如果不在最外层），加入 $t$ 中。 代码如下： 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;string a, b;int main()&#123; int totLen, need; cin &gt;&gt; totLen &gt;&gt; need &gt;&gt; a; need &gt;&gt;= 1; int cnt = 0; for (int i = 0; i &lt; totLen; i++) &#123; if (a[i] == '(' &amp;&amp; need &gt; 0) &#123; need--; b += '('; cnt++; &#125; if (a[i] == ')'&amp;&amp;cnt &gt; 0) &#123; b += ')'; cnt--; &#125; &#125; cout &lt;&lt; b &lt;&lt; endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF176B]]></title>
    <url>%2F2018%2F08%2F18%2FCF176B%2F</url>
    <content type="text"><![CDATA[题目大致意思：给你两个字符串 $s$ 和 $t$ ,你一次操作可以将 $s$ 分为两部分，交换这两部分的位置，你要恰好执行 $k$ 次这样的操作，使得 $s$ 变为 $t$ ,有多少种不同的方法？只要中间有一步不同就视为两种不同的方法。 首先，我们需要知道这个所谓的操作是不会从根本上打乱串 $s$ 的，如果将 $s$ 看成是一个字符首尾相连圆圈，那么执行一次这样的操作就是将这个圆圈旋转了一下，并没有打乱字符之间的位置关系。 如果 $s$ 与 $t$ 的长度不想等，那么答案就是0，在这里我们假设它们长度一样。 首先，我们先找一下有多少个点 $k$ ，在这里切开 $s$ 之后可以得到 $t$ ，记这些点的总数量为 $cnt$ .这一步如果暴力匹配，时间复杂度最坏可能逼近 $O(N^2)$ ，但是应对大部分数据已经足够。当然，应该也可以用 KMP, 将 $s$ 与 $s + s$ 匹配一下，时间复杂度可以降到 $O(N \times 2)$ .保险起见我没有这么做。 之后开始递推，假设 $D[i]$ 是 执行了 $i$ 次操作之后的情况，$D[i,0]$ 代表与 $t$ 相等的方案数，$D[i,1]$ 代表与 $t$ 不等的方案数，那么转移如下： 12D[now, 0] &#x3D; (D[last, 0] * (cutPoints - 1) % mod + D[last, 1] * cutPoints % mod) % mod;D[now, 1] &#x3D; (D[last, 0] * (len - cutPoints) % mod + D[last, 1] * (len - cutPoints - 1) % mod) % mod; 与 $t$ 相同，可以由上一步已经相同的选择一个未被选择的点 $k$ ，也可以由上一步不一样的任意选择一个 $k$ 得到。 与 $t$ 不同，可以由上一步已经相同的选择一个不是 $k$ 的点，也可以由上一步不一样的任意选择一个不是 $k$ 的点得到 最终的答案，就是 1D[totOptns, 0] %&#x3D; mod; 由于每一次转移只使用到了上一次的值，所以 $D$ 数组可以滚动，空间复杂度为 $O(1)$ . 完整的程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Collections;namespace CF176B&#123; class Program &#123; public class Global &#123; public static string fr, to; &#125; static void Main(string[] args) &#123; Global.fr &#x3D; Console.ReadLine();Global.to &#x3D; Console.ReadLine(); if(Global.fr.Length !&#x3D; Global.to.Length) &#123; Console.WriteLine(&quot;0&quot;);return; &#125; int totChanges &#x3D; Convert.ToInt32(Console.ReadLine()), mod &#x3D; 1000000007; Int64[,] D; D &#x3D; new Int64[2, 2]; int now &#x3D; 0, last &#x3D; 1, cutPoints &#x3D; Solve(), len &#x3D; Global.to.Length; if(Global.fr &#x3D;&#x3D; Global.to) &#123; D[now, 0] &#x3D; 1; D[now, 1] &#x3D; 0; &#125; else &#123; D[now, 0] &#x3D; 0; D[now, 1] &#x3D; 1;&#125; for(int i &#x3D; 0; i &lt; totChanges; i++) &#123; now ^&#x3D; last;last ^&#x3D; now;now ^&#x3D; last; D[now, 0] &#x3D; (D[last, 0] * (cutPoints - 1) % mod + D[last, 1] * cutPoints % mod) % mod; D[now, 1] &#x3D; (D[last, 0] * (len - cutPoints) % mod + D[last, 1] * (len - cutPoints - 1) % mod) % mod; &#125; D[now, 0] %&#x3D; mod; Console.WriteLine(D[now, 0].ToString()); &#125; static int Solve() &#123; int cnt &#x3D; 0; for(int i &#x3D; 0; i &lt; Global.fr.Length; i++) if(Solve(i)) &#123; cnt++; &#125; return cnt; &#125; static bool Solve(int Pos) &#123; for(int i &#x3D; Pos; i &lt; Global.fr.Length; i++) if(Global.fr[i] !&#x3D; Global.to[i - Pos]) return false; for(int i &#x3D; 0; i &lt; Pos; i++) if(Global.fr[i] !&#x3D; Global.to[i + Global.to.Length - Pos]) return false; return true; &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF735C]]></title>
    <url>%2F2018%2F08%2F17%2FCF735C%2F</url>
    <content type="text"><![CDATA[这又是一道很有意思的CF题目。 题目大致意思是要我们安排一次有 $n$ 名参赛者参与的竞赛，在满足每场对决中的两名参赛者此前参加的比赛相差不超过1的前提下尽可能让竞赛的总场次多，要求这个最多的场次数量。 假设 $f(x) = $ 安排 $x$ 场比赛所需要的最少参赛者，那么题目要我们求的，就是一个最大的 $j$ 满足 $f(j) \leq n$ .所以我们需要解决的就是 $f$ 函数。 可以确定的是全部比赛结束之后只有1名参赛者，而且决赛是这名参赛者与亚军的对决，如果我们将规模缩小，$f$ 函数对应安排应该是与下图很像的。 即，尽可能让两位已经参加场数相差为1的参赛者对决，按照这个逻辑，冠军和亚军在决赛之前参加的比赛场数应该分别为 $n-1$ 和 $n - 2$ ，而图中的这两个子树分别对应着 $f(n-1)$ 和 $f(n-2)$ 名参赛者，也就是说 $f(n) = f(n-1) + f(n-2)$ . 这样我们就可以递推 $f$ 函数了，边界条件为 $f(0) = f(-1) = 1$ . AC代码如下： 123456789101112131415161718192021using System;namespace CF767E&#123; class Program &#123; static void Main(string[] args) &#123; Int64 a &#x3D; 1, b &#x3D; 1, ans &#x3D; 0, max &#x3D; Convert.ToInt64(Console.ReadLine()); for(int i &#x3D; 1; true; i++) &#123; ans &#x3D; a + b; if(ans &gt; max) &#123; Console.WriteLine((i - 1).ToString()); return; &#125; a &#x3D; b;b &#x3D; ans; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1019C]]></title>
    <url>%2F2018%2F08%2F15%2FCF1019C%2F</url>
    <content type="text"><![CDATA[这题除了保存需要用到一下邻接表以外，几乎没什么是和图论有关的。就是一个纯模拟。 题目大致的意思是，在一个有向图 $G$ 中找到一个点集 $S$ 。满足： 点集中不能有两点之间有边相连。 从 $S$ 中的点出发，2步之内可以到达 $G$ 中任何一个点。 算法分为两步： 先开两个布尔数组 $vis_i$ 代表点 $i$ 有没有被访问过。 $cse_i$ 代表选不选点 $i$ 。 从小到大将所有的点扫一遍，如果没有访问过( $vis_i==true$ )就同时标记 $vis_i$ 和 $cse_i$ 为真，并将所有的 $vis_j$ 标记为假。(如果从 $i$ 出发能够直接到达 $j$ ) 从大到小将所有的点扫一遍，如果这个点已经被选( $cse_i==true$ ),将所有 $cse_j$ 标记为假。(如果从 $i$ 出发能够直接到达 $j$ ) 最后再扫一遍所有的点，这时 $cse_i$ 就是点 $i$ 最终是否被选择的情况了。 这个算法为什么是正确的？ 假设每条边长度都是1. 首先我们可以确定的是，执行步骤1之后满足条件2，因为如果存在一个点离 $S$ 中最近的点 $t$ 距离超过2，那么他们中间一定间隔了至少2个点，而这两个点中有一个是一定可选的，如果不可选，那么这个点离 $S$ 中最近的点一定不是 $t$, 而是另外一个距离为2的点。 事实上，我们祟随便列举一些数据就可以知道，由于我们在选择一个点之后只标记这个点距离为1的说有点不可选，所以现在不仅满足条件2，而且条件2中的距离最大只可能是1. 但是，步骤1执行完成之后很可能不满足条件1，只要存在点 $s$ 和 $t$ 满足编号 $s&gt;t$, 而且有一条边从 $s$ 到 $t$. 这时可以发现，如果去掉了 $t$， 仍然是满足条件2的，这时的最大距离可能恰巧就为2了，但是仍然满足。而且去掉了所有不满足条件1的矛盾。 如果去掉 $s$ 会怎么样？这样有可能 $s$ 入度为0，不可能从任何一个 $S$ 中的点出发到达 $s$. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXPOINTS 1000005vector&lt;int&gt; G[MAXPOINTS], arr;bool vis[MAXPOINTS], book[MAXPOINTS];int main()&#123; int totNode, totEdge, a, b; cin &gt;&gt; totNode &gt;&gt; totEdge; for (int i = 0; i &lt; totEdge; i++) &#123; scanf("%d%d", &amp;a, &amp;b); G[--a].push_back(--b); &#125; memset(vis, false, sizeof(vis)); memset(book, false, sizeof(book)); for (int i = 0; i &lt; totNode; i++) if (!vis[i]) &#123; vis[i] = book[i] = true; for (const auto &amp;it : G[i]) vis[it] = true; &#125; for (int i = totNode - 1; i &gt;= 0; i--) if (book[i]) &#123; for (const auto &amp;it : G[i]) book[it] = false; &#125; for (int i = 0; i &lt; totNode; i++) if (book[i])arr.push_back(i + 1); cout &lt;&lt; arr.size() &lt;&lt; endl; for (const auto &amp;it : arr) printf("%d ", it); putchar('\n'); //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF940E]]></title>
    <url>%2F2018%2F08%2F15%2FCF940E%2F</url>
    <content type="text"><![CDATA[这题的题意可以转换为在数组上选择若干个没有交集的区间，去掉区间内最小的数，且每一个区间的长度都为 $c$ 的倍数。如果不为 $c$ 的倍数，去掉的数只可能更劣，这很好想，也很好证明。 所以，我们先预处理出一个数组 $que_i$ 代表如果一个区间的右端点恰好在 $i$ 这个位置，那么能够去掉的数字是多少，这项预处理如果使用单调队列优化，可以在 $O(N)$ 的时间复杂度内解决。 接下来动态规划部分求出一个数组 $Dp_i$ 代表序列前 $i$ 个数中去掉的数字之和最大是多少。这样一来转移就很好想了。这是一个线性动态规划，时间复杂度也是 $O(N)$, 答案在 $Dp_n$ 处。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Collections;namespace ConsoleApp1 &#123; class Program &#123; public class Node &#123; public Int64 Num &#123; get; set; &#125; public Int64 Pos &#123; get; set; &#125; &#125; static void Main(string[] args) &#123; string inp;string[] div; int totNums, k, frnt &#x3D; 0, tail &#x3D; 0; Int64[] num, D, que;Int64 tot &#x3D; 0; inp &#x3D; Console.ReadLine();div &#x3D; inp.Split(&#39; &#39;); totNums &#x3D; Convert.ToInt32(div[0]);k &#x3D; Convert.ToInt32(div[1]); inp &#x3D; Console.ReadLine();div &#x3D; inp.Split(&#39; &#39;); num &#x3D; new Int64[totNums];D &#x3D; new Int64[totNums];que &#x3D; new Int64[totNums]; for(int i &#x3D; 0; i &lt; totNums; i++) &#123; num[i] &#x3D; Convert.ToInt64(div[i]); tot +&#x3D; num[i]; &#125; Node[] arr &#x3D; new Node[totNums];Node inIt; for(int i &#x3D; 0; i &lt; k - 1 &amp;&amp; i &lt; totNums; i++) &#123; inIt &#x3D; new Node &#123; &#125;; inIt.Pos &#x3D; i; inIt.Num &#x3D; num[i]; while(frnt &lt; tail &amp;&amp; arr[tail - 1].Num &gt;&#x3D; inIt.Num) tail--; arr[tail++] &#x3D; inIt; &#125; for(int i &#x3D; k - 1; i &lt; totNums; i++) &#123; inIt &#x3D; new Node &#123; &#125;; inIt.Pos &#x3D; i;inIt.Num &#x3D; num[i]; while(frnt &lt; tail &amp;&amp; arr[frnt].Pos &lt;&#x3D; i - k) frnt++; while(frnt &lt; tail &amp;&amp; arr[tail - 1].Num &gt;&#x3D; inIt.Num) tail--; arr[tail++] &#x3D; inIt; que[i] &#x3D; arr[frnt].Num; &#125; D[0] &#x3D; que[0]; for(int i &#x3D; Math.Max(k - 1, 1); i &lt; totNums; i++) &#123; D[i] &#x3D; Math.Max(D[i - 1], que[i]); if(i - k &gt;&#x3D; 0) D[i] &#x3D; Math.Max(D[i], D[i - k] + que[i]); &#125; Console.WriteLine((tot - D[totNums - 1]).ToString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1015F]]></title>
    <url>%2F2018%2F08%2F14%2FCF1015F%2F</url>
    <content type="text"><![CDATA[从左往右加字符，弄个预处理搞一下。 这题分为两部分，首先我们预处理出来一个二维数组 $len$. 1public static int[,] len &#x3D; new int[s.Length + 1, 2]; $len$ 的第二维只可能是0或者1. $len_i,_j$ 代表 $s$ 取前i个字符，后面加上一个’(‘或者’)’之后组成一个新的字符串 $t$ , $t$ 的后缀最多能与 $s$ 的前缀匹配多少位。 假设 s = ‘())()’, 那么 $len_5,_1$ 就是 $s$ 取前5位再加上一个’)’ ，这时 $t$ = ‘())()), $t$ 的后缀最多能与 $s$ 的前缀匹配3位，所以 $len_5,_1 = 3$. 这一步可以暴力完成，时间复杂度不算太高。这是随后Dp的根据。 正式的Dp需要一个四维数组。 1public static int[,,,] Dp &#x3D; new int[(len &lt;&lt; 1) + 5, (len &lt;&lt; 1) + 5, s.Length + 5, 2]; 保险起见这里开的大了一点。具体含义是 $Dp_i,_j,_k,_p$ 代表搞一个长度为 $i$ 的串，这个串中左括号数量减去右括号数量为 $j$, 这个串的后缀与 $s$ 的前缀最长能够匹配 $k$ 位，这个串中是否已经出现过至少一次串 $s$（$p=0$代表没有，$p=1$反之）。数值为构成满足以上条件的串的方案数。 那么显而易见 $Dp_0,_0,_0,_0 = 1$, 除此之外 $Dp$ 数组中所有的值都是0. 这里的转移非常的暴力，准确地说这应该是递推而非动态规划。 123456789if(Global.Dp[i, j, k, fin] &#x3D;&#x3D; 0) continue;if(j &lt; len) &#123; Global.Dp[i + 1, j + 1, Global.len[k, 0], fin | (Global.len[k, 0] &#x3D;&#x3D; s.Length ? 1 : 0)] +&#x3D; Global.Dp[i, j, k, fin]; Global.Dp[i + 1, j + 1, Global.len[k, 0], fin | (Global.len[k, 0] &#x3D;&#x3D; s.Length ? 1 : 0)] %&#x3D; mod;&#125;if(j &gt; 0) &#123; Global.Dp[i + 1, j - 1, Global.len[k, 1], fin | (Global.len[k, 1] &#x3D;&#x3D; s.Length ? 1 : 0)] +&#x3D; Global.Dp[i, j, k, fin]; Global.Dp[i + 1, j - 1, Global.len[k, 1], fin | (Global.len[k, 1] &#x3D;&#x3D; s.Length ? 1 : 0)] %&#x3D; mod;&#125; 虽然写的复杂，但是其思路是非常直观的，枚举一下当前的状态，试着往后面加一个’(‘,试着往后面加一个’)’,更新一下。 前面 $i$ 和 $j$ 的变化很好想，第三维我们保存的是这个串的后缀与 $s$ 的前缀能够匹配的最大长度，加上了一个字符应该如何更新？这就是前面算的 $len$ 的作用。因为我们知道当前串后 $k$ 位和 $s$ 的前 $k$ 位是完全一样的，那么如果加上一个 ‘(‘ 后新的 $k$ 不就应该是 $len_k,_0$ 吗，加上 ‘)’ 则是 $len_k,_1$ 回顾 $len$ 的定义，会发现此处正好是这种情况。 Dp完了以后，还需要累加一下答案。所有 $Dp_2*_n,_0,_i,_1$ 都是符合题意的合法括号序列生成方案数，加起来就是答案。 完整的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System;namespace CF1015F&#123; class Program &#123; public class Global &#123; public static int[,] len; public static int[,,,] Dp; &#125; static void Main(string[] args) &#123; const int mod &#x3D; 1000000007; int len &#x3D; Convert.ToInt32(Console.ReadLine()); string s &#x3D; Console.ReadLine(), t &#x3D; &quot;&quot;; Global.len &#x3D; new int[s.Length + 1, 2]; Global.Dp &#x3D; new int[(len &lt;&lt; 1) + 5, (len &lt;&lt; 1) + 5, s.Length + 5, 2]; Global.Dp[0, 0, 0, 0] &#x3D; 1; if(s[0] &#x3D;&#x3D; &#39;(&#39;) Global.len[0, 0] &#x3D; 1; else Global.len[0, 1] &#x3D; 1; for(int i &#x3D; 0; i &lt; s.Length; i++) &#123; t +&#x3D; s[i];t +&#x3D; &#39;(&#39;; Global.len[i + 1, 0] &#x3D; Match(s, t); t &#x3D; t.Remove(t.Length - 1, 1); t +&#x3D; &#39;)&#39;; Global.len[i + 1, 1] &#x3D; Match(s, t); t &#x3D; t.Remove(t.Length - 1, 1); &#125; for(int i &#x3D; 0; i &lt; (len &lt;&lt; 1); i++) for(int j &#x3D; 0; j &lt;&#x3D; len; j++) for(int k &#x3D; 0; k &lt;&#x3D; s.Length; k++) for(int fin &#x3D; 0; fin &lt;&#x3D; 1; fin++) &#123; if(Global.Dp[i, j, k, fin] &#x3D;&#x3D; 0) continue; if(j &lt; len) &#123; Global.Dp[i + 1, j + 1, Global.len[k, 0], fin | (Global.len[k, 0] &#x3D;&#x3D; s.Length ? 1 : 0)] +&#x3D; Global.Dp[i, j, k, fin]; Global.Dp[i + 1, j + 1, Global.len[k, 0], fin | (Global.len[k, 0] &#x3D;&#x3D; s.Length ? 1 : 0)] %&#x3D; mod; &#125; if(j &gt; 0) &#123; Global.Dp[i + 1, j - 1, Global.len[k, 1], fin | (Global.len[k, 1] &#x3D;&#x3D; s.Length ? 1 : 0)] +&#x3D; Global.Dp[i, j, k, fin]; Global.Dp[i + 1, j - 1, Global.len[k, 1], fin | (Global.len[k, 1] &#x3D;&#x3D; s.Length ? 1 : 0)] %&#x3D; mod; &#125; &#125; int _count &#x3D; 0, final_Len &#x3D; len &lt;&lt; 1; for(int i &#x3D; 0; i &lt;&#x3D; s.Length; i++) &#123; _count +&#x3D; Global.Dp[final_Len, 0, i, 1]; _count %&#x3D; mod; &#125; Console.WriteLine(_count.ToString()); &#125; static int Match(string a,string t) &#123; for(int i &#x3D; Math.Min(t.Length, a.Length); i &gt; 0; i--) if(a.Substring(0, i) &#x3D;&#x3D; t.Substring(t.Length - i, i)) return i; return 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无向图的割顶和桥 模板]]></title>
    <url>%2F2018%2F08%2F13%2F%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%89%B2%E9%A1%B6%E5%92%8C%E6%A1%A5-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021#define MAXNPOINTS 1000#define MAXMROADS 5000int pre[MAXNPOINTS], low[MAXNPOINTS], dfs_clock;bool vis[MAXNPOINTS], isCutPoint[MAXNPOINTS], isCutRoad[MAXMROADS];vector&lt;int&gt; G[MAXNPOINTS];int dfs(const int nowAt, const int fa) &#123; int lowU = pre[nowAt] = dfs_clock++, child = 0, lowV; for (const auto &amp;it : G[nowAt]) &#123; if (!vis[it]) &#123; child++; lowV = dfs(it, nowAt); lowU = std::min(lowU, lowV); if (lowV &gt;= pre[nowAt])isCutPoint[nowAt] = true; if (lowV &gt; pre[nowAt])isCutRoad[roadID] = true; &#125; else if (it != fa &amp;&amp; pre[it] &lt; pre[nowAt]) lowU = std::min(lowU, pre[it]); &#125; if (fa &lt; 0 &amp;&amp; child == 1)isCutPoint[nowAt] = false; return low[nowAt] = lowU;&#125;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>割顶与桥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1019A]]></title>
    <url>%2F2018%2F08%2F12%2FCF1019A%2F</url>
    <content type="text"><![CDATA[这题乍一看好像是一道图论难题。 我在考试时的思考方向是从选民下手，这样很容易想到贪心，尽可能选需要金币少的，但是有可能你选择一个相对需要金币较多的人，拉低了敌对政党的总票数，这样有可能比选择两个人只提升自己的票数更划算，而且，我们很难知道某一位选民到底能对我们做出多大贡献，因为有可能有多个政党票数比联合党多，再加上每位选民需要的金币不同，题目就显得更加复杂了。 这时我看到我校某位大佬也没有做出来这道题，于是就放弃了。 正确的思路应该是从政党入手。我们假设一个最终的结局，联合党的票数一定是最多的，所以我们只用枚举一下票数第二的政党获得的选票数量 $i$ ，随后的贪心就非常好想了。 首先，对于所有选票数大于 $i$ 的政党，我们必须从中拉一部分选民，先让这些政党票数都变为 $i$. 之后，有可能联合党票数还是少于 $i$, 这种情况下就可以用之前的贪心，每次尽可能选择需要金币最少的选民，将票数累加之 $i+1$ 即可。 可以发现如果联合党获得一半以上的选票就可以立即成为执政党，所以枚举 $i$ 的范围并不会很大。时间复杂度 $O(N^2)$. 另外还需要注意一下细节，判断一下选民是否已经被我们拉过票，否则有可能从一位选民手上拉两张选票导致错误。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;struct Voter &#123; int ID, needCoin; bool operator () (Voter a, Voter comp)const &#123; return a.needCoin &lt; comp.needCoin; &#125;&#125;;vector&lt;Voter&gt; partyVote[3001];vector&lt;Voter&gt; que;bool vis[3001]; int Rank[3001];int main()&#123; int totVoter, totParty, voteTarg, $; int votesGet = 0, nowVotes, siz = 0, Left; long long _min = 9223372036854775807LL, _count; cin &gt;&gt; totVoter &gt;&gt; totParty; for (int i = 0; i &lt; totVoter; i++) &#123; cin &gt;&gt; voteTarg &gt;&gt; $; if (--voteTarg == 0)votesGet++; else &#123; partyVote[voteTarg].push_back(&#123; i,$ &#125;); que.push_back(&#123; i,$ &#125;); &#125; &#125; for (int i = 0; i &lt; totParty; i++)Rank[i] = i; sort(Rank, Rank + totParty, [](int a, int comp) &#123;return partyVote[a].size() &gt; partyVote[comp].size(); &#125;); for (int i = 0; i &lt; totParty; i++) sort(partyVote[i].begin(), partyVote[i].end(), Voter()); sort(que.begin(), que.end(), Voter()); siz = totVoter &gt;&gt; 1; for (int minNeeds = 0; minNeeds &lt;= siz; minNeeds++) &#123; nowVotes = votesGet; _count = 0; memset(vis, false, sizeof(vis)); for (int i = 0; partyVote[Rank[i]].size() &gt; minNeeds; i++) for (int j = 0; j &lt; partyVote[Rank[i]].size() - minNeeds; j++) &#123; _count += partyVote[Rank[i]][j].needCoin; nowVotes++; vis[partyVote[Rank[i]][j].ID] = true; &#125; for (int i = 0; nowVotes &lt;= minNeeds; i++) &#123; if (vis[que[i].ID])continue; nowVotes++; _count += que[i].needCoin; &#125; if (_count &lt; _min)_min = _count; &#125; cout &lt;&lt; _min &lt;&lt; endl; //system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力/枚举</tag>
        <tag>贪心</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1017D]]></title>
    <url>%2F2018%2F08%2F10%2FCF1017D%2F</url>
    <content type="text"><![CDATA[注意在这题中01串都很短，长度不超过12，可以使用集合转换为整数表示，然后开一个二维数组，预处理一下所有可能查询的串和最大Wu值存在里面就可以了。 1int arr[i][v]; 准确地说，数组第一维保存可能给定的一个01串转换为整数的值 $i$，第二位则是当Wu值 恰好等于 $v$ 时的答案，随后在线地处理每一个询问，将小于最大Wu值的所有答案加起来即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace CF1017D&#123; class Program &#123; public class Global&#123; public static int[,] arr; public static int[] cnt, wuVal; &#125; static void Main(string[] args) &#123; string inp;string[] div; int len, totTemp, totQuery, maxWu, x, _count; inp &#x3D; Console.ReadLine();div &#x3D; inp.Split(&#39; &#39;); len &#x3D; Convert.ToInt32(div[0]);totTemp &#x3D; Convert.ToInt32(div[1]);totQuery &#x3D; Convert.ToInt32(div[2]); Global.arr &#x3D; new int[(1 &lt;&lt; 13), 101]; Global.cnt &#x3D; new int[1 &lt;&lt; 13]; Global.wuVal &#x3D; new int[len]; &#x2F;&#x2F;read inp &#x3D; Console.ReadLine(); div &#x3D; inp.Split(&#39; &#39;); for(int i &#x3D; 0; i &lt; len; i++) Global.wuVal[i] &#x3D; Convert.ToInt32(div[i]); for(int i &#x3D; 0; i &lt; totTemp; i++) &#123; inp &#x3D; Console.ReadLine(); x &#x3D; 0; for(int j &#x3D; 0; j &lt; len; j++) if(inp[j] &#x3D;&#x3D; &#39;1&#39;) x |&#x3D; (1 &lt;&lt; j); Global.cnt[x]++; &#125; &#x2F;&#x2F;预处理 for(int i &#x3D; 0; i &lt; (1 &lt;&lt; len); i++) for(int j &#x3D; 0; j &lt; (1 &lt;&lt; len); j++) if(Global.cnt[i] &gt; 0) &#123; x &#x3D; 0; &#x2F;&#x2F;代价 for(int k &#x3D; 0; k &lt; len; k++) if((i &amp; (1 &lt;&lt; k)) &#x3D;&#x3D; (j &amp; (1 &lt;&lt; k))) x +&#x3D; Global.wuVal[k]; if(x &lt;&#x3D; 100) Global.arr[j, x] +&#x3D; Global.cnt[i]; &#125; while(totQuery-- &gt; 0) &#123; inp &#x3D; Console.ReadLine();div &#x3D; inp.Split(&#39; &#39;); maxWu &#x3D; Convert.ToInt32(div[1]); _count &#x3D; x &#x3D; 0; for(int i &#x3D; 0; i &lt; len; i++) if(inp[i] &#x3D;&#x3D; &#39;1&#39;) x |&#x3D; (1 &lt;&lt; i); for(int i &#x3D; 0; i &lt;&#x3D; maxWu; i++) _count +&#x3D; Global.arr[x, i]; Console.WriteLine(_count.ToString()); &#125; &#125; &#125;&#125; 代码就是这样了，这道题时间卡得非常紧，导致我用C#调了半天还是超时。逐行翻译成 C++ 代码之后就AC了.]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>暴力/枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aho-Corasick自动机 API]]></title>
    <url>%2F2018%2F08%2F08%2FAho-Corasick%E8%87%AA%E5%8A%A8%E6%9C%BA-API%2F</url>
    <content type="text"><![CDATA[AC自动机是建立在Trie树上的一个多模式匹配算法。理论上应该会用到KMP的思想，实际上我学习KMP时操作next数组弄了半天也没懂，写了AC自动机才慢慢体会到KMP的精髓。 果然还是指针最好用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class AhoCorasickAutomaton &#123;private: int siz = 0; bool isFresh = false; struct Node &#123; Node* nxt[26]; Node* fail; int endHere; &#125;*root = nullptr; Node* newNode() &#123; Node* creat = (Node*)malloc(sizeof(Node)); for (int i = 0; i &lt; 26; i++) creat-&gt;nxt[i] = nullptr; creat-&gt;fail = nullptr; creat-&gt;endHere = 0; return creat; &#125; void cls(Node* nowAt) &#123; for (int i = 0; i &lt; 26; i++) if (nowAt-&gt;nxt[i] != nullptr)cls(nowAt-&gt;nxt[i]); free(nowAt); &#125; void build() &#123; this-&gt;isFresh = true; queue&lt;Node*&gt; dat; dat.push(root); Node *nowAt = nullptr, *ext = nullptr; while (!dat.empty()) &#123; nowAt = dat.front(); dat.pop(); for (int i = 0; i &lt; 26; i++) if (nowAt-&gt;nxt[i] != nullptr) &#123; if (nowAt == root)nowAt-&gt;nxt[i]-&gt;fail = root; else &#123; ext = nowAt-&gt;fail; while (ext != nullptr) &#123; if (ext-&gt;nxt[i]) &#123; nowAt-&gt;nxt[i]-&gt;fail = ext-&gt;nxt[i]; break; &#125; &#125; if (ext == nullptr)nowAt-&gt;nxt[i]-&gt;fail = root; &#125; dat.push(nowAt-&gt;nxt[i]); &#125; &#125; &#125; void compare(char* comp, int &amp;_count) &#123; Node* nowAt = root, *ext; int len = strlen(comp); while (len--) &#123; while (nowAt-&gt;nxt[*comp - 'a'] == nullptr&amp;&amp;nowAt != root)nowAt = nowAt-&gt;fail; if (nowAt-&gt;nxt[*comp - 'a'] != nullptr) nowAt = nowAt-&gt;nxt[*comp - 'a']; ext = nowAt; while (ext != root) &#123; if (ext-&gt;endHere &gt;= 0) &#123; _count += ext-&gt;endHere; ext-&gt;endHere = -1; //重复出现只算一次 &#125; else break; ext = ext-&gt;fail; &#125; &#125; &#125;public: bool isEmpty() &#123; return siz == 0; &#125; bool clear() &#123; siz = 0; if (root != nullptr)cls(root); root = nullptr; &#125; int size() &#123; return this-&gt;siz; &#125; void insert(char* ins) &#123; this-&gt;isFresh = false; if (root == nullptr)root = newNode(); int len = std::strlen(ins); Node* nowAt = root; while(len--) &#123; if (nowAt-&gt;nxt[*ins - 'a'] == nullptr) nowAt-&gt;nxt[*ins - 'a'] = newNode(); nowAt = nowAt-&gt;nxt[*ins - 'a']; ins++; &#125; nowAt-&gt;endHere++; this-&gt;siz++; &#125; int compare(char *comp) &#123; int _count = 0; if (this-&gt;isFresh == false) &#123; build(); isFresh = true; &#125; compare(comp, _count); return _count; &#125;&#125;;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>自动机</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1016C]]></title>
    <url>%2F2018%2F08%2F04%2FCF1016C%2F</url>
    <content type="text"><![CDATA[这道题难度并不算大，主要考的是细心程度。 思路这题思路并不难想，注意有一句非常关键的话: _每个格子必须且只能经过一次。_ 不难发现，方案数量是线性的。 这是样例解释中的两张图，我们分别记他们为 方案1 和 方案2 ,可以发现，我们有三种可行方案：方案1，方案2，前 $i$ 列使用方案1，随后使用方案2. 这样，所有的方案都已经被找到，将他们计算出来的时间复杂度为 $O(N^2)$ ,超时。虽然时间超了，但是这种思路没错。 优化方案为了简单起见，以下图片中的数字代表 _位于这个格子中的数字(蘑菇生长速度)为最终的答案的贡献值_ 也就是 _采集这个蘑菇时它生长了多少秒_ 换句话说， _到达这个格子时可以采集到多少倍于它每秒生长值的蘑菇_. 如图，这是方案2中每个蘑菇的贡献。 $(n=8)$ 这是采用两行方案1之后采用方案2每个蘑菇的贡献。 这样，不难发现规律：从第三列开始，下图中每个数都比上图大2.我们可以使用两个变量 $now$ 和 $last$ ，分别记录现在这种方案中方案1和方案2对答案的贡献，像这样每隔一列更新一下，可以手算出八种变化，然后后边大2的部分前缀和快速求和乘2即可。不要忘记方案1有可能采用奇数列，可以用一样的方法计算。最后 $ans = max(now_i+last_i)$ 建议手算变化量时，画个图给自己看，可以让思路更加清晰。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace CF1016C&#123; class Program &#123; public class Global &#123; public static Int64[,] num; public static Int64[] perf; &#125; public static Int64 GetSum(int fr, int to)&#123; if (fr &#x3D;&#x3D; 0) return Global.perf[to]; else return (Global.perf[to] - Global.perf[fr - 1]); &#125; static void Main(string[] args) &#123; string inp; string[] div; int totList &#x3D; Convert.ToInt32(Console.ReadLine()), p; Int64 nowNum, leftNum, _max, together; Global.num &#x3D; new Int64[2, totList];Global.perf &#x3D; new Int64[totList]; for (int i &#x3D; 0; i &lt; 2; i++) &#123; inp &#x3D; Console.ReadLine(); div &#x3D; inp.Split(&#39; &#39;); for (int j &#x3D; 0; j &lt; totList; j++) &#123; Global.num[i, j] &#x3D; Convert.ToInt64(div[j]); &#125; &#125; Global.perf[0] &#x3D; Global.num[0, 0] + Global.num[1, 0]; for (int i &#x3D; 1; i &lt; totList; i++) Global.perf[i] &#x3D; Global.perf[i - 1] + Global.num[1, i] + Global.num[0, i]; nowNum &#x3D; leftNum &#x3D; 0; for (int i &#x3D; 0; i &lt; totList; i++) leftNum +&#x3D; Global.num[0, i] * i; for (int i &#x3D; totList - 1; i &gt;&#x3D; 0; i--) leftNum +&#x3D; Global.num[1, i] * ((totList &lt;&lt; 1) - i - 1); together &#x3D; _max &#x3D; leftNum; for(int cgList &#x3D; 2; cgList &lt; totList; cgList +&#x3D; 2) &#123; p &#x3D; (cgList &lt;&lt; 1) - 4; nowNum +&#x3D; Global.num[0, cgList - 2] * p++; nowNum +&#x3D; Global.num[1, cgList - 2] * p++; nowNum +&#x3D; Global.num[1, cgList - 1] * p++; nowNum +&#x3D; Global.num[0, cgList - 1] * p; p &#x3D; ((cgList - 2) &lt;&lt; 1); leftNum -&#x3D; Global.num[0, cgList - 2] * p++; leftNum -&#x3D; Global.num[0, cgList - 1] * p; p &#x3D; (totList &lt;&lt; 1) - 1; leftNum -&#x3D; Global.num[1, cgList - 2] * p--; leftNum -&#x3D; Global.num[1, cgList - 1] * p; leftNum +&#x3D; (GetSum(cgList, totList - 1) &lt;&lt; 1); _max &#x3D; Math.Max(_max, nowNum + leftNum); &#125; nowNum &#x3D; Global.num[1,0];leftNum &#x3D; 0; for (int i &#x3D; 1; i &lt; totList; i++) leftNum +&#x3D; Global.num[1, i] * (i + 1); for (int i &#x3D; totList - 1; i &gt; 0; i--) leftNum +&#x3D; Global.num[0, i] * ((totList &lt;&lt; 1) - i); _max &#x3D; Math.Max(_max, nowNum + leftNum); for (int cgList &#x3D; 3; cgList &lt; totList; cgList +&#x3D; 2) &#123; p &#x3D; ((cgList - 2) &lt;&lt; 1); nowNum +&#x3D; Global.num[1, cgList - 2] * p++; nowNum +&#x3D; Global.num[0, cgList - 2] * p++; nowNum +&#x3D; Global.num[0, cgList - 1] * p++; nowNum +&#x3D; Global.num[1, cgList - 1] * p; p &#x3D; ((cgList - 2) &lt;&lt; 1); leftNum -&#x3D; Global.num[1, cgList - 2] * p++; leftNum -&#x3D; Global.num[1, cgList - 1] * p; p &#x3D; (totList &lt;&lt; 1) - 1; leftNum -&#x3D; Global.num[0, cgList - 2] * p--; leftNum -&#x3D; Global.num[0, cgList - 1] * p; leftNum +&#x3D; (GetSum(cgList, totList - 1) &lt;&lt; 1); _max &#x3D; Math.Max(_max, nowNum + leftNum); &#125; Console.WriteLine(_max.ToString()); &#125; &#125;&#125; CF支持C#。在 .NET Framework 4.7.1 或更高版本的框架下编译并运行。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie字典树API]]></title>
    <url>%2F2018%2F08%2F04%2FTrie%E5%AD%97%E5%85%B8%E6%A0%91API%2F</url>
    <content type="text"><![CDATA[支持的操作：插入、查询。 C++11: 12345678910111213141516171819202122232425262728293031323334353637class Trie &#123;private: struct Node &#123; bool endHere; Node* nxt[26]; &#125;*root = nullptr; Node* newNode() &#123; Node* creat = (Node*)malloc(sizeof(Node)); for (int i = 0; i &lt; 26; i++)creat-&gt;nxt[i] = nullptr; creat-&gt;endHere = false; return creat; &#125; void cls(Node* targ) &#123; for (int i = 0; i &lt; 26; i++) if (targ-&gt;nxt[i] != nullptr)cls(targ-&gt;nxt[i]); free(targ); &#125;public: void clear() &#123; if (root != nullptr)cls(root); root = newNode(); &#125; void insert(const string &amp;ins) &#123; Node *nowAt = root; for (int i = 0; i &lt; ins.length(); i++) &#123; if (nowAt-&gt;nxt[ins[i] - 'a'] == nullptr)nowAt-&gt;nxt[ins[i] - 'a'] = newNode(); nowAt = nowAt-&gt;nxt[ins[i] - 'a']; &#125;nowAt-&gt;endHere = true; &#125; bool query(char *cmp,const int &amp;len) &#123; Node* nowAt = root; for (int i = 0; i &lt; len; i++) &#123; if (nowAt-&gt;nxt[*cmp - 'a'] == nullptr)return false; nowAt = nowAt-&gt;nxt[*cmp++ - 'a']; &#125; return nowAt-&gt;endHere; &#125;&#125;;]]></content>
      <categories>
        <category>模板和API</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1012B]]></title>
    <url>%2F2018%2F08%2F03%2FCF1012B%2F</url>
    <content type="text"><![CDATA[这道题目难度并不大，但是需要使用到特殊构造的算法。 首先，我们假设这个表规格是 $nm$ 的，如果上面一个点也没有，那么我们只需要放置 $n+m-1$ 的点，就可以产生出其它所有的点。一种可行的方案是放满最上面一行和最左边一列。换句话说，最终计算出来的总代价(额外放置的点的数量)不可能超过 $n+m-1.$ 我们假设这是一个并查集，那么当这个并查集中只有一个联通块时，就覆盖了所有的点，满足题意。 那么如何将一个使用二元组描述的点抽象成一个并查集中的元素呢？我们假设这个点坐标为 $(x_1, y_1)$ 如果有另外三个点 $(x_1, y_0), (x_0,y_1), (x_0, y_0)$ 那么这个点就与他们在同一个集合中。对于一个存在的点 $(x_1, y_1)$ ，将集合 $x_1$ 与集合 $y_1 + n$ 合并，这样原图中所有的点都可以被分到 $n+m$ 个集合中，而合并两个集合的代价就是添加一个额外的点。也就是1. 并查集可以在线维护，最后求一下它的联通数量减去1即为答案。 伪代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace CF1012B&#123; class Program &#123; public class Global &#123; public static int[] up; &#125; public static int FindTop(int nowAt) &#123; return (Global.up[nowAt] &#x3D;&#x3D; nowAt ? nowAt : (Global.up[nowAt] &#x3D; FindTop(Global.up[nowAt]))); &#125; static void Main(string[] args) &#123; string inp;string[] div; int totLine, totList, totPoints, x, y; inp &#x3D; Console.ReadLine();div &#x3D; inp.Split(&#39; &#39;); totLine &#x3D; Convert.ToInt32(div[0]); totList &#x3D; Convert.ToInt32(div[1]); totPoints &#x3D; Convert.ToInt32(div[2]); Global.up &#x3D; new int[totLine + totList]; for (int i &#x3D; 0; i &lt; totLine + totList; i++) Global.up[i] &#x3D; i; for (int i &#x3D; 0; i &lt; totPoints; i++) &#123; inp &#x3D; Console.ReadLine();div &#x3D; inp.Split(&#39; &#39;); y &#x3D; Convert.ToInt32(div[0]) - 1;x &#x3D; Convert.ToInt32(div[1]) - 1; Global.up[FindTop(y)] &#x3D; FindTop(x + totLine); &#125; int _count &#x3D; -1; for (int i &#x3D; 0; i &lt; totLine + totList; i++) if (Global.up[i] &#x3D;&#x3D; i) _count++; Console.WriteLine(_count.ToString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>特殊算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1015E1 & CF1015E2]]></title>
    <url>%2F2018%2F08%2F03%2FCF1015E1-%26-CF1015E2%2F</url>
    <content type="text"><![CDATA[事实上，CF1015E1 和 CF1015E2 是两道题，它们题面相同，但是 CF1015E2 的数据范围比 CF1015E1 多一个0, 以下统称为 CF1015E. 题目大意 有一个大小为 $nm$, 全部由 ‘.’ 和 ‘*‘ 组成的字符矩阵，其中定义一个星星为类似于下图中的东西(十字形)： 你要求出一种方案，使用不同或相同大小的星星覆盖图中所有的 ‘*‘. 输出方案数(没必要最少)，以及所有星星的位置，大小(十字形的长度)。任意一种方案都被视为正确，时限3秒。 E1中 $n,m$ 小于 100，E2 小于 1000. 思路 由于没有必要使星星最少，我们可以随便瞎搞，碰到一个位置能放就放，能放多大就放多大，肯定不会错。具体地说，碰到图中的一个 ‘*‘ 后，每一步向上下左右扩展一格，一旦碰到 ‘.’ 就停止，如果这个扩展步数大于0(没有大小是一个’*‘的星星)，就在这里放一个星星。 $O(NM)$ 将整个图扫一遍， $O(max(N,M))$ 计算大小，最后还要再渲染一张按照这种方案放置后的结果图，看看是不是每个星星都覆盖到了，这样可以通过 E1. 正解 E2 的思路与 E1 一样，也是尽可能多、大地放置星星，但是需要加上许多优化。 首先，计算星星的大小。这就相当于看看扩展的时候是那一边最先碰到一个 ‘.’ 也就是这个星星的中点到四周最近的一个 ‘.’ 的距离我们可以预处理出四个大小为 $nm$ 的矩阵每个元素 $(i,j)$ 代表 $(i,j)$ 这个点到上\下\左\右最近一个’.’的距离，这个预处理可以在 $O(NM)$ 内完成，随后便可以支持我们 $O(1)$ 地查询。 这样，确定星星的时间复杂度降低到了 $O(NM)$ 。在渲染放置的结果时，我们可以将行与列分离，单独地处理每一行、每一列，这样就化为了一个一维问题:给定一些区间 [i,j]，将数组中在这个区间内所有的字符变为 ‘*‘。我们可以开一个一维数组A[], 对于每一个区间[i,j]，使A[i]++,A[j]—.然后用一个变量now一遍扫过去，先让now加上A[i],如果now大于0，则A[i] = ‘*‘.这样总时间复杂度是 O(NM). 两个操作的复杂度、空间复杂度都为 O(NM), 面对1000这样的数据绰绰有余。 C#代码如下。在 .NET Framework 4.7.1 或更高版本的框架下编译并运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Collections;namespace CF1015E&#123; class Program &#123; public class Global &#123; public static ArrayList outPut; public static int[,] lft, rgt, up, dwn; public static int[,] line, list; public static bool[,] mp, rdMp; &#125; static int GetMaxLen(int y,int x) &#123; return Math.Min(Math.Min(Global.lft[y, x], Global.rgt[y, x]), Math.Min(Global.up[y, x], Global.dwn[y, x])); &#125; static void PutStar(int y, int x, int siz) &#123; Global.line[y, x - siz]++;Global.line[y, x + siz + 1]--; Global.list[y - siz, x]++;Global.list[y + siz + 1, x]--; &#125; static void Main(string[] args) &#123; string inp;string[] div; int totLine, totList; inp &#x3D; Console.ReadLine();div &#x3D; inp.Split(&#39; &#39;); totLine &#x3D; Convert.ToInt32(div[0]);totList &#x3D; Convert.ToInt32(div[1]); Global.mp &#x3D; new bool[totLine + 2, totList + 2];Global.rdMp &#x3D; new bool[totLine + 2, totList + 2]; Global.lft &#x3D; new int[totLine + 2, totList + 2]; Global.rgt &#x3D; new int[totLine + 2, totList + 2]; Global.up &#x3D; new int[totLine + 2, totList + 2]; Global.dwn &#x3D; new int[totLine + 2, totList + 2]; Global.line &#x3D; new int[totLine + 2, totList + 2]; Global.list &#x3D; new int[totLine + 2, totList + 2]; for(int i &#x3D; 1; i &lt;&#x3D; totLine; i++) &#123; inp &#x3D; Console.ReadLine(); for(int j &#x3D; 1; j &lt;&#x3D; totList; j++) &#123; if (inp[j - 1] &#x3D;&#x3D; &#39;*&#39;) Global.mp[i, j] &#x3D; true; else Global.mp[i, j] &#x3D; false; &#125; &#125; &#x2F;&#x2F;Pretreatment for (int i &#x3D; 1; i &lt;&#x3D; totLine; i++) &#123; for (int j &#x3D; 1; j &lt;&#x3D; totList; j++) &#123; if (Global.mp[i, j] &#x3D;&#x3D; false) &#123; Global.lft[i, j] &#x3D; Global.up[i, j] &#x3D; 0; continue; &#125; Global.lft[i, j] &#x3D; Global.lft[i, j - 1] + 1; Global.up[i, j] &#x3D; Global.up[i - 1, j] + 1; &#125; &#125; for (int i &#x3D; totLine; i &gt; 0; i--) &#123; for(int j &#x3D; totList; j &gt; 0; j--) &#123; if (Global.mp[i, j] &#x3D;&#x3D; false) &#123; Global.rgt[i, j] &#x3D; Global.dwn[i, j] &#x3D; 0; continue; &#125; Global.rgt[i, j] &#x3D; Global.rgt[i, j + 1] + 1; Global.dwn[i, j] &#x3D; Global.dwn[i + 1, j] + 1; &#125; &#125; &#x2F;&#x2F;Set Position and Size of Stars int _count &#x3D; 0, len; Global.outPut &#x3D; new ArrayList &#123; &#125;; for (int i &#x3D; 1; i &lt;&#x3D; totLine; i++) for(int j &#x3D; 1; j &lt;&#x3D; totList; j++) &#123; len &#x3D; GetMaxLen(i, j) - 1; if (Global.mp[i, j] &#x3D;&#x3D; false || len &lt; 1) continue; _count++; PutStar(i, j, len); Global.outPut.Add(i.ToString() + &quot; &quot; + j.ToString() + &quot; &quot; + len.ToString()); &#125; &#x2F;&#x2F;Render int nowNum; for (int i &#x3D; 1; i &lt;&#x3D; totLine; i++) &#123; nowNum &#x3D; 0; for (int j &#x3D; 1; j &lt;&#x3D; totList; j++) &#123; nowNum +&#x3D; Global.line[i, j]; if (nowNum &gt; 0) Global.rdMp[i, j] &#x3D; true; &#125; &#125; for (int j &#x3D; 1; j &lt;&#x3D; totList; j++) &#123; nowNum &#x3D; 0; for (int i &#x3D; 1; i &lt;&#x3D; totLine; i++) &#123; nowNum +&#x3D; Global.list[i, j]; if (nowNum &gt; 0) Global.rdMp[i, j] &#x3D; true; &#125; &#125; &#x2F;&#x2F;Check Result for (int i &#x3D; 1; i &lt;&#x3D; totLine; i++) for (int j &#x3D; 1; j &lt;&#x3D; totList; j++) if (Global.mp[i, j] &#x3D;&#x3D; true &amp;&amp; Global.rdMp[i, j] &#x3D;&#x3D; false) &#123; Console.WriteLine(&quot;-1&quot;); return; &#125; &#x2F;&#x2F;OutPut Console.WriteLine(_count.ToString()); foreach (string it in Global.outPut) Console.WriteLine(it); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>暴力/枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】CF1011B]]></title>
    <url>%2F2018%2F08%2F02%2FCF1011B%2F</url>
    <content type="text"><![CDATA[先将所有的食物读入，用类似于桶排序的方法存在一个数组中。 然后二分一下天数，检查是否可行。 对于一个确定的天数，可以使用贪心的方法模拟检查：首先将食物排序，数组中的数字代表着这种食物_剩余的_数量。创建一个指针指向数组的0号单元，这时判断指针指向的数是否大于这个天数，也就是这种类型的食物是否还够一个人吃上这么多天，如果够，人数减一，这种食物剩余量减去天数，如果不够，指针后移。特别地，如果人数等于0说明可行，指针超出数组范围反之。 上伪代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace CF1011B&#123; class Program &#123; public static int _cmp(int a,int b) &#123; if (a &#x3D;&#x3D; b) return 0; else if (a &gt; b) return -1; else return 1; &#125; public static bool canSolve(int[] food, int days, int totPeo) &#123; int now &#x3D; 0; while (totPeo &gt; 0) &#123; while (food[now] &lt; days) if (++now &gt; 100) return false; food[now] -&#x3D; days; totPeo--; &#125; return true; &#125; static void Main(string[] args) &#123; int totNums, totParticipant; string inp &#x3D; Console.ReadLine(); string[] div; div &#x3D; inp.Split(&#39; &#39;); totNums &#x3D; Convert.ToInt32(div[1]);totParticipant &#x3D; Convert.ToInt32(div[0]); int[] num &#x3D; new int[101]; for (int i &#x3D; 0; i &lt; 101; i++) num[i] &#x3D; 0; inp &#x3D; Console.ReadLine();div &#x3D; inp.Split(&#39; &#39;); for (int i &#x3D; 0; i &lt; totNums; i++) num[Convert.ToInt32(div[i]) - 1]++; Array.Sort(num, _cmp); int fr &#x3D; 0, to &#x3D; 101, mid; int[] fd &#x3D; new int[101]; while (fr &lt; to) &#123; mid &#x3D; ((fr + to) &gt;&gt; 1) + 1; for (int i &#x3D; 0; i &lt; 101; i++) fd[i] &#x3D; num[i]; if (canSolve(fd, mid, totParticipant)) fr &#x3D; mid; else to &#x3D; mid - 1; &#125; Console.WriteLine(fr.ToString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】UVA1437]]></title>
    <url>%2F2018%2F07%2F10%2FUVA1437%2F</url>
    <content type="text"><![CDATA[这题大体的思路比较好想，就是一个动态规划。 不过，由于我们是要把一个字符串刷成另外一个字符串，那么这个字符串当中有一部分可能已经是另外的那个字符串中相同的一部分了。换句话说，记这两个字符串为A和B.那么有可能存在A[i] == B[i].那么这些字符在我们还没有开始使用刷子的时候就已经是符合要求的了。假如A和B相同，那么我们根本就不需要使用刷子。 可见，由于A和B中字符的不确定性，我们并不能够轻易地定义出状态并写出状态转移方程。但是，如果换一个思路考虑就可以简化问题。 假设有一个全部由空格组成的字符串，与A和B的长度相等，我们记这个字符串为E.由于空格并不存在与A或者B中，所以可以把E理解成每一个字符都和相同位置的A或B的字符都不相同。我们尝试将E刷成B.1int D[][]; 定义一个二维数组D[i][j] = E中i到j刷成和B中i到j相同需要刷的最小次数. 那么显而易见1D[i][i] = 1; 假如B中存在两个字符是相同的，那么其实还有另外一种刷法。不妨设123B = "a b u d i s p b m l k j"E = "_ _ _ _ _ _ _ _ _ _ _ _"[] 1 2 3 4 5 6 7 8 9 10 11 12 在这里，B中有两个相同的字符b.那么我们可以先把E[8-12]刷成与B一样的，由于我们肯定有一次使用刷子是把E[8]刷成了’b’，那么在这一次使用刷子的时候，可以顺便把E[4-7]全部变成’b’,那么123B = "a b u d i s p b m l k j"E = "_ b b b b b b b m l k j"[] 1 2 3 4 5 6 7 8 9 10 11 12 随后，再刷E[3-7].这样，转移方程就呼之欲出了。12345//枚举i,j。i从后往前，j从i往后。D[i][j] = D[i + 1][j] + 1;//在i + 1和j之间枚举k.作为切分的位置。if(B[i] == B[k]) D[i][j] = min(D[i][j], D[i + 1][k - 1] + D[k][j]); 接下来处理从A刷到B.定义Dp[i] = A前i个字符刷成与B前i个字符相同需要刷的最小次数。那么1Dp[i] = D[1][i]; 前面提到，如果A中有某些字符在一开始就和B中相同位置的字符一样，那么这些字符就可以不用刷 前面提到，如果A中有某些字符在一开始就和B中相同位置的字符一样，那么这些字符就可以不用刷。12if (A[i] == B[i]) Dp[i] = (i == 1 ? 0 : Dp[i - 1]); 同样地，我们还是枚举一下k，作为切分的位置。可以先将A[1-k]刷成B[1-k],然后再把A[k+1-i]当作E[k+1-i]来刷。1Dp[i] = min(Dp[i], Dp[k] + D[k + 1][i]); 完整的程序如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; int X = 0, w = 0; char ch = 0; while (!std::isdigit(ch)) &#123; w |= ch == '-'; ch = std::getchar(); &#125; while (std::isdigit(ch)) X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48), ch = std::getchar(); return w ? -X : X;&#125;template&lt;typename T&gt;inline void write(T x) &#123; if (x &lt; 0) std::putchar('-'), x = -x; if (x &gt; 9) write(x / 10); std::putchar(x % 10 + '0');&#125;template&lt;typename T&gt;inline void writeLine(T x) &#123; write(x); std::putchar('\n');&#125;template&lt;typename T&gt;T min_(T&amp; numb, T comp) &#123; if (comp &lt; numb) &#123; numb = comp; return comp; &#125; else return numb;&#125;int main()&#123; char A[105], B[105]; int len; int D[105][105], Dp[105]; while (scanf("%s%s", B + 1, A + 1) == 2) &#123; len = strlen(A + 1); memset(D, 0, sizeof(D)); memset(Dp, 0, sizeof(Dp)); //Dp1 for (int i = 0; i &lt;= len; i++)D[i][i] = 1; for (int i = len - 1; i &gt; 0; i--) for (int j = i + 1; j &lt;= len; j++) &#123; D[i][j] = D[i + 1][j] + 1; for (int cut = i + 1; cut &lt;= j; cut++) if (A[i] == A[cut]) min_(D[i][j], D[i + 1][cut - 1] + D[cut][j]); &#125; //Dp2 for (int i = 1; i &lt;= len; i++) &#123; Dp[i] = D[1][i]; if (A[i] == B[i]) Dp[i] = (i == 0 ? 0 : min_(Dp[i], Dp[i - 1])); else &#123; for (int cut = 1; cut &lt; i; cut++) min_(Dp[i], Dp[cut] + D[cut + 1][i]); &#125; &#125; writeLine(Dp[len]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树的实现和应用]]></title>
    <url>%2F2018%2F07%2F08%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线段树的实现和应用 线段树是一种二叉树。 在编程的过程中我们有时会需要动态地维护一个序列，并且支持类似于区间加减乘除，区间最大值，区间和(积)这样的修改或者查询操作。 很容易想到的朴素算法在不需要辅助空间的情况下每次查询和修改的时间复杂度都有可能达到线性级别。倘若需要频繁地执行这两种操作，那么时间上将会达到难以承受的指数级别。 这时，我们就需要使用到 线段树 这种数据结构。线段树将整个序列分为很多大的区间，而每个大区间又分为若干较小的区间。并在修改时为区间打上标记，查询时综合很多有用区间的信息。依靠2~4倍的空间，和线性对数级别的预处理，将时间复杂度降低至对数级别，在空间充足的前提下，极大地节省了时间。 在开始实现线段树之前，我们有必要先了解一下指针的使用方法，原因是这样可以动态的申请/释放内存空间，而不是根据数据范围分配一大堆，在需要类似于树套树这样的操作时更可以节省大量空间。 如果您厌恶指针，使用数组模拟的线段树介绍文章并不少见，而且，它们思路大多都是相通的。 基本思想 可以用线段树统计的信息非常多，区间的和、最大值只是其中比较常见的两个。但是，这些统计的信息必须符合区间加法，也就是说，两个相邻的区间可以通过一定的计算合并成一整个大区间。举个例子，区间[0,10]的最大值为8，区间[11,20]的最大值为10，那么显而易见，区间[0,20]的最大值就是10，这也是一个符合区间加法信息统计的例子。其它符合区间加法的还有最大公因数GCD、平均数等。但是，众数、最长上升子序列、连续出现次数最多等都是不符合区间加法的。 前面已经提到过，_线段树将整个序列分为很多大的区间，而每个大区间又分为若干较小的区间_。 事实上，一个长度为n的序列可以被看成是n个区间:[0,0],[1,1]…[$n-1$,$n-1$].有了这些区间，我们就可以推到出更大区间的信息:[0,1][2,3]…[$n-2$,$n-1$].不断地重复进行这种序列之间的合并，最终就可以得到一个区间[$0$,$n-1$]，这个区间就是整个线段树的根。 需要查询的时候，我们将很多段区间的信息综合起来，例如，我们想要知道区间[2,7]的所有数之和，可以将区间[2,3]和[4,7]加起来，就得到了答案，这种操作的时间复杂度是对数级别的。 原理与实现 在这里，我们以【模板】线段树 1为例，介绍如何使用线段树维护一个区间，并在时间复杂度是线性对数级别的前提下实现 1.将某区间每一个数加上x 2.求出某区间每一个数的和 这两项操作。 线段树的建立 在建立线段树之前，我们先将所有的数据读入进来。这些数据本质上代表第i个数的值，不过，我们也可以将他们看作：_区间[i,i]中所有数的和._ 这样，我们就得到了线段数的所有叶子。 在下图中，fr代表区间的开始，to代表区间的终止，val含义为在区间[fr,to]中所有数之和。 接下来，我们要将这些区间逐个合并，由于我们要维护的是区间和，所以两个区间合并在一起，它们val值加起来就是整个区间的所有数之和了。 合并完四个区间之后，就出现了问题，最后的那个一区间被孤立了。这样是不是就意味着只有2的次方个节点才能够成功地建立一颗线段树？其实并不是这样，我们可以把这个区间先放在一边不管，假装它是一个已经经过合并了的区间，写在上面一行 继续按照之前的步骤合并，并在每步合并的过程中保存节点的左儿子和右儿子。如果使用数组模拟可以不用保存，但是如果是指针，不保存就永远无法访问这些节点了。 最终整个线段树就是这样的了。 具体如何实现呢？在这里由于线段树并不是存在一段连续的内存空间中的，所以单单凭借一个节点我们是不可能得知它的左儿子或右儿子的信息的。这也导致建树的过程较为复杂，不得不使用两个队列模拟，不过，这样一点麻烦可以让我们以后的操作更加直观。 简单地说，就是先把叶子节点全部放入一个队列a中，然后循环不断取出队列a前两个，合并，放入队列b，如果a中只有一个元素那么直接放入b，当a为空之后，swap一下a,b然后开始下一轮循环。随着区间之间不断地合并，最后得到的就是一整个大区间，覆盖了所有的节点。我们将它存为根节点。至此，线段树的建立就算完成了。这些操作的时间复杂度大约是 O(N logN). 值得一提的是，我们仅仅只显示地存储了一个根节点的指针，就完整地保存了一整颗树。下面是参考代码1234567891011121314151617181920212223242526272829303132void build(int size) &#123; //建立的线段树叶节点数为size if (size &lt; 1)return; Node *extra, *a, *b; queue&lt;Node*&gt;dat, add; for (int i = 0; i &lt; size; i++) &#123; extra = newNode(); //后面有对newNode()函数的解释. extra-&gt;fr = extra-&gt;to = i; //叶节点代表的区间就是[i,i]. cin &gt;&gt; extra-&gt;val; //读入 dat.push(extra); &#125; for (; dat.size() &gt; 1; swap(dat, add)) &#123; while (dat.size() &gt; 1) &#123; //提取两个待合并的区间 a = dat.front(); dat.pop(); b = dat.front(); dat.pop(); //合并过程 extra = newNode(); extra-&gt;fr = a-&gt;fr; extra-&gt;to = b-&gt;to; extra-&gt;val = (a-&gt;val + b-&gt;val); extra-&gt;lft = a; extra-&gt;rgt = b; add.push(extra); &#125; if (!dat.empty()) &#123; add.push(dat.front()); dat.pop(); &#125; &#125; root = dat.front(); //保存根节点&#125; 在这里，newNode()函数可以为我们申请一个Node的内存空间，Node就是这颗线段树中的节点。12345678910111213141516 struct Node &#123; int add; //懒标记，后面会介绍到 int fr, to; //区间 long long val;//和 Node *lft, *rgt;//左、右儿子&#125;; Node* newNode() &#123; //申请的一块内存空间由creatIt指向 Node* creatIt = (Node*)malloc(sizeof(Node)); //为一部分变量赋初值 creatIt-&gt;add = 0; creatIt-&gt;lft = creatIt-&gt;rgt = nullptr; return creatIt;&#125; 调用newNode()与直接使用malloc()申请一块内存是没有任何区别的，只不过是在此基础之上，为一些变量赋了初值，这样，在调用newNode()申请内存空间的同时，一些变量就是已经有初值的了，一定程度上可以简化编程的过程。 查询 前面已经提到过，_查询时综合很多有用区间的信息_,得出给定区间的结果。在实际操作过程中，这可以递归完成。 如图。如果我们需要查询区间[1,4]中所有数之和。 那么红色的区间就是之前提到的_有用的区间_。 将红色区间的val相加，得到的不就是区间[1,4]中所有数之和吗？仔细观察红色区间的fr和to，[1,4]不就是相当于[1,1]+[2,3]+[4,4]吗？在这里线段树的实用之处就在于没有累加[2,2]和[3,3]而是直接由[2,3]就得出了[2,2]+[3,3]，这样，倘若在这里维护的不是5个数而是50000个，那么查询大区间时线段树和朴素算法的时间差距将会相当明显。 具体怎么实现呢?我们假设需要查找的区间是[qfr,qto],使用一个指针*nowAt指向当前节点最后累加的和存在一个全局变量ans中。函数原型如下。1void query(const int &amp;qfr,const int &amp;qto,Node* nowAt) 由于我们不需要去更改qfr和qto的值，所以按照常量传递。这个过程是递归实现的，现在我们考虑的是nowAt这个节点。 查询分为三种情况： 当前区间与我们需要查询的区间无关。 当前区间正好是需要查询区间的一部分(或是全部) 当前区间的一部分是我们需要查询区间的一部分(或是全部)，但 当前区间有一部分不在我们查询范围内。 针对不同的情况，我们需要不同的策略。 直接return. 将ans加上这个区间的val. 分别以nowAt的左儿子和右儿子为新的nowAt,递归地调用query()，其它的参数保持不变，这样继续下去，这个区间就会被 切分成若干小区间，并且它们总会对应上情况 1 或者 2. 这样，代码的实现就非常简单了，这些情况和策略很容易就可以被翻译成代码。但是，在每次调用 query() 之前，必须将ans赋值为0. 区间加 线段树最基本的实践就是支持区间加法了，在了解查询的三种操作之后，加法就会变得非常容易，因为它的基本情况和查询几乎完全一样。 但是，唯独有一点不同的地方在于，我们在区间加的过程中需要使用“懒标记”，也就是为每一个Node节点附上一个额外的变量add，它的含义是 以这个节点为根的子树的所有叶子节点的值需要增加add ，也就是说，当我们碰到了查询情况2时，给当前节点打上懒标记，就可以不用继续向运算，这样可以节省大量的计算能力。 打上了懒标记，相应地val也应该改变，这里我的习惯是在打上标记的同时改变val，也就是说这个标记所在节点的val已经是最新的了。懒标记有一个“向下传递”的操作，也就是将一个节点的懒标记传递给它的两个儿子，实现起来非常简单： 1234567891011void push_Down(Node* nowAt) &#123; if (nowAt-&gt;lft != nullptr) &#123; nowAt-&gt;lft-&gt;add += nowAt-&gt;add; nowAt-&gt;lft-&gt;val += (nowAt-&gt;lft-&gt;to - nowAt-&gt;lft-&gt;fr + 1)*nowAt-&gt;add; &#125; if (nowAt-&gt;rgt != nullptr) &#123; nowAt-&gt;rgt-&gt;add += nowAt-&gt;add; nowAt-&gt;rgt-&gt;val += (nowAt-&gt;rgt-&gt;to - nowAt-&gt;rgt-&gt;fr + 1)*nowAt-&gt;add; &#125; nowAt-&gt;add = 0;&#125; 这样，在我们区间加和区间查询的时候，每到达一个节点，除非这个节点与查询\修改的区间无关或者根本就没有懒标记，我们都需要先为其执行一次 push_Down() 操作。 执行区间加操作之后，碰到2类情况的第二个步骤是更新val值，也就是区间和，由于区间内每一个数都加上了同一个值，所以它们的和也就需要加上这个值乘上区间内数的个数的积。 区间查询、区间加的参考代码如下，仔细观察一下就可以发现，它们基本一样： 123456789101112131415161718192021222324252627void query(const int &amp;fr, const int &amp;to, Node *nowAt) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;fr &gt; to || nowAt-&gt;to &lt; fr)return; if (nowAt-&gt;add != 0)push_Down(nowAt); if (nowAt-&gt;fr &gt;= fr &amp;&amp; nowAt-&gt;to &lt;= to) ans += nowAt-&gt;val; else &#123; query(fr, to, nowAt-&gt;lft); query(fr, to, nowAt-&gt;rgt); &#125;&#125;void add(const int &amp;fr, const int &amp;to, const int &amp;addVal, Node* nowAt) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;fr &gt; to || nowAt-&gt;to &lt; fr)return; if (nowAt-&gt;add != 0)push_Down(nowAt); if (nowAt-&gt;fr &gt;= fr &amp;&amp; nowAt-&gt;to &lt;= to) &#123; nowAt-&gt;add += addVal; nowAt-&gt;val += (nowAt-&gt;to - nowAt-&gt;fr + 1)*addVal; &#125; else &#123; add(fr, to, addVal, nowAt-&gt;lft); add(fr, to, addVal, nowAt-&gt;rgt); nowAt-&gt;val = 0; if (nowAt-&gt;lft != nullptr)nowAt-&gt;val += nowAt-&gt;lft-&gt;val; if (nowAt-&gt;rgt != nullptr)nowAt-&gt;val += nowAt-&gt;rgt-&gt;val; &#125;&#125; 销毁 在某些时候，我们需要释放掉之前某些运算过程中占用的内存空间，以保存其它的变量进行下一步运算，销毁一棵线段树可以递归地进行，主要依靠 free() 函数进行内存释放。 123456void destroy(Node *nowAt) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;lft != nullptr)destroy(nowAt-&gt;lft); if (nowAt-&gt;rgt != nullptr)destroy(nowAt-&gt;rgt); free(nowAt);&#125; 这样，执行以下代码就可以销毁掉整颗线段树。 1free(root); 当然，我们也可以将传参更改为其它的节点来达到销毁一颗子树的效果。 模板 将前面的所有操作封装成的模板如下。事实上线段树是一个非常万能，在很多情况下都可以使用的东西，不应被过度封装。这段代码仅供理解、参考。 使用C++11编译、运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102template&lt;typename T&gt;class segTr &#123;private: long long ans; struct Node&#123; int fr, to; T val, add; Node *lft, *rgt; &#125;*root = nullptr; Node* newNode() &#123; Node *creat = (Node *)malloc(sizeof(Node)); creat-&gt;lft = creat-&gt;rgt = nullptr; &#125; void push_Down(Node* nowAt) &#123; if (nowAt-&gt;lft != nullptr) &#123; nowAt-&gt;lft-&gt;add += nowAt-&gt;add; nowAt-&gt;lft-&gt;val += (nowAt-&gt;lft-&gt;to - nowAt-&gt;lft-&gt;fr + 1)*nowAt-&gt;add; &#125; if (nowAt-&gt;rgt != nullptr) &#123; nowAt-&gt;rgt-&gt;add += nowAt-&gt;add; nowAt-&gt;rgt-&gt;val += (nowAt-&gt;rgt-&gt;to - nowAt-&gt;rgt-&gt;fr + 1)*nowAt-&gt;add; &#125; nowAt-&gt;add = 0; &#125; void destroy(Node *nowAt) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;lft != nullptr)destroy(nowAt-&gt;lft); if (nowAt-&gt;rgt != nullptr)destroy(nowAt-&gt;rgt); free(nowAt); &#125; void query(const int &amp;fr, const int &amp;to, Node *nowAt) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;fr &gt; to || nowAt-&gt;to &lt; fr)return; if (nowAt-&gt;add != 0)push_Down(nowAt); if (nowAt-&gt;fr &gt;= fr &amp;&amp; nowAt-&gt;to &lt;= to) ans += nowAt-&gt;val; else &#123; query(fr, to, nowAt-&gt;lft); query(fr, to, nowAt-&gt;rgt); &#125; &#125; void add(const int &amp;fr, const int &amp;to, const T &amp;addVal, Node* nowAt) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;fr &gt; to || nowAt-&gt;to &lt; fr)return; if (nowAt-&gt;add != 0)push_Down(nowAt); if (nowAt-&gt;fr &gt;= fr &amp;&amp; nowAt-&gt;to &lt;= to) &#123; nowAt-&gt;add += addVal; nowAt-&gt;val += (nowAt-&gt;to - nowAt-&gt;fr + 1)*addVal; &#125; else &#123; add(fr, to, addVal, nowAt-&gt;lft); add(fr, to, addVal, nowAt-&gt;rgt); nowAt-&gt;val = 0; if (nowAt-&gt;lft != nullptr)nowAt-&gt;val += nowAt-&gt;lft-&gt;val; if (nowAt-&gt;rgt != nullptr)nowAt-&gt;val += nowAt-&gt;rgt-&gt;val; &#125; &#125;public: bool isEmpty() &#123; return root == nullptr; &#125; bool clear() &#123; destroy(root); root = nullptr; &#125; void build(int size) &#123; if (size &lt; 1)return; Node *extra, *a, *b; queue&lt;Node*&gt;dat, add; for (int i = 0; i &lt; size; i++) &#123; extra = newNode(); extra-&gt;fr = extra-&gt;to = i; cin &gt;&gt; extra-&gt;val; dat.push(extra); &#125; for (; dat.size() &gt; 1; swap(dat, add)) &#123; while (dat.size() &gt; 1) &#123; a = dat.front(); dat.pop(); b = dat.front(); dat.pop(); extra = newNode(); extra-&gt;fr = a-&gt;fr; extra-&gt;to = b-&gt;to; extra-&gt;val = (a-&gt;val + b-&gt;val); extra-&gt;lft = a; extra-&gt;rgt = b; add.push(extra); &#125; if (!dat.empty()) &#123; add.push(dat.front()); dat.pop(); &#125; &#125; root = dat.front(); &#125; void add(const int fr, const int to, const T val) &#123; add(fr, to, val, root); &#125; int query(const int fr, const int to) &#123; ans = 0; query(fr, to, root); return ans; &#125;&#125;; 像这样使用： 123456segTr&lt;int&gt; a; a.build(10); a.add(1,5,30); cout&lt;&lt; a.query(1,10) &lt;&lt;endl; if(!a.isEmpty()) a.clear(); 实践 在通常情况下，不会有题目专门以线段树作为考点来考我们，更多情况下，线段树是我们_优化程序的手段_。也就是说，我们在做题时通常是先想到一个很朴素的算法，如果这个算法时间复杂度不对，再来考虑能否用线段树优化。 例如，在这道题目中，我们在了解扫描线这种东西的原理之后，立马就会想到开一个二维数组，然后按照题目的要求，将二维数组填满，再扫一遍得到最大值，就是这道题的答案。 不过，这道题目数据大得可怕，以至于这么做可能连头几组数据也有些无能为力，即便是将二维数组优化为滚动的一维数组也还是时空都超。因此，我们可以总结一下导致时间爆炸的几个重要操作： 区间加减法，我们在这种操作上面最坏改动了整个数组的值。 查询区间最大值。 不难看出，这不就是线段树的基本应用之一吗，对比上面的线段树介绍，只有查询的东西有所不同。 仔细思考就可以发现，其实区间最大值在整个区间加上或减去一个数的同时，也相应地加或减了这么多。只需将val更改为一个保存着区间最大值的变量，再稍稍修改一点细节，直接套用到程序上，就可以符合这道题的时间复杂度要求。 要完全地通过这道题其实还需要优化空间，即离散化，这超出了我们讨论的范围，但是这不是本题的重点。 代码如下，使用C++11编译并运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;namespace oiudm&#123; inline int read() &#123; int X = 0, w = 0; char ch = 0; while (!std::isdigit(ch)) &#123; w |= ch == '-'; ch = std::getchar(); &#125; while (std::isdigit(ch)) X = (X &lt;&lt; 3) + (X &lt;&lt; 1) + (ch ^ 48), ch = std::getchar(); return w ? -X : X; &#125; template&lt;typename T&gt; inline void write(T x) &#123; if (x &lt; 0) std::putchar('-'), x = -x; if (x &gt; 9) oiudm::write(x / 10); std::putchar(x % 10 + '0'); &#125; template&lt;typename T&gt; inline void writeLine(T x) &#123; oiudm::write(x); std::putchar('\n'); &#125;&#125;using namespace oiudm;//头文件---------//线段树---------struct Node &#123; int fr, to, val, add; Node *lft, *rgt;&#125;*root;Node* newNode() &#123; Node* extra = (Node*)malloc(sizeof(Node)); extra-&gt;lft = extra-&gt;rgt = nullptr; extra-&gt;val = 0; extra-&gt;add = 0; return extra;&#125;void push_Down(Node *nowAt) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;lft != nullptr) &#123; nowAt-&gt;lft-&gt;val += nowAt-&gt;add; nowAt-&gt;lft-&gt;add += nowAt-&gt;add; &#125; if (nowAt-&gt;rgt != nullptr) &#123; nowAt-&gt;rgt-&gt;val += nowAt-&gt;add; nowAt-&gt;rgt-&gt;add += nowAt-&gt;add; &#125; nowAt-&gt;add = 0;&#125;void build(int size) &#123; Node *ext, *a, *b; queue&lt;Node*&gt; dat, add; for (int i = 0; i &lt; size; i++) &#123; ext = newNode(); ext-&gt;fr = ext-&gt;to = i; dat.push(ext); &#125; for (; dat.size() &gt; 1; std::swap(dat, add)) &#123; while (dat.size() &gt; 1) &#123; a = dat.front(); dat.pop(); b = dat.front(); dat.pop(); ext = newNode(); ext-&gt;fr = a-&gt;fr; ext-&gt;to = b-&gt;to; ext-&gt;lft = a; ext-&gt;rgt = b; add.push(ext); &#125; if (!dat.empty()) &#123; add.push(dat.front()); dat.pop(); &#125; &#125; root = dat.front();&#125;void destroy(Node* nowAt) &#123; if (nowAt == nullptr)return; if (nowAt-&gt;lft != nullptr)destroy(nowAt-&gt;lft); if (nowAt-&gt;rgt != nullptr)destroy(nowAt-&gt;rgt); free(nowAt);&#125;int getValue(Node* targ) &#123; return (targ == nullptr ? 0 : targ-&gt;val);&#125;void fresh(const int &amp;fr, const int &amp;to, int val, Node* nowAt) &#123; if (nowAt == nullptr)return; if (fr &gt; nowAt-&gt;to || to &lt; nowAt-&gt;fr)return; if (nowAt-&gt;add != 0)push_Down(nowAt); if (fr &lt;= nowAt-&gt;fr&amp;&amp;to &gt;= nowAt-&gt;to) &#123; nowAt-&gt;val += val; nowAt-&gt;add += val; return; &#125; else &#123; fresh(fr, to, val + nowAt-&gt;add, nowAt-&gt;lft); fresh(fr, to, val + nowAt-&gt;add, nowAt-&gt;rgt); nowAt-&gt;add = 0; nowAt-&gt;val = std::max(getValue(nowAt-&gt;lft), getValue(nowAt-&gt;rgt)); &#125;&#125;//扫描线---------struct scanningLinePoint &#123; //四元组 int y, x, hight, light; bool operator () (scanningLinePoint a, scanningLinePoint comp)const &#123; return (a.y == comp.y ? a.light &lt; comp.light : a.y &lt; comp.y); &#125; //重载 &lt;&#125;;vector&lt;scanningLinePoint&gt; lines;//离散化---------vector&lt;int&gt; highs;map&lt;int, int&gt; val;int InIt()&#123; int x = 0; sort(highs.begin(), highs.end()); auto endAt = unique(highs.begin(), highs.end()); for (auto it = highs.begin(); it &lt; endAt; it++) val[*it] = x++; return x;&#125;//main----------int main()&#123; int totCase = read(), totStar, windW, windH, _max; int x, y, light; while (totCase--) &#123; lines.clear(); highs.clear(); val.clear(); _max = 0; totStar = read(); windW = read(); windH = read(); for (int star = 0; star &lt; totStar; star++) &#123; y = read(); x = read(); light = read(); lines.push_back(&#123; y,x,windH - 1,light &#125;); lines.push_back(&#123; y + windW,x,windH - 1,-light &#125;); highs.push_back(x); highs.push_back(x + windH - 1); &#125; sort(lines.begin(), lines.end(), scanningLinePoint()); build(InIt()); for (auto &amp;it : lines) &#123; fresh(val[it.x], val[it.x + it.hight], it.light, root); _max = max(_max, root-&gt;val); &#125; writeLine(_max); destroy(root); root = nullptr; &#125; //system("pause"); return 0;&#125; 线段树另外一个非常巧妙的应用体现在题目“Ray, Pass me the dishes!”中，这道题目与另一道比较简单的题目非常相似，但是实际上完全不同，前者是后者的动态版本，处理静态版本问题的方法就不再奏效了。 这题的正解是，使用线段树维护一个自定义的结构体struct，先针对所有的数据建立线段树，然后不用修改，每次只是查询。重点是这个自定义结构体和合并两个这种自定义结构体的方法。 事实上，这个结构体是这样的。 12345678910111213struct area &#123; int fr, to; int val;&#125;;struct Node &#123; int fr, to; area frnt;//frnt.fr必须等于this-&gt;fr area mid;//无限制 area tail;//tail.to必须等于to //frnt,mid,tail均为*this的子区间 Node *lft, *rgt;&#125;; 线段树中的节点为Node类型，关于如何合并两个相邻的Node，留给大家思考，这是解开这道题目的关键。 如果你碰到了困难，这个人(不是我)写的题解或许对你有所帮助。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针的使用与内存的申请和释放]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE%2F</url>
    <content type="text"><![CDATA[指针的使用与内存的申请和释放 众所周知，内存给我们提供了存储数据的位置。当我们写下 1int a; 我们就申请了大小为一个int型的内存空间，可以用 1a = 12; 这样的方式为其赋值。 &amp; 这个符号叫做 “取地址符” ，顾名思义，在变量前面加上它，就变成了变量的地址，可以理解为变量存放在内存中的位置。 1int *b; 在变量前面加上‘*’就是指针变量了。指针变量存储的就是一个地址，而前面加的类似于int这样的字眼是为了说明这个地址中存储的是一个什么类型的变量。 相应地，在指针前面加上*就是指针指向地址中的值了。 1234 *b = a; *b = 79; b = &amp;a;//这三种写法都是正确的 在实际应用中，指针和变量有很多表示都是等价的,例如： 指针 a *a 变量 &amp;a a 由于指针相当于一个存储着一个地址的变量，所以很多个指针指向同一个地址是可行的。 1234int a = 10;int *b, *c, *d;b = c = d = &amp;a;a = 100; 执行完这一系列指令后，a,*b,*c,*d 的值都是100. 特别地，数组其实也就是一块保存了第一个变量的指针的连续内存块，由于它是连续的，所以数组中下一个元素的地址就等于上一个元素的地址 + 1. 123456int A[100];那么 *(A + 50) 等价于 A[50]*A 等价于 A[0]A[3] - *(A + 2) 等价于 A[3] - A[2]scnaf("%d",&amp;A[7]); 等价于 scnaf("%d",A + 7); 到此为止，可能你觉得指针并没有什么实际用处，它能够做的，普通的变量都可以完成，甚至指针必须要依赖于变量存在，不先申请一些变量，光有指针好像也没有什么地址可以指向，仔细想一想，不是吗？事实上，并不是这样的。 123int *a;a = (int *)malloc(sizeof(int));*a = 4; 在这里，malloc是一个函数，用处为申请一段内存空间。它的返回值是一个void*,这种指针可以被强制转换为任何类型的指针，后面的传参就是需要申请的空间大小，如果不确定，可以像这里这样，用sizeof()代替。特别地，由于malloc函数的返回值是void*,所以在实际使用过程中要在前面加上类似于(int *)这样的标识转换为需要的指针类型。 有一个小漏洞，尝试以下写法： 12int *a;*a = 4; 相比较上面，少了malloc.但是，这时我们如果尝试输出*a，那么很有可能是可以得到4这个正确的数值的，为什么还需要使用malloc分配内存空间呢？ 事实上，我们在定义*a时，a的值像局部变量被定义的时候一样，是一个不确定的值，也就是说，a指向的内存空间有可能是一段没有被使用的，也有可能此处正存放着其它某一个变量的值，我们执行了赋值语句之后并没有出错，但是也留下了隐患。这样我们有可能在此之后又定义一些别的变量，然后这段内存空间就会被占用，那么*a的值也就丢失了，也有可能我们因此修改了别的变量的值，造成一些莫名其妙的错误。 与malloc相对的函数作用是释放一段内存空间，也就是free函数。 12int *a = (int *)malloc(sizeof(int));free(a); 这样，我们就分配了大小为int的内存空间给a，随后由将其释放掉了。 有时指针会造成一些不必要的内存浪费，例如 123int *a;a = (int *)malloc(sizeof(int));a = (int *)malloc(sizeof(int)); 如果这么做，我们相当于是先是给a分配了一段内存，随后又用另一段将其覆盖了。其实，原先的内存并没有被释放掉，存在那里的变量其实也还存在，只不过是我们已经无法访问到它了，因为我们不知道它的内存地址。这样就会造成内存的浪费，直到程序结束之后，操作系统才会回收掉这些内存空间。 应用 现在，我们已经可以动态地申请和释放内存空间了，使用指针写很多数据结构或者容器，能够更好地利用内存。在这里，我将给出基于指针实现的链表，稍微改动就可以用于完成类似于约瑟夫问题、队列安排这样的题目。 注意，这里并不是题目的完整代码，建议在理解以后自己重写。使用C++11编译。 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;typename dataType&gt;class linkedList &#123;private: struct Node &#123; dataType val; Node* nxt; &#125;; Node* newNode() &#123; Node* creat = (Node *)malloc(sizeof(Node)); creat-&gt;nxt = nullptr; &#125;public: Node *start = newNode(); unsigned int siz = 0; void addNew(dataType vlaue, Node* pos) &#123; //在pos后面添加 Node* extra = newNode(); extra-&gt;val = value; extra-&gt;nxt = pos-&gt;nxt; siz++; &#125; void del(Node* pos) &#123; //删除pos后面的一个元素 Node* delIt = pos-&gt;nxt; pos-&gt;nxt = delIt-&gt;nxt; free(delIt); siz--; &#125; dataType query(unsigned int pos) &#123; //第pos个元素 Node* nowAt; for (nowAt = start; --pos;)nowAt = nowAt-&gt;nxt; return nowAt-&gt;val; &#125; unsigned int size() &#123; //元素数量 return siz; &#125; void clear() &#123; siz = 0; Node *nowAt = start, *nxt; do &#123; nxt = nowAt-&gt;next; free(nowAt); nowAt = nxt; &#125; while (nowAt != nullptr); &#125;&#125;; 类似地，指针还可以用来写双端队列、单调栈(队列)、线段树、各种平衡树等数据结构，并且表现相当出色。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P3951]]></title>
    <url>%2F2018%2F04%2F14%2FP3951%2F</url>
    <content type="text"><![CDATA[设有两个正整数$x$,$y$且 $ \gcd(x,y)=1$ .则不能用$ax+by(a\ge 0$ 且 $b\ge 0$) 表示的最大整数为$xy-x-y$. 以下证明过程中所有未知数均为整数。 引理1 令 $k&lt;xy, a&lt;0$时$|a|&lt;y$， $b&lt;0$时$|b|&lt;x$. 则 $k=ax+by(ab&lt;0)$.证明： 设 $gx+py=1 $ 则 $k=kqx+kpy$. 不妨设 $p0$, $y&gt;0$, $qx+py=1&gt;0$ 所以$q&gt;0$. 所以$kp0​$. 因为 $qx+py=1$ 所以 $qx&gt;-py$ 且 $kqx&gt;-kpy$. 设 $kq=ny+c$, $kp=-nx-d (d&lt;x)$. 因为 $kqx+kpy=k$ 所以 $(kq-ny)x+(kp+nx)y=k$ 且 $cx+(-d)y=k (d&lt;x)$. 令 $a=c, b=-d$ 所以 $ax+by=k$ ($b&lt;0$ 且 $|b|&lt;y$). 同理,当 $q&lt;0$ 时, $(-c)x+dy=k (c&lt;y)$. 令 $a=-c, b=d$ 所以 $ax+by=k$ ($a&lt;0$ 且 $|a|&lt;y$). 综上, $k=ax+by$ ($k&lt;xy$, $ab&lt;0$, $a&lt;0$时$|a|&lt;y$， $b&lt;0$时$|b|&lt;x$). 引理2 $xy-x-y$ 无法被表示为 $ax+by$ 的和.证明： 若 $xy-x-y = ax+by$ 则 $xy=(a+1)x+(b+1)y $ 因为 $a&gt;=0, b&gt;=0$ 所以 $a+1&gt;=1, b+1&gt;=1.$ 因为 $\gcd(x,y)=1$ 所以 $lcm(x,y)=xy$. 令 $c,d$ 满足 $cx=dy$. 且 $y-c=a+1$. 因为 $xy=xy-cx+dy=(y-c)x+dy$ 所以 $d=b+1$. 所以 $a+1&gt;1, y-c&gt;=1, c&lt;y$. 又因为 $cx=dy$ 且 $lcm(x,y)=xy$ 所以 $c&gt;=y, d&gt;=x$. 因为 $c&lt;y$ 且 $c\ge y$, 矛盾. 所以 $xy-x-y=ax+by$ 不成立. 所以 $xy-x-y$ 无法被表示为 $ax+by$ 的和. 正题证明： 设 $m$ 为正整数. 当 $m&gt;2xy$ 时, $m=txy+k \space (t\ge 2) = (a+ty)x+by \space (a&lt;0) = ax+(b+tx)y \space (b&lt;0)$. $\because$ 当 $a]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P1160]]></title>
    <url>%2F2018%2F01%2F13%2FP1160%2F</url>
    <content type="text"><![CDATA[题目还是非常有意思的，重点是链表读取效率的优化。 首先，既然题目中多次提到了“移去”、“插入”等字眼，很明显需要用到链表。 在这里，我们使用一个结构体存储这个链表，并使用一个head指针指向队列的队首，方便输出时使用。 123456struct queueDat&#123; int ID; //该同学的号码 queueDat *front = NULL, *back = NULL;&#125;que[100001];queueDat *head = &amp;que[1]; 使用链表，可以极大地方便我们进行*插入*和*删除*的操作，不过，相比较于数组，链表最大的弊端就是在读取时不方便，我们为了寻找一个数据，可能需要从链表的某一个地方开始，一个个地找，这样就浪费了大量的时间，程序的效率极为低下。 幸运的是，在这道题中，所有的数据均为整数，所以我们可以让同学们的号码和que一 一对应。也就是说，如果需要寻找i号同学，直接使用que[i]即可，这么做不仅使我们的代码更为简单易懂，更重要的是节约了大量的宝贵时间。 for (int i = 1; i &lt; 100001; i++) que[i].ID = i; //que[i]对应i号同学 我们还需要做的另外一件事，就是设置好已经在队列中的1号同学的数据信息，由于在程序刚刚开始运行时，队列中只有1号同学一个人，为了方便后面的*插入*和*删除*的操作，在这里我使用了双向链表，因此，1号同学的前面和后面都是1号同学。 que[1].back = &amp;que[1]; que[1].front = &amp;que[1]; 接下来我们就可以开始构建整个队列了，本题当中，比较好的选择是边读边做，一次读完不仅没有必要，而且会复杂化我们的程序。 在后面的处理中，移去的同学编号有重复，因此我们可以使用一个布尔数组判断i号同学是否在队列之中。 bool inQueue[100001]; memset(inQueue, false, sizeof(inQueue)); inQueue[1] = true; 12345678910for (int i = 1; i &lt; 100001; i++) que[i].ID = i; //que[i]对应i号同学que[1].back = &amp;que[1]; que[1].front = &amp;que[1];int totStudents, a, b;cin &gt;&gt; totStudents; //同学总数for (int i = 2; i &lt;= totStudents; i++) //i代表同学的号码&#123; inQueue[i] = true; //确认i号同学在队列当中 cin &gt;&gt; a &gt;&gt; b; //插入在a同学的 左边或右边&#125; 至此，我们只是读取了需要的数据，并没有在链表中进行相应的操作。所以，我们需要一些代码来实现插入的过程。这里我把它封装成了一个函数_add. 1234567891011121314151617181920212223 void _add(int num, int ID, bool back)&#123; queueDat *find = &amp;que[ID], *add = &amp;que[num]; if (back) //插入在后面 &#123; add-&gt;front = find; add-&gt;back = find-&gt;back; find-&gt;back = add; find = find-&gt;back-&gt;back; find-&gt;front = add; return; &#125; else //插入在前面 &#123; add-&gt;back = find; add-&gt;front = find-&gt;front; find = find-&gt;front; find-&gt;back = add; find = find-&gt;back-&gt;back; find-&gt;front = add; if (ID == head-&gt;ID)head = add; &#125;&#125; 在这当中，num代表需要插入的数，ID代表插入到的位置，back则表示是否插入在该同学的后面。首先定义指针find和add，分别指向需要插入的数和插入到的位置，之后进行相应的操作。这些乱七八糟的代码可能会让不少初学者感到不适，所以在这里详细解释一下，以back==true的情况——即插入在后面为例。 我们需要在一条完整的双向链表中插入一项，更改的数据包括四项：我们需要插入的数据的front和back指针，以及被我们“破坏了”的find-&gt;next指针和原本是find-&gt;back的front指针。 add-&gt;front = find; add-&gt;back = find-&gt;back; 这两行代码设置好了add即需要插入的数的两个指针，让它们分别指向插入到的位置和这个位置下一个，也就是back指针指向的位置。 find-&gt;back = add; 接着，设置好find的back指针，让它指向需要添加的数。 find = find-&gt;back-&gt;back; find-&gt;front = add; 然后，来到原本是find-&gt;back的位置，设置好front指针。这样，整个添加过程就完成了，插入在前面与后面的原理基本都是一样的。只不过若是插入在前面，有可能这个同学插入到了原先队首同学前，所以完成插入后需要再判断一下，更新一下队首的指针。 if (ID == head-&gt;ID)head = add; 我们完成了实现插入的函数之后，删除就变得非常简单了，实现起来并没有什么困难（如果理解了插入的过程的话）。 123456789 void _cut(int ID)&#123; queueDat *cut = &amp;que[ID]; if (cut-&gt;ID == head-&gt;ID)head = cut-&gt;back; cut = cut-&gt;front; cut-&gt;back = cut-&gt;back-&gt;back; cut = cut-&gt;back; cut-&gt;front = cut-&gt;front-&gt;front;&#125; 到这里，程序主体部分就写完了，剩下的就是非常简单的模拟，按照题目的要求一步步来即可。以下是完整代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstring&gt; //仅用作memsetusing namespace std;struct queueDat&#123; int ID; //该同学的号码 queueDat *front = NULL, *back = NULL;&#125;que[100001];queueDat *head = &amp;que[1];void _cut(int ID)&#123; queueDat *cut = &amp;que[ID]; if (cut-&gt;ID == head-&gt;ID)head = cut-&gt;back; cut = cut-&gt;front; cut-&gt;back = cut-&gt;back-&gt;back; cut = cut-&gt;back; cut-&gt;front = cut-&gt;front-&gt;front;&#125;void _add(int num, int ID, bool back)&#123; queueDat *find = &amp;que[ID], *add = &amp;que[num]; if (back) //插入在后面 &#123; add-&gt;front = find; add-&gt;back = find-&gt;back; find-&gt;back = add; find = find-&gt;back-&gt;back; find-&gt;front = add; return; &#125; else //插入在前面 &#123; add-&gt;back = find; add-&gt;front = find-&gt;front; find = find-&gt;front; find-&gt;back = add; find = find-&gt;back-&gt;back; find-&gt;front = add; if (ID == head-&gt;ID)head = add; &#125;&#125;int main()&#123; bool inQueue[100001]; memset(inQueue, false, sizeof(inQueue)); inQueue[1] = true; for (int i = 1; i &lt; 100001; i++) que[i].ID = i; //que[i]对应i号同学 que[1].back = &amp;que[1]; que[1].front = &amp;que[1]; int totStudents, a, b; cin &gt;&gt; totStudents; //同学总数 for (int i = 2; i &lt;= totStudents; i++) //i代表同学的号码 &#123; inQueue[i] = true; //确认i号同学在队列当中 cin &gt;&gt; a &gt;&gt; b; //插入在a同学的 左边或右边 _add(i, a, ((b == 0) ? false : true)); &#125; cin &gt;&gt; totStudents; for (int i = 0; i &lt; totStudents; i++) &#123; cin &gt;&gt; a; if (inQueue[a] == true) &#123; inQueue[a] = false; _cut(a); &#125; &#125; b = head-&gt;ID; do &#123; cout &lt;&lt; head-&gt;ID &lt;&lt; " "; head = head-&gt;back; &#125; while (b != head-&gt;ID); cout &lt;&lt; endl; system("pause"); return 0;&#125; 这道题目对于才刚刚接触链表不久的我和其它初学者来说或许有些难度，不过只要正确理解并掌握了链表的插入和删除操作，这种数据结构的相关题目其实也并没有多难。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P1996]]></title>
    <url>%2F2018%2F01%2F13%2FP1996%2F</url>
    <content type="text"><![CDATA[相信不少人都会发现，这题数据非常小，可以用很多比较暴力的奇怪算法。不过，命题者的初衷是希望我们使用链表进行模拟。 在这里，我使用了一个结构体peo存储了一个双向链表： 12345struct peo&#123; int ID; //编号 peo *next = NULL, *front = NULL;&#125;n[100]; 其中ID代表这个人的编号，输出时使用，另外两个指针分别指向上一个和下一个人，不过我们先要对其初始化。使用两个变量tot, outNum来分别存储总人数和出局的数，然后让链表之间互相链接，最后首尾相连。 12345 for (int i = 1; i &lt; tot - 1; i++) &#123; n[i].front = &amp;n[i - 1]; n[i].next = &amp;n[i + 1]; n[i].ID = i + 1; &#125;n[0].front = &amp;n[tot - 1]; n[0].next = &amp;n[1]; n[tot - 1].front = &amp;n[tot - 2]; n[tot - 1].next = &amp;n[0];n[0].ID = 1; n[tot - 1].ID = tot;//初始化链表 链表初始化完成之后，我们可以使用一个结构体指针now来表示我们现在模拟到哪一个人了。 peo *now = &amp;n[0]; //指向目前报数的人的指针 最后，我们需要考虑怎么删除链表当中的某一项，事实上这一非常简单，将now-&gt;front的next更改为now-&gt;next，然后now-&gt;next的front更改为now-&gt;front就可以了。我们使用一个函数实现这一过程。 1234567 void _cut(peo *num)&#123; num = num-&gt;front; num-&gt;next = num-&gt;next-&gt;next; num = num-&gt;next; num-&gt;front = num-&gt;front-&gt;front;&#125; 这样，剩下的就是非常简单的模拟了，过程虽然有些复杂，但是这大致就是题目期望我们去做的全部过程。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;struct peo&#123; int ID; //编号 peo *next = NULL, *front = NULL;&#125;n[100];void _cut(peo *num)&#123; num = num-&gt;front; num-&gt;next = num-&gt;next-&gt;next; num = num-&gt;next; num-&gt;front = num-&gt;front-&gt;front;&#125;int main()&#123; int tot, outNum, nowNum = 1; peo *now = &amp;n[0]; //指向目前报数的人的指针 cin &gt;&gt; tot &gt;&gt; outNum; //数据读入 for (int i = 1; i &lt; tot - 1; i++) &#123; n[i].front = &amp;n[i - 1]; n[i].next = &amp;n[i + 1]; n[i].ID = i + 1; &#125; n[0].front = &amp;n[tot - 1]; n[0].next = &amp;n[1]; n[tot - 1].front = &amp;n[tot - 2]; n[tot - 1].next = &amp;n[0]; n[0].ID = 1; n[tot - 1].ID = tot; //初始化链表 while (tot &gt; 0) &#123; if (nowNum == outNum) &#123; cout &lt;&lt; now-&gt;ID &lt;&lt; " "; //输出出局的人的编号 _cut(now); //出局 nowNum = 1; //初始化数字 tot--; //总人数-1 now = now-&gt;next; //下一个人 &#125; else &#123; nowNum++; //数字+1 now = now-&gt;next; //下一个人 &#125; &#125; return 0;&#125; 方法2：队列 若是使用链表，这题的复杂程度无疑大大上升了，其实，我们完全用不着那么麻烦，一个个地报数，可以想象成一个队列，一个人报完数后，判断他所报的数是不是出局的数，如果是，直接弹出，但若不是，将其移动至队尾即可。 我们使用一个队列q进行模拟，在读取总人数和出局数字后，把这些人一个个地压入队列尾部。在使用队列之前，需要先加上头文件queue。 1234int tot, outNum, nowNum = 1; queue&lt;int&gt; q; cin &gt;&gt; tot &gt;&gt; outNum; //读取数据 for (int i = 1; i &lt;= tot; i++)q.push(i); //初始化队列 完成这些之后，开始模拟，整个过程也非常简单，在这里就不详细解释了。以下是完整代码。 12345678910111213141516171819202122232425262728 #include&lt;iostream&gt; #include&lt;queue&gt; using namespace std; int main() &#123; int tot, outNum, nowNum = 1; queue&lt;int&gt; q; cin &gt;&gt; tot &gt;&gt; outNum; //读取数据 for (int i = 1; i &lt;= tot; i++)q.push(i); //初始化队列 while (!q.empty()) //在队列不为空时继续模拟 &#123; if (nowNum == outNum) &#123; cout &lt;&lt; q.front() &lt;&lt; " "; //打印出局的人的编号 q.pop(); //出局 nowNum = 1; //初始化现在的数字 &#125; else &#123; nowNum++; q.push(q.front()); //排至队尾 q.pop(); &#125; &#125; cout &lt;&lt; endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P1019]]></title>
    <url>%2F2018%2F01%2F02%2FP1019%2F</url>
    <content type="text"><![CDATA[重点：单词重叠的部分不好操作 在搜索的基础上代码需要有所修改。 首先，题目包含的接龙要求大致有以下几点：1.同一个单词最多出现2次 2.相邻的两部分不能存在包含关系 3.在两个单词相连时，其重合部分合为一部分。 我们很容易就可以想到，使用一个结构体用于存储各个单词的数据，包括单词本身，它的实际长度以及可供使用的剩余次数（初始值为2）.如下： 12345struct words&#123; int left = 2, tail = 0; //剩余的使用次数 单词实际长度 char word[101]; //内容&#125;words[22]; 我们可以使用一个字符变量start用来存储开头的字母，然后即可开始搜索，由于start当中的字符并不会被计入总长度，所以可以先通过一个循环，找到符合题意的单词，然后再以这个单词作为开头，进行深搜。 12345678cin &gt;&gt; start; for (int i = 0; i &lt; wordTot; i++) if (words[i].word[0] == start) &#123; words[i].left--; dfs(words[i].word, words[i].tail); //目前龙中最后一个单词 长度 words[i].left++; &#125; 由于单词接龙中相邻的两部分不能存在包含关系，所以无论龙有多长，只需要考虑最后一个加入的单词能够和那些单词拼接即可。在这里，我们可以编写一个函数juj来判断两个单词之间重合部分长度的最小值。 1234567891011121314 int juj(char a[], char b[])&#123; int al = strlen(a), bl = strlen(b), j; bool flag = true; for (int i = 1; i &lt; al &amp;&amp; i &lt; bl; i++) &#123; flag = true; for (j = 0; j &lt; i; j++) if (a[al - i + j] != b[j]) &#123; flag = false; break; &#125; if (flag) return i; &#125; return 0;&#125; 这个函数主要的原理是：在a，b两个字符串当中一个个地尝试可能重合部分的长度，并把这个长度作为一个数值返回。如果这个长度已经不小于当中最短字符串的长度，那么说明这两个字符串没有符合题意的重合部分，juj将返回0。 处理好了单词重合部分，剩下的就是搜索了。这部分比较简单，直接照着深搜的伪代码模板进行填充相应的代码即可。 12345678910111213141516 void dfs(char tail[], int num)&#123; _max = max(_max, num); //更新最大值 int a; //两个单词重合部分的长度 for (int i = 0; i &lt; wordTot; i++) if (words[i].left &gt; 0) &#123; a = juj(tail, words[i].word); if (a != 0) //判断是否符合题意 &#123; words[i].left--; dfs(words[i].word, num + words[i].tail - a); //下一步搜索 words[i].left++; &#125; &#125;&#125; 这样，程序就基本完成了，下面是完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int wordTot, _max = 0; struct words &#123; int left = 2, tail = 0; //剩余的使用次数 单词实际长度 char word[101]; //内容 &#125;words[22]; int juj(char a[], char b[]) &#123; int al = strlen(a), bl = strlen(b), j; bool flag = true; for (int i = 1; i &lt; al &amp;&amp; i &lt; bl; i++) &#123; flag = true; for (j = 0; j &lt; i; j++) if (a[al - i + j] != b[j]) &#123; flag = false; break; &#125; if (flag) return i; &#125; return 0; &#125; void dfs(char tail[], int num) &#123; _max = max(_max, num); //更新最大值 int a; //两个单词重合部分的长度 for (int i = 0; i &lt; wordTot; i++) if (words[i].left &gt; 0) &#123; a = juj(tail, words[i].word); if (a != 0) //判断是否符合题意 &#123; words[i].left--; dfs(words[i].word, num + words[i].tail - a); //下一步搜索 words[i].left++; &#125; &#125; &#125; int main() &#123; char start; cin &gt;&gt; wordTot; for (int i = 0; i &lt; wordTot; i++) &#123; cin &gt;&gt; words[i].word; words[i].tail = strlen(words[i].word); &#125; cin &gt;&gt; start; for (int i = 0; i &lt; wordTot; i++) if (words[i].word[0] == start) &#123; words[i].left--; dfs(words[i].word, words[i].tail); //目前龙中最后一个单词 长度 words[i].left++; &#125; cout &lt;&lt; _max &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>暴力/枚举</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】洛谷P2626]]></title>
    <url>%2F2017%2F12%2F31%2FP2626%2F</url>
    <content type="text"><![CDATA[基本解题思路： 使用两个int变量a和b进行模拟，a,b初始值均为1，每循环一次执行一次a += b; b += a; 。这样，数列中1,1,2,3,5,8…分别对应变量a,b,a,b,a,b…不难发现若n为偶数则对应b，否则为a。而循环的次数为((n + 1) / 2 - 1) 。 我们很容易就可以写出如下代码： 1234567int a = 1, b = 1, n; bool isA; cin &gt;&gt; n; //数列中第n个数 isA = n % 2 == 0 ? false : true; //判断这个数对应的是变量a还是b n = (n + 1) / 2 - 1; //总共的循环次数 for (int i = 0; i &lt; n; i++) a += b; b += a; 接着，我们需要将求出的数mod 2^31。由于int最大可存储数值就是2^31，所以若变量达到了2147483648，就会变为-2147483648，这个数正好是2^31，所以只需要在变量a,b小于0（溢出）时加上2^31即可。 修改一下代码之后可以得到 123456for (int i = 0; i &lt; n; i++) &#123; a += b; b += a; if (b &lt; 0)b += 2147483648; if (a &lt; 0)a += 2147483648; &#125; 这时，尝试输出一下得到的数，符合题意。随后就是很简单的分解质因数过程，在这里我使用了一个dev函数完成 12345678910111213141516171819bool isPrime(int inp) //判断质数&#123; int a = sqrt(inp); //储存inp开方后的结果，提高效率 for (int i = 2; i &lt;= a; i++) if (inp%i == 0) return false; return true;&#125;void dev(int num) //输出&#123; cout &lt;&lt; num &lt;&lt; "="; while (!isPrime(num)) &#123; while (num % 2 == 0 &amp;&amp; num != 2) &#123; num /= 2; cout &lt;&lt; 2 &lt;&lt; "*"; &#125; for (int i = 3; i &lt; num; i+=2) if (num%i == 0 &amp;&amp; isPrime(i)) &#123; cout &lt;&lt; i &lt;&lt; "*"; num /= i; break; &#125; &#125; cout &lt;&lt; num &lt;&lt; endl;&#125; 完整的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; bool isPrime(int inp) //判断质数 &#123; int a = sqrt(inp); //储存inp开方后的结果，提高效率 for (int i = 2; i &lt;= a; i++) if (inp%i == 0) return false; return true; &#125; void dev(int num) //输出 &#123; cout &lt;&lt; num &lt;&lt; "="; while (!isPrime(num)) &#123; while (num % 2 == 0 &amp;&amp; num != 2) &#123; num /= 2; cout &lt;&lt; 2 &lt;&lt; "*"; &#125; for (int i = 3; i &lt; num; i+=2) if (num%i == 0 &amp;&amp; isPrime(i)) &#123; cout &lt;&lt; i &lt;&lt; "*"; num /= i; break; &#125; &#125; cout &lt;&lt; num &lt;&lt; endl; &#125; int main() &#123; int a = 1, b = 1, n; bool isA; cin &gt;&gt; n; //数列中第n个数 isA = n % 2 == 0 ? false : true; //判断这个数对应的是变量a还是b n = (n + 1) / 2 - 1; //总共的循环次数 for (int i = 0; i &lt; n; i++) &#123; a += b; b += a; if (b &lt; 0)b += 2147483648; if (a &lt; 0)a += 2147483648; &#125; dev(isA ? a : b); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
</search>
